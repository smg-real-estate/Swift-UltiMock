import CoreLocation
import TestPackage
import UltiMock
import XCTest

// Generated by UltiMock. DO NOT EDIT!

open class CLLocationManagerMock: CLLocationManager, Mock {
    enum Methods {
        static var requestWhenInUseAuthorization_sync_ret_Void: MockMethod {
            .init { _ in
                "requestWhenInUseAuthorization()"
            }
        }

        static var requestAlwaysAuthorization_sync_ret_Void: MockMethod {
            .init { _ in
                "requestAlwaysAuthorization()"
            }
        }

        static var requestTemporaryFullAccuracyAuthorization_syncwithPurposeKey_purposeKey_String_completion_completion__lp__lp_anyError_opt__rp__ret_Void_rp__opt__ret_Void: MockMethod {
            .init {
                "requestTemporaryFullAccuracyAuthorization(withPurposeKey: \"\($0[0]!)\", completion: \($0[1] ?? "nil"))"
            }
        }

        static var requestTemporaryFullAccuracyAuthorization_asyncwithPurposeKey_purposeKey_String_ret_Void: MockMethod {
            .init {
                "requestTemporaryFullAccuracyAuthorization(withPurposeKey: \"\($0[0]!)\")"
            }
        }

        static var startUpdatingLocation_sync_ret_Void: MockMethod {
            .init { _ in
                "startUpdatingLocation()"
            }
        }

        static var stopUpdatingLocation_sync_ret_Void: MockMethod {
            .init { _ in
                "stopUpdatingLocation()"
            }
        }

        static var requestLocation_sync_ret_Void: MockMethod {
            .init { _ in
                "requestLocation()"
            }
        }

        static var startUpdatingHeading_sync_ret_Void: MockMethod {
            .init { _ in
                "startUpdatingHeading()"
            }
        }

        static var dismissHeadingCalibrationDisplay_sync_ret_Void: MockMethod {
            .init { _ in
                "dismissHeadingCalibrationDisplay()"
            }
        }

        static var startMonitoringSignificantLocationChanges_sync_ret_Void: MockMethod {
            .init { _ in
                "startMonitoringSignificantLocationChanges()"
            }
        }

        static var stopMonitoringSignificantLocationChanges_sync_ret_Void: MockMethod {
            .init { _ in
                "stopMonitoringSignificantLocationChanges()"
            }
        }

        static var startMonitoring_syncfor_region_CLRegion_desiredAccuracy_accuracy_CLLocationAccuracy_ret_Void: MockMethod {
            .init {
                "startMonitoring(for: \($0[0] ?? "nil"), desiredAccuracy: \($0[1] ?? "nil"))"
            }
        }

        static var stopMonitoring_syncfor_region_CLRegion_ret_Void: MockMethod {
            .init {
                "stopMonitoring(for: \($0[0] ?? "nil"))"
            }
        }

        static var startMonitoring_syncfor_region_CLRegion_ret_Void: MockMethod {
            .init {
                "startMonitoring(for: \($0[0] ?? "nil"))"
            }
        }

        static var requestState_syncfor_region_CLRegion_ret_Void: MockMethod {
            .init {
                "requestState(for: \($0[0] ?? "nil"))"
            }
        }

        static var startRangingBeacons_syncin_region_CLBeaconRegion_ret_Void: MockMethod {
            .init {
                "startRangingBeacons(in: \($0[0] ?? "nil"))"
            }
        }

        static var stopRangingBeacons_syncin_region_CLBeaconRegion_ret_Void: MockMethod {
            .init {
                "stopRangingBeacons(in: \($0[0] ?? "nil"))"
            }
        }

        static var startRangingBeacons_syncsatisfying_constraint_CLBeaconIdentityConstraint_ret_Void: MockMethod {
            .init {
                "startRangingBeacons(satisfying: \($0[0] ?? "nil"))"
            }
        }

        static var stopRangingBeacons_syncsatisfying_constraint_CLBeaconIdentityConstraint_ret_Void: MockMethod {
            .init {
                "stopRangingBeacons(satisfying: \($0[0] ?? "nil"))"
            }
        }

        static var allowDeferredLocationUpdates_syncuntilTraveled_distance_CLLocationDistance_timeout_timeout_TimeInterval_ret_Void: MockMethod {
            .init {
                "allowDeferredLocationUpdates(untilTraveled: \($0[0] ?? "nil"), timeout: \($0[1] ?? "nil"))"
            }
        }

        static var disallowDeferredLocationUpdates_sync_ret_Void: MockMethod {
            .init { _ in
                "disallowDeferredLocationUpdates()"
            }
        }

        static var finalize_sync_ret_Void: MockMethod {
            .init { _ in
                "finalize()"
            }
        }

        static var copy_sync_ret_Any: MockMethod {
            .init { _ in
                "copy()"
            }
        }

        static var mutableCopy_sync_ret_Any: MockMethod {
            .init { _ in
                "mutableCopy()"
            }
        }

        static var method_syncfor_aSelector_Selector_impopt__ret_IMP_impopt_: MockMethod {
            .init {
                "method(for: \($0[0] ?? "nil"))"
            }
        }

        static var doesNotRecognizeSelector_sync_aSelector_Selector_impopt__ret_Void: MockMethod {
            .init {
                "doesNotRecognizeSelector(\($0[0] ?? "nil"))"
            }
        }

        static var forwardingTarget_syncfor_aSelector_Selector_impopt__ret_Any_opt_: MockMethod {
            .init {
                "forwardingTarget(for: \($0[0] ?? "nil"))"
            }
        }

        static var isEqual_sync_object_Any_opt__ret_Bool: MockMethod {
            .init {
                "isEqual(\($0[0] ?? "nil"))"
            }
        }

        static var self_sync_ret_Self: MockMethod {
            .init { _ in
                "`self`()"
            }
        }

        static var perform_sync_aSelector_Selector_impopt__ret_Unmanaged_lab_AnyObject_rab__impopt_: MockMethod {
            .init {
                "perform(\($0[0] ?? "nil"))"
            }
        }

        static var perform_sync_aSelector_Selector_impopt__with_object_Any_impopt__ret_Unmanaged_lab_AnyObject_rab__impopt_: MockMethod {
            .init {
                "perform(\($0[0] ?? "nil"), with: \($0[1] ?? "nil"))"
            }
        }

        static var perform_sync_aSelector_Selector_impopt__with_object1_Any_impopt__with_object2_Any_impopt__ret_Unmanaged_lab_AnyObject_rab__impopt_: MockMethod {
            .init {
                "perform(\($0[0] ?? "nil"), with: \($0[1] ?? "nil"), with: \($0[2] ?? "nil"))"
            }
        }

        static var isProxy_sync_ret_Bool: MockMethod {
            .init { _ in
                "isProxy()"
            }
        }

        static var isKind_syncof_aClass_AnyClass_ret_Bool: MockMethod {
            .init {
                "isKind(of: \($0[0] ?? "nil"))"
            }
        }

        static var isMember_syncof_aClass_AnyClass_ret_Bool: MockMethod {
            .init {
                "isMember(of: \($0[0] ?? "nil"))"
            }
        }

        static var conforms_syncto_aProtocol_Protocol_ret_Bool: MockMethod {
            .init {
                "conforms(to: \($0[0] ?? "nil"))"
            }
        }

        static var responds_syncto_aSelector_Selector_impopt__ret_Bool: MockMethod {
            .init {
                "responds(to: \($0[0] ?? "nil"))"
            }
        }

        static var authorizationStatus_sync_ret_CLAuthorizationStatus: MockMethod {
            .init { _ in
                "authorizationStatus"
            }
        }

        static var accuracyAuthorization_sync_ret_CLAccuracyAuthorization: MockMethod {
            .init { _ in
                "accuracyAuthorization"
            }
        }

        static var isAuthorizedForWidgetUpdates_sync_ret_Bool: MockMethod {
            .init { _ in
                "isAuthorizedForWidgetUpdates"
            }
        }

        static var delegate_sync_ret_anyCLLocationManagerDelegate_opt_: MockMethod {
            .init { _ in
                "delegate"
            }
        }

        static var set_delegate_sync_ret_anyCLLocationManagerDelegate_opt_: MockMethod {
            .init {
                "delegate = \($0[0] ?? "nil")"
            }
        }

        static var locationServicesEnabled_sync_ret_Bool: MockMethod {
            .init { _ in
                "locationServicesEnabled"
            }
        }

        static var purpose_sync_ret_String_opt_: MockMethod {
            .init { _ in
                "purpose"
            }
        }

        static var set_purpose_sync_ret_String_opt_: MockMethod {
            .init {
                "purpose = \($0[0] ?? "nil")"
            }
        }

        static var activityType_sync_ret_CLActivityType: MockMethod {
            .init { _ in
                "activityType"
            }
        }

        static var set_activityType_sync_ret_CLActivityType: MockMethod {
            .init {
                "activityType = \($0[0] ?? "nil")"
            }
        }

        static var distanceFilter_sync_ret_CLLocationDistance: MockMethod {
            .init { _ in
                "distanceFilter"
            }
        }

        static var set_distanceFilter_sync_ret_CLLocationDistance: MockMethod {
            .init {
                "distanceFilter = \($0[0] ?? "nil")"
            }
        }

        static var desiredAccuracy_sync_ret_CLLocationAccuracy: MockMethod {
            .init { _ in
                "desiredAccuracy"
            }
        }

        static var set_desiredAccuracy_sync_ret_CLLocationAccuracy: MockMethod {
            .init {
                "desiredAccuracy = \($0[0] ?? "nil")"
            }
        }

        static var pausesLocationUpdatesAutomatically_sync_ret_Bool: MockMethod {
            .init { _ in
                "pausesLocationUpdatesAutomatically"
            }
        }

        static var set_pausesLocationUpdatesAutomatically_sync_ret_Bool: MockMethod {
            .init {
                "pausesLocationUpdatesAutomatically = \($0[0] ?? "nil")"
            }
        }

        static var allowsBackgroundLocationUpdates_sync_ret_Bool: MockMethod {
            .init { _ in
                "allowsBackgroundLocationUpdates"
            }
        }

        static var set_allowsBackgroundLocationUpdates_sync_ret_Bool: MockMethod {
            .init {
                "allowsBackgroundLocationUpdates = \($0[0] ?? "nil")"
            }
        }

        static var location_sync_ret_CLLocation_opt_: MockMethod {
            .init { _ in
                "location"
            }
        }

        static var headingAvailable_sync_ret_Bool: MockMethod {
            .init { _ in
                "headingAvailable"
            }
        }

        static var headingFilter_sync_ret_CLLocationDegrees: MockMethod {
            .init { _ in
                "headingFilter"
            }
        }

        static var set_headingFilter_sync_ret_CLLocationDegrees: MockMethod {
            .init {
                "headingFilter = \($0[0] ?? "nil")"
            }
        }

        static var headingOrientation_sync_ret_CLDeviceOrientation: MockMethod {
            .init { _ in
                "headingOrientation"
            }
        }

        static var set_headingOrientation_sync_ret_CLDeviceOrientation: MockMethod {
            .init {
                "headingOrientation = \($0[0] ?? "nil")"
            }
        }

        static var heading_sync_ret_CLHeading_opt_: MockMethod {
            .init { _ in
                "heading"
            }
        }

        static var maximumRegionMonitoringDistance_sync_ret_CLLocationDistance: MockMethod {
            .init { _ in
                "maximumRegionMonitoringDistance"
            }
        }

        static var monitoredRegions_sync_ret_Set_lab_CLRegion_rab_: MockMethod {
            .init { _ in
                "monitoredRegions"
            }
        }

        static var rangedRegions_sync_ret_Set_lab_CLRegion_rab_: MockMethod {
            .init { _ in
                "rangedRegions"
            }
        }

        static var rangedBeaconConstraints_sync_ret_Set_lab_CLBeaconIdentityConstraint_rab_: MockMethod {
            .init { _ in
                "rangedBeaconConstraints"
            }
        }

        static var hash_sync_ret_Int: MockMethod {
            .init { _ in
                "hash"
            }
        }

        static var superclass_sync_ret_AnyClass_opt_: MockMethod {
            .init { _ in
                "superclass"
            }
        }

        static var description_sync_ret_String: MockMethod {
            .init { _ in
                "description"
            }
        }

        static var debugDescription_sync_ret_String: MockMethod {
            .init { _ in
                "debugDescription"
            }
        }
    }

    public struct MethodExpectation<Signature> {
        public let expectation: Recorder.Expectation

        init(method: MockMethod, parameters: [AnyParameter]) {
            self.expectation = .init(
                method: method,
                parameters: parameters
            )
        }

        @available(macOS 10.15, *)
        public static func requestWhenInUseAuthorization() -> Self
        where Signature == () -> Void {
            .init(
                method: Methods.requestWhenInUseAuthorization_sync_ret_Void,
                parameters: []
            )
        }

        @available(macOS 10.15, *)
        public static func requestAlwaysAuthorization() -> Self
        where Signature == () -> Void {
            .init(
                method: Methods.requestAlwaysAuthorization_sync_ret_Void,
                parameters: []
            )
        }

        @available(macOS 11.0, *)
        public static func requestTemporaryFullAccuracyAuthorization(withPurposeKey purposeKey: Parameter<String>, completion: Parameter<(@Sendable ((any Error)?) -> Void)?>) -> Self
        where Signature == (_ purposeKey: String, _ completion: (@Sendable ((any Error)?) -> Void)?) -> Void {
            .init(
                method: Methods.requestTemporaryFullAccuracyAuthorization_syncwithPurposeKey_purposeKey_String_completion_completion__lp__lp_anyError_opt__rp__ret_Void_rp__opt__ret_Void,
                parameters: [purposeKey.anyParameter, completion.anyParameter]
            )
        }

        @available(macOS 11.0, *)
        public static func requestTemporaryFullAccuracyAuthorization(withPurposeKey purposeKey: Parameter<String>) -> Self
        where Signature == (_ purposeKey: String) async throws -> Void {
            .init(
                method: Methods.requestTemporaryFullAccuracyAuthorization_asyncwithPurposeKey_purposeKey_String_ret_Void,
                parameters: [purposeKey.anyParameter]
            )
        }

        public static func startUpdatingLocation() -> Self
        where Signature == () -> Void {
            .init(
                method: Methods.startUpdatingLocation_sync_ret_Void,
                parameters: []
            )
        }

        public static func stopUpdatingLocation() -> Self
        where Signature == () -> Void {
            .init(
                method: Methods.stopUpdatingLocation_sync_ret_Void,
                parameters: []
            )
        }

        @available(macOS 10.14, *)
        public static func requestLocation() -> Self
        where Signature == () -> Void {
            .init(
                method: Methods.requestLocation_sync_ret_Void,
                parameters: []
            )
        }

        @available(macOS 10.15, *)
        public static func startUpdatingHeading() -> Self
        where Signature == () -> Void {
            .init(
                method: Methods.startUpdatingHeading_sync_ret_Void,
                parameters: []
            )
        }

        @available(macOS 10.15, *)
        public static func dismissHeadingCalibrationDisplay() -> Self
        where Signature == () -> Void {
            .init(
                method: Methods.dismissHeadingCalibrationDisplay_sync_ret_Void,
                parameters: []
            )
        }

        @available(macOS 10.7, *)
        public static func startMonitoringSignificantLocationChanges() -> Self
        where Signature == () -> Void {
            .init(
                method: Methods.startMonitoringSignificantLocationChanges_sync_ret_Void,
                parameters: []
            )
        }

        @available(macOS 10.7, *)
        public static func stopMonitoringSignificantLocationChanges() -> Self
        where Signature == () -> Void {
            .init(
                method: Methods.stopMonitoringSignificantLocationChanges_sync_ret_Void,
                parameters: []
            )
        }

        @available(macOS, introduced: 10.15, deprecated: 10.15)
        public static func startMonitoring(for region: Parameter<CLRegion>, desiredAccuracy accuracy: Parameter<CLLocationAccuracy>) -> Self
        where Signature == (_ region: CLRegion, _ accuracy: Double) -> Void {
            .init(
                method: Methods.startMonitoring_syncfor_region_CLRegion_desiredAccuracy_accuracy_CLLocationAccuracy_ret_Void,
                parameters: [region.anyParameter, accuracy.anyParameter]
            )
        }

        @available(macOS, introduced: 10.8, deprecated: 100_000)
        public static func stopMonitoring(for region: Parameter<CLRegion>) -> Self
        where Signature == (_ region: CLRegion) -> Void {
            .init(
                method: Methods.stopMonitoring_syncfor_region_CLRegion_ret_Void,
                parameters: [region.anyParameter]
            )
        }

        @available(macOS, introduced: 10.8, deprecated: 100_000)
        public static func startMonitoring(for region: Parameter<CLRegion>) -> Self
        where Signature == (_ region: CLRegion) -> Void {
            .init(
                method: Methods.startMonitoring_syncfor_region_CLRegion_ret_Void,
                parameters: [region.anyParameter]
            )
        }

        @available(macOS, introduced: 10.8, deprecated: 100_000)
        public static func requestState(for region: Parameter<CLRegion>) -> Self
        where Signature == (_ region: CLRegion) -> Void {
            .init(
                method: Methods.requestState_syncfor_region_CLRegion_ret_Void,
                parameters: [region.anyParameter]
            )
        }

        @available(macOS, introduced: 11.0, deprecated: 11.0, message: "Use -startRangingBeaconsSatisfyingConstraint:")
        public static func startRangingBeacons(in region: Parameter<CLBeaconRegion>) -> Self
        where Signature == (_ region: CLBeaconRegion) -> Void {
            .init(
                method: Methods.startRangingBeacons_syncin_region_CLBeaconRegion_ret_Void,
                parameters: [region.anyParameter]
            )
        }

        @available(macOS, introduced: 11.0, deprecated: 11.0, message: "Use -stopRangingBeaconsSatisfyingConstraint:")
        public static func stopRangingBeacons(in region: Parameter<CLBeaconRegion>) -> Self
        where Signature == (_ region: CLBeaconRegion) -> Void {
            .init(
                method: Methods.stopRangingBeacons_syncin_region_CLBeaconRegion_ret_Void,
                parameters: [region.anyParameter]
            )
        }

        @available(macOS 10.15, *)
        public static func startRangingBeacons(satisfying constraint: Parameter<CLBeaconIdentityConstraint>) -> Self
        where Signature == (_ constraint: CLBeaconIdentityConstraint) -> Void {
            .init(
                method: Methods.startRangingBeacons_syncsatisfying_constraint_CLBeaconIdentityConstraint_ret_Void,
                parameters: [constraint.anyParameter]
            )
        }

        @available(macOS 10.15, *)
        public static func stopRangingBeacons(satisfying constraint: Parameter<CLBeaconIdentityConstraint>) -> Self
        where Signature == (_ constraint: CLBeaconIdentityConstraint) -> Void {
            .init(
                method: Methods.stopRangingBeacons_syncsatisfying_constraint_CLBeaconIdentityConstraint_ret_Void,
                parameters: [constraint.anyParameter]
            )
        }

        @available(macOS, introduced: 10.15, deprecated: 10.15, message: "You can remove calls to this method")
        public static func allowDeferredLocationUpdates(untilTraveled distance: Parameter<CLLocationDistance>, timeout: Parameter<TimeInterval>) -> Self
        where Signature == (_ distance: Double, _ timeout: TimeInterval) -> Void {
            .init(
                method: Methods.allowDeferredLocationUpdates_syncuntilTraveled_distance_CLLocationDistance_timeout_timeout_TimeInterval_ret_Void,
                parameters: [distance.anyParameter, timeout.anyParameter]
            )
        }

        @available(macOS, introduced: 10.15, deprecated: 10.15, message: "You can remove calls to this method")
        public static func disallowDeferredLocationUpdates() -> Self
        where Signature == () -> Void {
            .init(
                method: Methods.disallowDeferredLocationUpdates_sync_ret_Void,
                parameters: []
            )
        }

        @available(*, deprecated, message: "Objective-C garbage collection is no longer supported")
        public static func finalize() -> Self
        where Signature == () -> Void {
            .init(
                method: Methods.finalize_sync_ret_Void,
                parameters: []
            )
        }

        public static func copy() -> Self
        where Signature == () -> Any {
            .init(
                method: Methods.copy_sync_ret_Any,
                parameters: []
            )
        }

        public static func mutableCopy() -> Self
        where Signature == () -> Any {
            .init(
                method: Methods.mutableCopy_sync_ret_Any,
                parameters: []
            )
        }

        public static func method(for aSelector: Parameter<Selector?>) -> Self
        where Signature == (_ aSelector: Selector?) -> IMP? {
            .init(
                method: Methods.method_syncfor_aSelector_Selector_impopt__ret_IMP_impopt_,
                parameters: [aSelector.anyParameter]
            )
        }

        public static func doesNotRecognizeSelector(_ aSelector: Parameter<Selector?>) -> Self
        where Signature == (_ aSelector: Selector?) -> Void {
            .init(
                method: Methods.doesNotRecognizeSelector_sync_aSelector_Selector_impopt__ret_Void,
                parameters: [aSelector.anyParameter]
            )
        }

        @available(macOS 10.5, *)
        public static func forwardingTarget(for aSelector: Parameter<Selector?>) -> Self
        where Signature == (_ aSelector: Selector?) -> Any? {
            .init(
                method: Methods.forwardingTarget_syncfor_aSelector_Selector_impopt__ret_Any_opt_,
                parameters: [aSelector.anyParameter]
            )
        }

        public static func isEqual(_ object: Parameter<Any?>) -> Self
        where Signature == (_ object: Any?) -> Bool {
            .init(
                method: Methods.isEqual_sync_object_Any_opt__ret_Bool,
                parameters: [object.anyParameter]
            )
        }

        public static func `self`() -> Self
        where Signature == () -> CLLocationManagerMock {
            .init(
                method: Methods.self_sync_ret_Self,
                parameters: []
            )
        }

        @available(macOS 10.0, *)
        public static func perform(_ aSelector: Parameter<Selector?>) -> Self
        where Signature == (_ aSelector: Selector?) -> Unmanaged<AnyObject>? {
            .init(
                method: Methods.perform_sync_aSelector_Selector_impopt__ret_Unmanaged_lab_AnyObject_rab__impopt_,
                parameters: [aSelector.anyParameter]
            )
        }

        @available(macOS 10.0, *)
        public static func perform(_ aSelector: Parameter<Selector?>, with object: Parameter<Any?>) -> Self
        where Signature == (_ aSelector: Selector?, _ object: Any?) -> Unmanaged<AnyObject>? {
            .init(
                method: Methods.perform_sync_aSelector_Selector_impopt__with_object_Any_impopt__ret_Unmanaged_lab_AnyObject_rab__impopt_,
                parameters: [aSelector.anyParameter, object.anyParameter]
            )
        }

        @available(macOS 10.0, *)
        public static func perform(_ aSelector: Parameter<Selector?>, with object1: Parameter<Any?>, with object2: Parameter<Any?>) -> Self
        where Signature == (_ aSelector: Selector?, _ object1: Any?, _ object2: Any?) -> Unmanaged<AnyObject>? {
            .init(
                method: Methods.perform_sync_aSelector_Selector_impopt__with_object1_Any_impopt__with_object2_Any_impopt__ret_Unmanaged_lab_AnyObject_rab__impopt_,
                parameters: [aSelector.anyParameter, object1.anyParameter, object2.anyParameter]
            )
        }

        public static func isProxy() -> Self
        where Signature == () -> Bool {
            .init(
                method: Methods.isProxy_sync_ret_Bool,
                parameters: []
            )
        }

        public static func isKind(of aClass: Parameter<AnyClass>) -> Self
        where Signature == (_ aClass: AnyClass) -> Bool {
            .init(
                method: Methods.isKind_syncof_aClass_AnyClass_ret_Bool,
                parameters: [aClass.anyParameter]
            )
        }

        public static func isMember(of aClass: Parameter<AnyClass>) -> Self
        where Signature == (_ aClass: AnyClass) -> Bool {
            .init(
                method: Methods.isMember_syncof_aClass_AnyClass_ret_Bool,
                parameters: [aClass.anyParameter]
            )
        }

        public static func conforms(to aProtocol: Parameter<Protocol>) -> Self
        where Signature == (_ aProtocol: Protocol) -> Bool {
            .init(
                method: Methods.conforms_syncto_aProtocol_Protocol_ret_Bool,
                parameters: [aProtocol.anyParameter]
            )
        }

        @available(macOS 10.0, *)
        public static func responds(to aSelector: Parameter<Selector?>) -> Self
        where Signature == (_ aSelector: Selector?) -> Bool {
            .init(
                method: Methods.responds_syncto_aSelector_Selector_impopt__ret_Bool,
                parameters: [aSelector.anyParameter]
            )
        }
    }

    public struct PropertyExpectation<Signature> {
        private let method: MockMethod

        init(method: MockMethod) {
            self.method = method
        }

        public var getterExpectation: Recorder.Expectation {
            .init(
                method: method,
                parameters: []
            )
        }

        public func setterExpectation(_ newValue: AnyParameter) -> Recorder.Expectation {
            .init(
                method: method,
                parameters: [newValue]
            )
        }
    }

    public let recorder = Recorder()

    private let fileID: String
    private let filePath: StaticString
    private let line: UInt
    private let column: Int

    public init(
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column
    ) {
        self.fileID = fileID
        self.filePath = filePath
        self.line = line
        self.column = column
        self.autoForwardingEnabled = true
        super.init()
        self.autoForwardingEnabled = false
    }

    public var autoForwardingEnabled: Bool

    public var isEnabled: Bool {
        !autoForwardingEnabled
    }

    private func _record(
        _ expectation: Recorder.Expectation,
        _ fileID: String,
        _ filePath: StaticString,
        _ line: UInt,
        _ column: Int,
        _ perform: some Any
    ) {
        guard isEnabled else {
            handleFatalFailure(
                "Setting expectation on disabled mock is not allowed",
                fileID: fileID,
                filePath: filePath,
                line: line,
                column: column
            )
        }
        recorder.record(
            .init(
                expectation,
                perform,
                fileID,
                filePath,
                line,
                column
            )
        )
    }

    private func _perform(_ method: MockMethod, _ parameters: [Any?] = []) -> Any {
        let invocation = Invocation(
            method: method,
            parameters: parameters
        )
        guard let stub = recorder.next() else {
            handleFatalFailure(
                "Expected no calls but received `\(invocation)`",
                fileID: fileID,
                filePath: filePath,
                line: line,
                column: column
            )
        }

        guard stub.matches(invocation) else {
            handleFatalFailure(
                "Unexpected call: expected `\(stub.expectation)`, but received `\(invocation)`",
                fileID: stub.fileID,
                filePath: stub.filePath,
                line: stub.line,
                column: stub.column
            )
        }

        defer { recorder.checkVerification() }
        return stub.perform
    }

    @available(macOS 10.15, *)
    override public func requestWhenInUseAuthorization() {
        guard !autoForwardingEnabled else {
            return super.requestWhenInUseAuthorization()
        }
        let perform = _perform(Methods.requestWhenInUseAuthorization_sync_ret_Void) as! (_ forwardToOriginal: () -> Void) -> Void
        return perform(super.requestWhenInUseAuthorization)
    }

    @available(macOS 10.15, *)
    override public func requestAlwaysAuthorization() {
        guard !autoForwardingEnabled else {
            return super.requestAlwaysAuthorization()
        }
        let perform = _perform(Methods.requestAlwaysAuthorization_sync_ret_Void) as! (_ forwardToOriginal: () -> Void) -> Void
        return perform(super.requestAlwaysAuthorization)
    }

    @available(macOS 11.0, *)
    override public func requestTemporaryFullAccuracyAuthorization(withPurposeKey purposeKey: String, completion: (@Sendable ((any Error)?) -> Void)?) {
        guard !autoForwardingEnabled else {
            return super.requestTemporaryFullAccuracyAuthorization(withPurposeKey: purposeKey, completion: completion)
        }
        let perform = _perform(
            Methods.requestTemporaryFullAccuracyAuthorization_syncwithPurposeKey_purposeKey_String_completion_completion__lp__lp_anyError_opt__rp__ret_Void_rp__opt__ret_Void,
            [purposeKey, completion]
        ) as! (_ forwardToOriginal: (_ purposeKey: String, _ completion: (@Sendable ((any Error)?) -> Void)?) -> Void, _ purposeKey: String, _ completion: (@Sendable ((any Error)?) -> Void)?) -> Void
        return perform(super.requestTemporaryFullAccuracyAuthorization(withPurposeKey:completion:), purposeKey, completion)
    }

    override public func startUpdatingLocation() {
        guard !autoForwardingEnabled else {
            return super.startUpdatingLocation()
        }
        let perform = _perform(Methods.startUpdatingLocation_sync_ret_Void) as! (_ forwardToOriginal: () -> Void) -> Void
        return perform(super.startUpdatingLocation)
    }

    override public func stopUpdatingLocation() {
        guard !autoForwardingEnabled else {
            return super.stopUpdatingLocation()
        }
        let perform = _perform(Methods.stopUpdatingLocation_sync_ret_Void) as! (_ forwardToOriginal: () -> Void) -> Void
        return perform(super.stopUpdatingLocation)
    }

    @available(macOS 10.14, *)
    override public func requestLocation() {
        guard !autoForwardingEnabled else {
            return super.requestLocation()
        }
        let perform = _perform(Methods.requestLocation_sync_ret_Void) as! (_ forwardToOriginal: () -> Void) -> Void
        return perform(super.requestLocation)
    }

    @available(macOS 10.15, *)
    override public func startUpdatingHeading() {
        guard !autoForwardingEnabled else {
            return super.startUpdatingHeading()
        }
        let perform = _perform(Methods.startUpdatingHeading_sync_ret_Void) as! (_ forwardToOriginal: () -> Void) -> Void
        return perform(super.startUpdatingHeading)
    }

    @available(macOS 10.15, *)
    override public func dismissHeadingCalibrationDisplay() {
        guard !autoForwardingEnabled else {
            return super.dismissHeadingCalibrationDisplay()
        }
        let perform = _perform(Methods.dismissHeadingCalibrationDisplay_sync_ret_Void) as! (_ forwardToOriginal: () -> Void) -> Void
        return perform(super.dismissHeadingCalibrationDisplay)
    }

    @available(macOS 10.7, *)
    override public func startMonitoringSignificantLocationChanges() {
        guard !autoForwardingEnabled else {
            return super.startMonitoringSignificantLocationChanges()
        }
        let perform = _perform(Methods.startMonitoringSignificantLocationChanges_sync_ret_Void) as! (_ forwardToOriginal: () -> Void) -> Void
        return perform(super.startMonitoringSignificantLocationChanges)
    }

    @available(macOS 10.7, *)
    override public func stopMonitoringSignificantLocationChanges() {
        guard !autoForwardingEnabled else {
            return super.stopMonitoringSignificantLocationChanges()
        }
        let perform = _perform(Methods.stopMonitoringSignificantLocationChanges_sync_ret_Void) as! (_ forwardToOriginal: () -> Void) -> Void
        return perform(super.stopMonitoringSignificantLocationChanges)
    }

    @available(macOS, introduced: 10.15, deprecated: 10.15)
    override public func startMonitoring(for region: CLRegion, desiredAccuracy accuracy: CLLocationAccuracy) {
        guard !autoForwardingEnabled else {
            return super.startMonitoring(for: region, desiredAccuracy: accuracy)
        }
        let perform = _perform(
            Methods.startMonitoring_syncfor_region_CLRegion_desiredAccuracy_accuracy_CLLocationAccuracy_ret_Void,
            [region, accuracy]
        ) as! (_ forwardToOriginal: (_ region: CLRegion, _ accuracy: Double) -> Void, _ region: CLRegion, _ accuracy: Double) -> Void
        return perform(super.startMonitoring(for:desiredAccuracy:), region, accuracy)
    }

    @available(macOS, introduced: 10.8, deprecated: 100_000)
    override public func stopMonitoring(for region: CLRegion) {
        guard !autoForwardingEnabled else {
            return super.stopMonitoring(for: region)
        }
        let perform = _perform(
            Methods.stopMonitoring_syncfor_region_CLRegion_ret_Void,
            [region]
        ) as! (_ forwardToOriginal: (_ region: CLRegion) -> Void, _ region: CLRegion) -> Void
        return perform(super.stopMonitoring(for:), region)
    }

    @available(macOS, introduced: 10.8, deprecated: 100_000)
    override public func startMonitoring(for region: CLRegion) {
        guard !autoForwardingEnabled else {
            return super.startMonitoring(for: region)
        }
        let perform = _perform(
            Methods.startMonitoring_syncfor_region_CLRegion_ret_Void,
            [region]
        ) as! (_ forwardToOriginal: (_ region: CLRegion) -> Void, _ region: CLRegion) -> Void
        return perform(super.startMonitoring(for:), region)
    }

    @available(macOS, introduced: 10.8, deprecated: 100_000)
    override public func requestState(for region: CLRegion) {
        guard !autoForwardingEnabled else {
            return super.requestState(for: region)
        }
        let perform = _perform(
            Methods.requestState_syncfor_region_CLRegion_ret_Void,
            [region]
        ) as! (_ forwardToOriginal: (_ region: CLRegion) -> Void, _ region: CLRegion) -> Void
        return perform(super.requestState(for:), region)
    }

    @available(macOS, introduced: 11.0, deprecated: 11.0, message: "Use -startRangingBeaconsSatisfyingConstraint:")
    override public func startRangingBeacons(in region: CLBeaconRegion) {
        guard !autoForwardingEnabled else {
            return super.startRangingBeacons(in: region)
        }
        let perform = _perform(
            Methods.startRangingBeacons_syncin_region_CLBeaconRegion_ret_Void,
            [region]
        ) as! (_ forwardToOriginal: (_ region: CLBeaconRegion) -> Void, _ region: CLBeaconRegion) -> Void
        return perform(super.startRangingBeacons(in:), region)
    }

    @available(macOS, introduced: 11.0, deprecated: 11.0, message: "Use -stopRangingBeaconsSatisfyingConstraint:")
    override public func stopRangingBeacons(in region: CLBeaconRegion) {
        guard !autoForwardingEnabled else {
            return super.stopRangingBeacons(in: region)
        }
        let perform = _perform(
            Methods.stopRangingBeacons_syncin_region_CLBeaconRegion_ret_Void,
            [region]
        ) as! (_ forwardToOriginal: (_ region: CLBeaconRegion) -> Void, _ region: CLBeaconRegion) -> Void
        return perform(super.stopRangingBeacons(in:), region)
    }

    @available(macOS 10.15, *)
    override public func startRangingBeacons(satisfying constraint: CLBeaconIdentityConstraint) {
        guard !autoForwardingEnabled else {
            return super.startRangingBeacons(satisfying: constraint)
        }
        let perform = _perform(
            Methods.startRangingBeacons_syncsatisfying_constraint_CLBeaconIdentityConstraint_ret_Void,
            [constraint]
        ) as! (_ forwardToOriginal: (_ constraint: CLBeaconIdentityConstraint) -> Void, _ constraint: CLBeaconIdentityConstraint) -> Void
        return perform(super.startRangingBeacons(satisfying:), constraint)
    }

    @available(macOS 10.15, *)
    override public func stopRangingBeacons(satisfying constraint: CLBeaconIdentityConstraint) {
        guard !autoForwardingEnabled else {
            return super.stopRangingBeacons(satisfying: constraint)
        }
        let perform = _perform(
            Methods.stopRangingBeacons_syncsatisfying_constraint_CLBeaconIdentityConstraint_ret_Void,
            [constraint]
        ) as! (_ forwardToOriginal: (_ constraint: CLBeaconIdentityConstraint) -> Void, _ constraint: CLBeaconIdentityConstraint) -> Void
        return perform(super.stopRangingBeacons(satisfying:), constraint)
    }

    @available(macOS, introduced: 10.15, deprecated: 10.15, message: "You can remove calls to this method")
    override public func allowDeferredLocationUpdates(untilTraveled distance: CLLocationDistance, timeout: TimeInterval) {
        guard !autoForwardingEnabled else {
            return super.allowDeferredLocationUpdates(untilTraveled: distance, timeout: timeout)
        }
        let perform = _perform(
            Methods.allowDeferredLocationUpdates_syncuntilTraveled_distance_CLLocationDistance_timeout_timeout_TimeInterval_ret_Void,
            [distance, timeout]
        ) as! (_ forwardToOriginal: (_ distance: Double, _ timeout: TimeInterval) -> Void, _ distance: Double, _ timeout: TimeInterval) -> Void
        return perform(super.allowDeferredLocationUpdates(untilTraveled:timeout:), distance, timeout)
    }

    @available(macOS, introduced: 10.15, deprecated: 10.15, message: "You can remove calls to this method")
    override public func disallowDeferredLocationUpdates() {
        guard !autoForwardingEnabled else {
            return super.disallowDeferredLocationUpdates()
        }
        let perform = _perform(Methods.disallowDeferredLocationUpdates_sync_ret_Void) as! (_ forwardToOriginal: () -> Void) -> Void
        return perform(super.disallowDeferredLocationUpdates)
    }

    @available(*, deprecated, message: "Objective-C garbage collection is no longer supported")
    override public func finalize() {
        guard !autoForwardingEnabled else {
            return super.finalize()
        }
        let perform = _perform(Methods.finalize_sync_ret_Void) as! (_ forwardToOriginal: () -> Void) -> Void
        return perform(super.finalize)
    }

    override public func copy() -> Any {
        guard !autoForwardingEnabled else {
            return super.copy()
        }
        let perform = _perform(Methods.copy_sync_ret_Any) as! (_ forwardToOriginal: () -> Any) -> Any
        return perform(super.copy)
    }

    override public func mutableCopy() -> Any {
        guard !autoForwardingEnabled else {
            return super.mutableCopy()
        }
        let perform = _perform(Methods.mutableCopy_sync_ret_Any) as! (_ forwardToOriginal: () -> Any) -> Any
        return perform(super.mutableCopy)
    }

    override public func method(for aSelector: Selector!) -> IMP! {
        guard !autoForwardingEnabled else {
            return super.method(for: aSelector)
        }
        let perform = _perform(
            Methods.method_syncfor_aSelector_Selector_impopt__ret_IMP_impopt_,
            [aSelector]
        ) as! (_ forwardToOriginal: (_ aSelector: Selector?) -> IMP?, _ aSelector: Selector?) -> IMP?
        return perform(super.method(for:), aSelector)
    }

    override public func doesNotRecognizeSelector(_ aSelector: Selector!) {
        guard !autoForwardingEnabled else {
            return super.doesNotRecognizeSelector(aSelector)
        }
        let perform = _perform(
            Methods.doesNotRecognizeSelector_sync_aSelector_Selector_impopt__ret_Void,
            [aSelector]
        ) as! (_ forwardToOriginal: (_ aSelector: Selector?) -> Void, _ aSelector: Selector?) -> Void
        return perform(super.doesNotRecognizeSelector(_:), aSelector)
    }

    @available(macOS 10.5, *)
    override public func forwardingTarget(for aSelector: Selector!) -> Any? {
        guard !autoForwardingEnabled else {
            return super.forwardingTarget(for: aSelector)
        }
        let perform = _perform(
            Methods.forwardingTarget_syncfor_aSelector_Selector_impopt__ret_Any_opt_,
            [aSelector]
        ) as! (_ forwardToOriginal: (_ aSelector: Selector?) -> Any?, _ aSelector: Selector?) -> Any?
        return perform(super.forwardingTarget(for:), aSelector)
    }

    override public func isEqual(_ object: Any?) -> Bool {
        guard !autoForwardingEnabled else {
            return super.isEqual(object)
        }
        let perform = _perform(
            Methods.isEqual_sync_object_Any_opt__ret_Bool,
            [object]
        ) as! (_ forwardToOriginal: (_ object: Any?) -> Bool, _ object: Any?) -> Bool
        return perform(super.isEqual(_:), object)
    }

    override public func `self`() -> Self {
        guard !autoForwardingEnabled else {
            return super.`self`()
        }
        let perform = _perform(Methods.self_sync_ret_Self) as! (_ forwardToOriginal: () -> Self) -> Self
        return perform { self }
    }

    @available(macOS 10.0, *)
    override public func perform(_ aSelector: Selector!) -> Unmanaged<AnyObject>! {
        guard !autoForwardingEnabled else {
            return super.perform(aSelector)
        }
        let perform = _perform(
            Methods.perform_sync_aSelector_Selector_impopt__ret_Unmanaged_lab_AnyObject_rab__impopt_,
            [aSelector]
        ) as! (_ forwardToOriginal: (_ aSelector: Selector?) -> Unmanaged<AnyObject>?, _ aSelector: Selector?) -> Unmanaged<AnyObject>?
        return perform(super.perform(_:), aSelector)
    }

    @available(macOS 10.0, *)
    override public func perform(_ aSelector: Selector!, with object: Any!) -> Unmanaged<AnyObject>! {
        guard !autoForwardingEnabled else {
            return super.perform(aSelector, with: object)
        }
        let perform = _perform(
            Methods.perform_sync_aSelector_Selector_impopt__with_object_Any_impopt__ret_Unmanaged_lab_AnyObject_rab__impopt_,
            [aSelector, object]
        ) as! (_ forwardToOriginal: (_ aSelector: Selector?, _ object: Any?) -> Unmanaged<AnyObject>?, _ aSelector: Selector?, _ object: Any?) -> Unmanaged<AnyObject>?
        return perform(super.perform(_:with:), aSelector, object)
    }

    @available(macOS 10.0, *)
    override public func perform(_ aSelector: Selector!, with object1: Any!, with object2: Any!) -> Unmanaged<AnyObject>! {
        guard !autoForwardingEnabled else {
            return super.perform(aSelector, with: object1, with: object2)
        }
        let perform = _perform(
            Methods.perform_sync_aSelector_Selector_impopt__with_object1_Any_impopt__with_object2_Any_impopt__ret_Unmanaged_lab_AnyObject_rab__impopt_,
            [aSelector, object1, object2]
        ) as! (_ forwardToOriginal: (_ aSelector: Selector?, _ object1: Any?, _ object2: Any?) -> Unmanaged<AnyObject>?, _ aSelector: Selector?, _ object1: Any?, _ object2: Any?) -> Unmanaged<AnyObject>?
        return perform(super.perform(_:with:with:), aSelector, object1, object2)
    }

    override public func isProxy() -> Bool {
        guard !autoForwardingEnabled else {
            return super.isProxy()
        }
        let perform = _perform(Methods.isProxy_sync_ret_Bool) as! (_ forwardToOriginal: () -> Bool) -> Bool
        return perform(super.isProxy)
    }

    override public func isKind(of aClass: AnyClass) -> Bool {
        guard !autoForwardingEnabled else {
            return super.isKind(of: aClass)
        }
        let perform = _perform(
            Methods.isKind_syncof_aClass_AnyClass_ret_Bool,
            [aClass]
        ) as! (_ forwardToOriginal: (_ aClass: AnyClass) -> Bool, _ aClass: AnyClass) -> Bool
        return perform(super.isKind(of:), aClass)
    }

    override public func isMember(of aClass: AnyClass) -> Bool {
        guard !autoForwardingEnabled else {
            return super.isMember(of: aClass)
        }
        let perform = _perform(
            Methods.isMember_syncof_aClass_AnyClass_ret_Bool,
            [aClass]
        ) as! (_ forwardToOriginal: (_ aClass: AnyClass) -> Bool, _ aClass: AnyClass) -> Bool
        return perform(super.isMember(of:), aClass)
    }

    override public func conforms(to aProtocol: Protocol) -> Bool {
        guard !autoForwardingEnabled else {
            return super.conforms(to: aProtocol)
        }
        let perform = _perform(
            Methods.conforms_syncto_aProtocol_Protocol_ret_Bool,
            [aProtocol]
        ) as! (_ forwardToOriginal: (_ aProtocol: Protocol) -> Bool, _ aProtocol: Protocol) -> Bool
        return perform(super.conforms(to:), aProtocol)
    }

    @available(macOS 10.0, *)
    override public func responds(to aSelector: Selector!) -> Bool {
        guard !autoForwardingEnabled else {
            return super.responds(to: aSelector)
        }
        let perform = _perform(
            Methods.responds_syncto_aSelector_Selector_impopt__ret_Bool,
            [aSelector]
        ) as! (_ forwardToOriginal: (_ aSelector: Selector?) -> Bool, _ aSelector: Selector?) -> Bool
        return perform(super.responds(to:), aSelector)
    }

    @available(macOS 11.0, *)
    override public var authorizationStatus: CLAuthorizationStatus {
        guard !autoForwardingEnabled else {
            return super.authorizationStatus
        }
        let perform = _perform(Methods.authorizationStatus_sync_ret_CLAuthorizationStatus) as! (_ forwardToOriginal: () -> CLAuthorizationStatus) -> CLAuthorizationStatus
        return perform { super.authorizationStatus }
    }

    @available(macOS 11.0, *)
    override public var accuracyAuthorization: CLAccuracyAuthorization {
        guard !autoForwardingEnabled else {
            return super.accuracyAuthorization
        }
        let perform = _perform(Methods.accuracyAuthorization_sync_ret_CLAccuracyAuthorization) as! (_ forwardToOriginal: () -> CLAccuracyAuthorization) -> CLAccuracyAuthorization
        return perform { super.accuracyAuthorization }
    }

    @available(macOS 11.0, *)
    override public var isAuthorizedForWidgetUpdates: Bool {
        guard !autoForwardingEnabled else {
            return super.isAuthorizedForWidgetUpdates
        }
        let perform = _perform(Methods.isAuthorizedForWidgetUpdates_sync_ret_Bool) as! (_ forwardToOriginal: () -> Bool) -> Bool
        return perform { super.isAuthorizedForWidgetUpdates }
    }

    override public var delegate: (any CLLocationManagerDelegate)? {
        get {
            guard !autoForwardingEnabled else {
                return super.delegate
            }
            let perform = _perform(Methods.delegate_sync_ret_anyCLLocationManagerDelegate_opt_) as! (_ forwardToOriginal: () -> (any CLLocationManagerDelegate)?) -> (any CLLocationManagerDelegate)?
            return perform { super.delegate }
        }
        set {
            guard !autoForwardingEnabled else {
                super.delegate = newValue
                return
            }
            let perform = _perform(
                Methods.set_delegate_sync_ret_anyCLLocationManagerDelegate_opt_,
                [newValue]
            ) as! (_ forwardToOriginal: (_ newValue: (any CLLocationManagerDelegate)?) -> Void, _ newValue: (any CLLocationManagerDelegate)?) -> Void
            return perform({ super.delegate = $0 }, newValue)
        }
    }

    @available(macOS, introduced: 10.15, deprecated: 10.15)
    override public var locationServicesEnabled: Bool {
        guard !autoForwardingEnabled else {
            return super.locationServicesEnabled
        }
        let perform = _perform(Methods.locationServicesEnabled_sync_ret_Bool) as! (_ forwardToOriginal: () -> Bool) -> Bool
        return perform { super.locationServicesEnabled }
    }

    @available(macOS, introduced: 10.7, deprecated: 11.0, message: "Set the purpose string in Info.plist using key NSLocationUsageDescription")
    override public var purpose: String? {
        get {
            guard !autoForwardingEnabled else {
                return super.purpose
            }
            let perform = _perform(Methods.purpose_sync_ret_String_opt_) as! (_ forwardToOriginal: () -> String?) -> String?
            return perform { super.purpose }
        }
        set {
            guard !autoForwardingEnabled else {
                super.purpose = newValue
                return
            }
            let perform = _perform(
                Methods.set_purpose_sync_ret_String_opt_,
                [newValue]
            ) as! (_ forwardToOriginal: (_ newValue: String?) -> Void, _ newValue: String?) -> Void
            return perform({ super.purpose = $0 }, newValue)
        }
    }

    @available(macOS 10.15, *)
    override public var activityType: CLActivityType {
        get {
            guard !autoForwardingEnabled else {
                return super.activityType
            }
            let perform = _perform(Methods.activityType_sync_ret_CLActivityType) as! (_ forwardToOriginal: () -> CLActivityType) -> CLActivityType
            return perform { super.activityType }
        }
        set {
            guard !autoForwardingEnabled else {
                super.activityType = newValue
                return
            }
            let perform = _perform(
                Methods.set_activityType_sync_ret_CLActivityType,
                [newValue]
            ) as! (_ forwardToOriginal: (_ newValue: CLActivityType) -> Void, _ newValue: CLActivityType) -> Void
            return perform({ super.activityType = $0 }, newValue)
        }
    }

    override public var distanceFilter: CLLocationDistance {
        get {
            guard !autoForwardingEnabled else {
                return super.distanceFilter
            }
            let perform = _perform(Methods.distanceFilter_sync_ret_CLLocationDistance) as! (_ forwardToOriginal: () -> Double) -> Double
            return perform { super.distanceFilter }
        }
        set {
            guard !autoForwardingEnabled else {
                super.distanceFilter = newValue
                return
            }
            let perform = _perform(
                Methods.set_distanceFilter_sync_ret_CLLocationDistance,
                [newValue]
            ) as! (_ forwardToOriginal: (_ newValue: Double) -> Void, _ newValue: Double) -> Void
            return perform({ super.distanceFilter = $0 }, newValue)
        }
    }

    override public var desiredAccuracy: CLLocationAccuracy {
        get {
            guard !autoForwardingEnabled else {
                return super.desiredAccuracy
            }
            let perform = _perform(Methods.desiredAccuracy_sync_ret_CLLocationAccuracy) as! (_ forwardToOriginal: () -> Double) -> Double
            return perform { super.desiredAccuracy }
        }
        set {
            guard !autoForwardingEnabled else {
                super.desiredAccuracy = newValue
                return
            }
            let perform = _perform(
                Methods.set_desiredAccuracy_sync_ret_CLLocationAccuracy,
                [newValue]
            ) as! (_ forwardToOriginal: (_ newValue: Double) -> Void, _ newValue: Double) -> Void
            return perform({ super.desiredAccuracy = $0 }, newValue)
        }
    }

    @available(macOS 10.15, *)
    override public var pausesLocationUpdatesAutomatically: Bool {
        get {
            guard !autoForwardingEnabled else {
                return super.pausesLocationUpdatesAutomatically
            }
            let perform = _perform(Methods.pausesLocationUpdatesAutomatically_sync_ret_Bool) as! (_ forwardToOriginal: () -> Bool) -> Bool
            return perform { super.pausesLocationUpdatesAutomatically }
        }
        set {
            guard !autoForwardingEnabled else {
                super.pausesLocationUpdatesAutomatically = newValue
                return
            }
            let perform = _perform(
                Methods.set_pausesLocationUpdatesAutomatically_sync_ret_Bool,
                [newValue]
            ) as! (_ forwardToOriginal: (_ newValue: Bool) -> Void, _ newValue: Bool) -> Void
            return perform({ super.pausesLocationUpdatesAutomatically = $0 }, newValue)
        }
    }

    @available(macOS 10.15, *)
    override public var allowsBackgroundLocationUpdates: Bool {
        get {
            guard !autoForwardingEnabled else {
                return super.allowsBackgroundLocationUpdates
            }
            let perform = _perform(Methods.allowsBackgroundLocationUpdates_sync_ret_Bool) as! (_ forwardToOriginal: () -> Bool) -> Bool
            return perform { super.allowsBackgroundLocationUpdates }
        }
        set {
            guard !autoForwardingEnabled else {
                super.allowsBackgroundLocationUpdates = newValue
                return
            }
            let perform = _perform(
                Methods.set_allowsBackgroundLocationUpdates_sync_ret_Bool,
                [newValue]
            ) as! (_ forwardToOriginal: (_ newValue: Bool) -> Void, _ newValue: Bool) -> Void
            return perform({ super.allowsBackgroundLocationUpdates = $0 }, newValue)
        }
    }

    override public var location: CLLocation? {
        guard !autoForwardingEnabled else {
            return super.location
        }
        let perform = _perform(Methods.location_sync_ret_CLLocation_opt_) as! (_ forwardToOriginal: () -> CLLocation?) -> CLLocation?
        return perform { super.location }
    }

    @available(macOS, introduced: 10.15, deprecated: 10.15)
    override public var headingAvailable: Bool {
        guard !autoForwardingEnabled else {
            return super.headingAvailable
        }
        let perform = _perform(Methods.headingAvailable_sync_ret_Bool) as! (_ forwardToOriginal: () -> Bool) -> Bool
        return perform { super.headingAvailable }
    }

    @available(macOS 10.15, *)
    override public var headingFilter: CLLocationDegrees {
        get {
            guard !autoForwardingEnabled else {
                return super.headingFilter
            }
            let perform = _perform(Methods.headingFilter_sync_ret_CLLocationDegrees) as! (_ forwardToOriginal: () -> Double) -> Double
            return perform { super.headingFilter }
        }
        set {
            guard !autoForwardingEnabled else {
                super.headingFilter = newValue
                return
            }
            let perform = _perform(
                Methods.set_headingFilter_sync_ret_CLLocationDegrees,
                [newValue]
            ) as! (_ forwardToOriginal: (_ newValue: Double) -> Void, _ newValue: Double) -> Void
            return perform({ super.headingFilter = $0 }, newValue)
        }
    }

    @available(macOS 10.15, *)
    override public var headingOrientation: CLDeviceOrientation {
        get {
            guard !autoForwardingEnabled else {
                return super.headingOrientation
            }
            let perform = _perform(Methods.headingOrientation_sync_ret_CLDeviceOrientation) as! (_ forwardToOriginal: () -> CLDeviceOrientation) -> CLDeviceOrientation
            return perform { super.headingOrientation }
        }
        set {
            guard !autoForwardingEnabled else {
                super.headingOrientation = newValue
                return
            }
            let perform = _perform(
                Methods.set_headingOrientation_sync_ret_CLDeviceOrientation,
                [newValue]
            ) as! (_ forwardToOriginal: (_ newValue: CLDeviceOrientation) -> Void, _ newValue: CLDeviceOrientation) -> Void
            return perform({ super.headingOrientation = $0 }, newValue)
        }
    }

    @available(macOS 10.15, *)
    override public var heading: CLHeading? {
        guard !autoForwardingEnabled else {
            return super.heading
        }
        let perform = _perform(Methods.heading_sync_ret_CLHeading_opt_) as! (_ forwardToOriginal: () -> CLHeading?) -> CLHeading?
        return perform { super.heading }
    }

    @available(macOS 10.8, *)
    override public var maximumRegionMonitoringDistance: CLLocationDistance {
        guard !autoForwardingEnabled else {
            return super.maximumRegionMonitoringDistance
        }
        let perform = _perform(Methods.maximumRegionMonitoringDistance_sync_ret_CLLocationDistance) as! (_ forwardToOriginal: () -> Double) -> Double
        return perform { super.maximumRegionMonitoringDistance }
    }

    @available(macOS 10.8, *)
    override public var monitoredRegions: Set<CLRegion> {
        guard !autoForwardingEnabled else {
            return super.monitoredRegions
        }
        let perform = _perform(Methods.monitoredRegions_sync_ret_Set_lab_CLRegion_rab_) as! (_ forwardToOriginal: () -> Set<CLRegion>) -> Set<CLRegion>
        return perform { super.monitoredRegions }
    }

    @available(macOS, introduced: 10.15, deprecated: 10.15, message: "Use -rangedBeaconConstraints")
    override public var rangedRegions: Set<CLRegion> {
        guard !autoForwardingEnabled else {
            return super.rangedRegions
        }
        let perform = _perform(Methods.rangedRegions_sync_ret_Set_lab_CLRegion_rab_) as! (_ forwardToOriginal: () -> Set<CLRegion>) -> Set<CLRegion>
        return perform { super.rangedRegions }
    }

    @available(macOS 10.15, *)
    override public var rangedBeaconConstraints: Set<CLBeaconIdentityConstraint> {
        guard !autoForwardingEnabled else {
            return super.rangedBeaconConstraints
        }
        let perform = _perform(Methods.rangedBeaconConstraints_sync_ret_Set_lab_CLBeaconIdentityConstraint_rab_) as! (_ forwardToOriginal: () -> Set<CLBeaconIdentityConstraint>) -> Set<CLBeaconIdentityConstraint>
        return perform { super.rangedBeaconConstraints }
    }

    override public var hash: Int {
        guard !autoForwardingEnabled else {
            return super.hash
        }
        let perform = _perform(Methods.hash_sync_ret_Int) as! (_ forwardToOriginal: () -> Int) -> Int
        return perform { super.hash }
    }

    override public var superclass: AnyClass? {
        guard !autoForwardingEnabled else {
            return super.superclass
        }
        let perform = _perform(Methods.superclass_sync_ret_AnyClass_opt_) as! (_ forwardToOriginal: () -> AnyClass?) -> AnyClass?
        return perform { super.superclass }
    }

    override public var description: String {
        guard !autoForwardingEnabled else {
            return super.description
        }
        let perform = _perform(Methods.description_sync_ret_String) as! (_ forwardToOriginal: () -> String) -> String
        return perform { super.description }
    }

    override public var debugDescription: String {
        guard !autoForwardingEnabled else {
            return super.debugDescription
        }
        let perform = _perform(Methods.debugDescription_sync_ret_String) as! (_ forwardToOriginal: () -> String) -> String
        return perform { super.debugDescription }
    }

    @available(macOS 10.15, *)
    public func expect(
        _ expectation: MethodExpectation<() -> Void>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ forwardToOriginal: () -> Void) -> Void = { _forwardToSuper in
            _forwardToSuper()
        }
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    @available(macOS 11.0, *)
    public func expect(
        _ expectation: MethodExpectation<(_ purposeKey: String, _ completion: (@Sendable ((any Error)?) -> Void)?) -> Void>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ forwardToOriginal: (_ purposeKey: String, _ completion: (@Sendable ((any Error)?) -> Void)?) -> Void, _ purposeKey: String, _ completion: (@Sendable ((any Error)?) -> Void)?) -> Void = { _forwardToSuper, purposeKey, completion in
            _forwardToSuper(purposeKey, completion)
        }
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    @available(macOS 11.0, *)
    public func expect(
        _ expectation: MethodExpectation<(_ purposeKey: String) async throws -> Void>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ forwardToOriginal: (_ purposeKey: String) async throws -> Void, _ purposeKey: String) async throws -> Void = { _forwardToSuper, purposeKey in
            try await _forwardToSuper(purposeKey)
        }
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    @available(macOS, introduced: 10.15, deprecated: 10.15)
    public func expect(
        _ expectation: MethodExpectation<(_ region: CLRegion, _ accuracy: Double) -> Void>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ forwardToOriginal: (_ region: CLRegion, _ accuracy: Double) -> Void, _ region: CLRegion, _ accuracy: Double) -> Void = { _forwardToSuper, region, accuracy in
            _forwardToSuper(region, accuracy)
        }
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    @available(macOS, introduced: 10.8, deprecated: 100_000)
    public func expect(
        _ expectation: MethodExpectation<(_ region: CLRegion) -> Void>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ forwardToOriginal: (_ region: CLRegion) -> Void, _ region: CLRegion) -> Void = { _forwardToSuper, region in
            _forwardToSuper(region)
        }
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    @available(macOS, introduced: 11.0, deprecated: 11.0, message: "Use -startRangingBeaconsSatisfyingConstraint:")
    public func expect(
        _ expectation: MethodExpectation<(_ region: CLBeaconRegion) -> Void>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ forwardToOriginal: (_ region: CLBeaconRegion) -> Void, _ region: CLBeaconRegion) -> Void = { _forwardToSuper, region in
            _forwardToSuper(region)
        }
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    @available(macOS 10.15, *)
    public func expect(
        _ expectation: MethodExpectation<(_ constraint: CLBeaconIdentityConstraint) -> Void>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ forwardToOriginal: (_ constraint: CLBeaconIdentityConstraint) -> Void, _ constraint: CLBeaconIdentityConstraint) -> Void = { _forwardToSuper, constraint in
            _forwardToSuper(constraint)
        }
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    @available(macOS, introduced: 10.15, deprecated: 10.15, message: "You can remove calls to this method")
    public func expect(
        _ expectation: MethodExpectation<(_ distance: Double, _ timeout: TimeInterval) -> Void>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ forwardToOriginal: (_ distance: Double, _ timeout: TimeInterval) -> Void, _ distance: Double, _ timeout: TimeInterval) -> Void = { _forwardToSuper, distance, timeout in
            _forwardToSuper(distance, timeout)
        }
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    public func expect(
        _ expectation: MethodExpectation<() -> Any>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ forwardToOriginal: () -> Any) -> Any = { _forwardToSuper in
            _forwardToSuper()
        }
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    public func expect(
        _ expectation: MethodExpectation<(_ aSelector: Selector?) -> IMP?>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ forwardToOriginal: (_ aSelector: Selector?) -> IMP?, _ aSelector: Selector?) -> IMP? = { _forwardToSuper, aSelector in
            _forwardToSuper(aSelector)
        }
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    public func expect(
        _ expectation: MethodExpectation<(_ aSelector: Selector?) -> Void>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ forwardToOriginal: (_ aSelector: Selector?) -> Void, _ aSelector: Selector?) -> Void = { _forwardToSuper, aSelector in
            _forwardToSuper(aSelector)
        }
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    @available(macOS 10.5, *)
    public func expect(
        _ expectation: MethodExpectation<(_ aSelector: Selector?) -> Any?>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ forwardToOriginal: (_ aSelector: Selector?) -> Any?, _ aSelector: Selector?) -> Any? = { _forwardToSuper, aSelector in
            _forwardToSuper(aSelector)
        }
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    public func expect(
        _ expectation: MethodExpectation<(_ object: Any?) -> Bool>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ forwardToOriginal: (_ object: Any?) -> Bool, _ object: Any?) -> Bool = { _forwardToSuper, object in
            _forwardToSuper(object)
        }
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    public func expect(
        _ expectation: MethodExpectation<() -> CLLocationManagerMock>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ forwardToOriginal: () -> CLLocationManagerMock) -> CLLocationManagerMock = { _forwardToSuper in
            _forwardToSuper()
        }
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    @available(macOS 10.0, *)
    public func expect(
        _ expectation: MethodExpectation<(_ aSelector: Selector?) -> Unmanaged<AnyObject>?>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ forwardToOriginal: (_ aSelector: Selector?) -> Unmanaged<AnyObject>?, _ aSelector: Selector?) -> Unmanaged<AnyObject>? = { _forwardToSuper, aSelector in
            _forwardToSuper(aSelector)
        }
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    @available(macOS 10.0, *)
    public func expect(
        _ expectation: MethodExpectation<(_ aSelector: Selector?, _ object: Any?) -> Unmanaged<AnyObject>?>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ forwardToOriginal: (_ aSelector: Selector?, _ object: Any?) -> Unmanaged<AnyObject>?, _ aSelector: Selector?, _ object: Any?) -> Unmanaged<AnyObject>? = { _forwardToSuper, aSelector, object in
            _forwardToSuper(aSelector, object)
        }
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    @available(macOS 10.0, *)
    public func expect(
        _ expectation: MethodExpectation<(_ aSelector: Selector?, _ object1: Any?, _ object2: Any?) -> Unmanaged<AnyObject>?>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ forwardToOriginal: (_ aSelector: Selector?, _ object1: Any?, _ object2: Any?) -> Unmanaged<AnyObject>?, _ aSelector: Selector?, _ object1: Any?, _ object2: Any?) -> Unmanaged<AnyObject>? = { _forwardToSuper, aSelector, object1, object2 in
            _forwardToSuper(aSelector, object1, object2)
        }
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    public func expect(
        _ expectation: MethodExpectation<() -> Bool>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ forwardToOriginal: () -> Bool) -> Bool = { _forwardToSuper in
            _forwardToSuper()
        }
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    public func expect(
        _ expectation: MethodExpectation<(_ aClass: AnyClass) -> Bool>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ forwardToOriginal: (_ aClass: AnyClass) -> Bool, _ aClass: AnyClass) -> Bool = { _forwardToSuper, aClass in
            _forwardToSuper(aClass)
        }
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    public func expect(
        _ expectation: MethodExpectation<(_ aProtocol: Protocol) -> Bool>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ forwardToOriginal: (_ aProtocol: Protocol) -> Bool, _ aProtocol: Protocol) -> Bool = { _forwardToSuper, aProtocol in
            _forwardToSuper(aProtocol)
        }
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    @available(macOS 10.0, *)
    public func expect(
        _ expectation: MethodExpectation<(_ aSelector: Selector?) -> Bool>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ forwardToOriginal: (_ aSelector: Selector?) -> Bool, _ aSelector: Selector?) -> Bool = { _forwardToSuper, aSelector in
            _forwardToSuper(aSelector)
        }
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    public func expect(
        _ expectation: PropertyExpectation<() -> CLAuthorizationStatus>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ forwardToOriginal: () -> CLAuthorizationStatus) -> CLAuthorizationStatus = { $0() }
    ) {
        _record(
            expectation.getterExpectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    public func expect(
        _ expectation: PropertyExpectation<() -> CLAccuracyAuthorization>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ forwardToOriginal: () -> CLAccuracyAuthorization) -> CLAccuracyAuthorization = { $0() }
    ) {
        _record(
            expectation.getterExpectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    public func expect(
        _ expectation: PropertyExpectation<() -> Bool>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ forwardToOriginal: () -> Bool) -> Bool = { $0() }
    ) {
        _record(
            expectation.getterExpectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    public func expect(
        _ expectation: PropertyExpectation<() -> (any CLLocationManagerDelegate)?>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ forwardToOriginal: () -> (any CLLocationManagerDelegate)?) -> (any CLLocationManagerDelegate)? = { $0() }
    ) {
        _record(
            expectation.getterExpectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    public func expect(
        _ expectation: PropertyExpectation<() -> String?>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ forwardToOriginal: () -> String?) -> String? = { $0() }
    ) {
        _record(
            expectation.getterExpectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    public func expect(
        _ expectation: PropertyExpectation<() -> CLActivityType>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ forwardToOriginal: () -> CLActivityType) -> CLActivityType = { $0() }
    ) {
        _record(
            expectation.getterExpectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    public func expect(
        _ expectation: PropertyExpectation<() -> Double>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ forwardToOriginal: () -> Double) -> Double = { $0() }
    ) {
        _record(
            expectation.getterExpectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    public func expect(
        _ expectation: PropertyExpectation<() -> CLLocation?>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ forwardToOriginal: () -> CLLocation?) -> CLLocation? = { $0() }
    ) {
        _record(
            expectation.getterExpectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    public func expect(
        _ expectation: PropertyExpectation<() -> CLDeviceOrientation>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ forwardToOriginal: () -> CLDeviceOrientation) -> CLDeviceOrientation = { $0() }
    ) {
        _record(
            expectation.getterExpectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    public func expect(
        _ expectation: PropertyExpectation<() -> CLHeading?>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ forwardToOriginal: () -> CLHeading?) -> CLHeading? = { $0() }
    ) {
        _record(
            expectation.getterExpectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    public func expect(
        _ expectation: PropertyExpectation<() -> Set<CLRegion>>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ forwardToOriginal: () -> Set<CLRegion>) -> Set<CLRegion> = { $0() }
    ) {
        _record(
            expectation.getterExpectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    public func expect(
        _ expectation: PropertyExpectation<() -> Set<CLBeaconIdentityConstraint>>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ forwardToOriginal: () -> Set<CLBeaconIdentityConstraint>) -> Set<CLBeaconIdentityConstraint> = { $0() }
    ) {
        _record(
            expectation.getterExpectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    public func expect(
        _ expectation: PropertyExpectation<() -> Int>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ forwardToOriginal: () -> Int) -> Int = { $0() }
    ) {
        _record(
            expectation.getterExpectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    public func expect(
        _ expectation: PropertyExpectation<() -> AnyClass?>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ forwardToOriginal: () -> AnyClass?) -> AnyClass? = { $0() }
    ) {
        _record(
            expectation.getterExpectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    public func expect(
        _ expectation: PropertyExpectation<() -> String>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ forwardToOriginal: () -> String) -> String = { $0() }
    ) {
        _record(
            expectation.getterExpectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    public func expect(
        set expectation: PropertyExpectation<(_ newValue: CLAuthorizationStatus) -> Void>,
        to newValue: Parameter<CLAuthorizationStatus>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ forwardToOriginal: (_ newValue: CLAuthorizationStatus) -> Void, _ newValue: CLAuthorizationStatus) -> Void = { $0($1) }
    ) {
        _record(
            expectation.setterExpectation(newValue.anyParameter),
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    public func expect(
        set expectation: PropertyExpectation<(_ newValue: CLAccuracyAuthorization) -> Void>,
        to newValue: Parameter<CLAccuracyAuthorization>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ forwardToOriginal: (_ newValue: CLAccuracyAuthorization) -> Void, _ newValue: CLAccuracyAuthorization) -> Void = { $0($1) }
    ) {
        _record(
            expectation.setterExpectation(newValue.anyParameter),
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    public func expect(
        set expectation: PropertyExpectation<(_ newValue: Bool) -> Void>,
        to newValue: Parameter<Bool>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ forwardToOriginal: (_ newValue: Bool) -> Void, _ newValue: Bool) -> Void = { $0($1) }
    ) {
        _record(
            expectation.setterExpectation(newValue.anyParameter),
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    public func expect(
        set expectation: PropertyExpectation<(_ newValue: (any CLLocationManagerDelegate)?) -> Void>,
        to newValue: Parameter<(any CLLocationManagerDelegate)?>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ forwardToOriginal: (_ newValue: (any CLLocationManagerDelegate)?) -> Void, _ newValue: (any CLLocationManagerDelegate)?) -> Void = { $0($1) }
    ) {
        _record(
            expectation.setterExpectation(newValue.anyParameter),
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    public func expect(
        set expectation: PropertyExpectation<(_ newValue: String?) -> Void>,
        to newValue: Parameter<String?>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ forwardToOriginal: (_ newValue: String?) -> Void, _ newValue: String?) -> Void = { $0($1) }
    ) {
        _record(
            expectation.setterExpectation(newValue.anyParameter),
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    public func expect(
        set expectation: PropertyExpectation<(_ newValue: CLActivityType) -> Void>,
        to newValue: Parameter<CLActivityType>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ forwardToOriginal: (_ newValue: CLActivityType) -> Void, _ newValue: CLActivityType) -> Void = { $0($1) }
    ) {
        _record(
            expectation.setterExpectation(newValue.anyParameter),
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    public func expect(
        set expectation: PropertyExpectation<(_ newValue: Double) -> Void>,
        to newValue: Parameter<CLLocationDistance>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ forwardToOriginal: (_ newValue: Double) -> Void, _ newValue: Double) -> Void = { $0($1) }
    ) {
        _record(
            expectation.setterExpectation(newValue.anyParameter),
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    public func expect(
        set expectation: PropertyExpectation<(_ newValue: CLLocation?) -> Void>,
        to newValue: Parameter<CLLocation?>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ forwardToOriginal: (_ newValue: CLLocation?) -> Void, _ newValue: CLLocation?) -> Void = { $0($1) }
    ) {
        _record(
            expectation.setterExpectation(newValue.anyParameter),
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    public func expect(
        set expectation: PropertyExpectation<(_ newValue: CLDeviceOrientation) -> Void>,
        to newValue: Parameter<CLDeviceOrientation>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ forwardToOriginal: (_ newValue: CLDeviceOrientation) -> Void, _ newValue: CLDeviceOrientation) -> Void = { $0($1) }
    ) {
        _record(
            expectation.setterExpectation(newValue.anyParameter),
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    public func expect(
        set expectation: PropertyExpectation<(_ newValue: CLHeading?) -> Void>,
        to newValue: Parameter<CLHeading?>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ forwardToOriginal: (_ newValue: CLHeading?) -> Void, _ newValue: CLHeading?) -> Void = { $0($1) }
    ) {
        _record(
            expectation.setterExpectation(newValue.anyParameter),
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    public func expect(
        set expectation: PropertyExpectation<(_ newValue: Set<CLRegion>) -> Void>,
        to newValue: Parameter<Set<CLRegion>>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ forwardToOriginal: (_ newValue: Set<CLRegion>) -> Void, _ newValue: Set<CLRegion>) -> Void = { $0($1) }
    ) {
        _record(
            expectation.setterExpectation(newValue.anyParameter),
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    public func expect(
        set expectation: PropertyExpectation<(_ newValue: Set<CLBeaconIdentityConstraint>) -> Void>,
        to newValue: Parameter<Set<CLBeaconIdentityConstraint>>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ forwardToOriginal: (_ newValue: Set<CLBeaconIdentityConstraint>) -> Void, _ newValue: Set<CLBeaconIdentityConstraint>) -> Void = { $0($1) }
    ) {
        _record(
            expectation.setterExpectation(newValue.anyParameter),
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    public func expect(
        set expectation: PropertyExpectation<(_ newValue: Int) -> Void>,
        to newValue: Parameter<Int>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ forwardToOriginal: (_ newValue: Int) -> Void, _ newValue: Int) -> Void = { $0($1) }
    ) {
        _record(
            expectation.setterExpectation(newValue.anyParameter),
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    public func expect(
        set expectation: PropertyExpectation<(_ newValue: AnyClass?) -> Void>,
        to newValue: Parameter<AnyClass?>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ forwardToOriginal: (_ newValue: AnyClass?) -> Void, _ newValue: AnyClass?) -> Void = { $0($1) }
    ) {
        _record(
            expectation.setterExpectation(newValue.anyParameter),
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    public func expect(
        set expectation: PropertyExpectation<(_ newValue: String) -> Void>,
        to newValue: Parameter<String>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ forwardToOriginal: (_ newValue: String) -> Void, _ newValue: String) -> Void = { $0($1) }
    ) {
        _record(
            expectation.setterExpectation(newValue.anyParameter),
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }
}

public extension CLLocationManagerMock.PropertyExpectation where Signature == () -> CLAuthorizationStatus {
    static var authorizationStatus: Self {
        .init(method: CLLocationManagerMock.Methods.authorizationStatus_sync_ret_CLAuthorizationStatus)
    }
}

public extension CLLocationManagerMock.PropertyExpectation where Signature == () -> CLAccuracyAuthorization {
    static var accuracyAuthorization: Self {
        .init(method: CLLocationManagerMock.Methods.accuracyAuthorization_sync_ret_CLAccuracyAuthorization)
    }
}

public extension CLLocationManagerMock.PropertyExpectation where Signature == () -> Bool {
    static var isAuthorizedForWidgetUpdates: Self {
        .init(method: CLLocationManagerMock.Methods.isAuthorizedForWidgetUpdates_sync_ret_Bool)
    }
}

public extension CLLocationManagerMock.PropertyExpectation where Signature == () -> (any CLLocationManagerDelegate)? {
    static var delegate: Self {
        .init(method: CLLocationManagerMock.Methods.delegate_sync_ret_anyCLLocationManagerDelegate_opt_)
    }
}

public extension CLLocationManagerMock.PropertyExpectation where Signature == (_ newValue: (any CLLocationManagerDelegate)?) -> Void {
    static var delegate: Self {
        .init(method: CLLocationManagerMock.Methods.set_delegate_sync_ret_anyCLLocationManagerDelegate_opt_)
    }
}

public extension CLLocationManagerMock.PropertyExpectation where Signature == () -> Bool {
    static var locationServicesEnabled: Self {
        .init(method: CLLocationManagerMock.Methods.locationServicesEnabled_sync_ret_Bool)
    }
}

public extension CLLocationManagerMock.PropertyExpectation where Signature == () -> String? {
    static var purpose: Self {
        .init(method: CLLocationManagerMock.Methods.purpose_sync_ret_String_opt_)
    }
}

public extension CLLocationManagerMock.PropertyExpectation where Signature == (_ newValue: String?) -> Void {
    static var purpose: Self {
        .init(method: CLLocationManagerMock.Methods.set_purpose_sync_ret_String_opt_)
    }
}

public extension CLLocationManagerMock.PropertyExpectation where Signature == () -> CLActivityType {
    static var activityType: Self {
        .init(method: CLLocationManagerMock.Methods.activityType_sync_ret_CLActivityType)
    }
}

public extension CLLocationManagerMock.PropertyExpectation where Signature == (_ newValue: CLActivityType) -> Void {
    static var activityType: Self {
        .init(method: CLLocationManagerMock.Methods.set_activityType_sync_ret_CLActivityType)
    }
}

public extension CLLocationManagerMock.PropertyExpectation where Signature == () -> Double {
    static var distanceFilter: Self {
        .init(method: CLLocationManagerMock.Methods.distanceFilter_sync_ret_CLLocationDistance)
    }
}

public extension CLLocationManagerMock.PropertyExpectation where Signature == (_ newValue: Double) -> Void {
    static var distanceFilter: Self {
        .init(method: CLLocationManagerMock.Methods.set_distanceFilter_sync_ret_CLLocationDistance)
    }
}

public extension CLLocationManagerMock.PropertyExpectation where Signature == () -> Double {
    static var desiredAccuracy: Self {
        .init(method: CLLocationManagerMock.Methods.desiredAccuracy_sync_ret_CLLocationAccuracy)
    }
}

public extension CLLocationManagerMock.PropertyExpectation where Signature == (_ newValue: Double) -> Void {
    static var desiredAccuracy: Self {
        .init(method: CLLocationManagerMock.Methods.set_desiredAccuracy_sync_ret_CLLocationAccuracy)
    }
}

public extension CLLocationManagerMock.PropertyExpectation where Signature == () -> Bool {
    static var pausesLocationUpdatesAutomatically: Self {
        .init(method: CLLocationManagerMock.Methods.pausesLocationUpdatesAutomatically_sync_ret_Bool)
    }
}

public extension CLLocationManagerMock.PropertyExpectation where Signature == (_ newValue: Bool) -> Void {
    static var pausesLocationUpdatesAutomatically: Self {
        .init(method: CLLocationManagerMock.Methods.set_pausesLocationUpdatesAutomatically_sync_ret_Bool)
    }
}

public extension CLLocationManagerMock.PropertyExpectation where Signature == () -> Bool {
    static var allowsBackgroundLocationUpdates: Self {
        .init(method: CLLocationManagerMock.Methods.allowsBackgroundLocationUpdates_sync_ret_Bool)
    }
}

public extension CLLocationManagerMock.PropertyExpectation where Signature == (_ newValue: Bool) -> Void {
    static var allowsBackgroundLocationUpdates: Self {
        .init(method: CLLocationManagerMock.Methods.set_allowsBackgroundLocationUpdates_sync_ret_Bool)
    }
}

public extension CLLocationManagerMock.PropertyExpectation where Signature == () -> CLLocation? {
    static var location: Self {
        .init(method: CLLocationManagerMock.Methods.location_sync_ret_CLLocation_opt_)
    }
}

public extension CLLocationManagerMock.PropertyExpectation where Signature == () -> Bool {
    static var headingAvailable: Self {
        .init(method: CLLocationManagerMock.Methods.headingAvailable_sync_ret_Bool)
    }
}

public extension CLLocationManagerMock.PropertyExpectation where Signature == () -> Double {
    static var headingFilter: Self {
        .init(method: CLLocationManagerMock.Methods.headingFilter_sync_ret_CLLocationDegrees)
    }
}

public extension CLLocationManagerMock.PropertyExpectation where Signature == (_ newValue: Double) -> Void {
    static var headingFilter: Self {
        .init(method: CLLocationManagerMock.Methods.set_headingFilter_sync_ret_CLLocationDegrees)
    }
}

public extension CLLocationManagerMock.PropertyExpectation where Signature == () -> CLDeviceOrientation {
    static var headingOrientation: Self {
        .init(method: CLLocationManagerMock.Methods.headingOrientation_sync_ret_CLDeviceOrientation)
    }
}

public extension CLLocationManagerMock.PropertyExpectation where Signature == (_ newValue: CLDeviceOrientation) -> Void {
    static var headingOrientation: Self {
        .init(method: CLLocationManagerMock.Methods.set_headingOrientation_sync_ret_CLDeviceOrientation)
    }
}

public extension CLLocationManagerMock.PropertyExpectation where Signature == () -> CLHeading? {
    static var heading: Self {
        .init(method: CLLocationManagerMock.Methods.heading_sync_ret_CLHeading_opt_)
    }
}

public extension CLLocationManagerMock.PropertyExpectation where Signature == () -> Double {
    static var maximumRegionMonitoringDistance: Self {
        .init(method: CLLocationManagerMock.Methods.maximumRegionMonitoringDistance_sync_ret_CLLocationDistance)
    }
}

public extension CLLocationManagerMock.PropertyExpectation where Signature == () -> Set<CLRegion> {
    static var monitoredRegions: Self {
        .init(method: CLLocationManagerMock.Methods.monitoredRegions_sync_ret_Set_lab_CLRegion_rab_)
    }
}

public extension CLLocationManagerMock.PropertyExpectation where Signature == () -> Set<CLRegion> {
    static var rangedRegions: Self {
        .init(method: CLLocationManagerMock.Methods.rangedRegions_sync_ret_Set_lab_CLRegion_rab_)
    }
}

public extension CLLocationManagerMock.PropertyExpectation where Signature == () -> Set<CLBeaconIdentityConstraint> {
    static var rangedBeaconConstraints: Self {
        .init(method: CLLocationManagerMock.Methods.rangedBeaconConstraints_sync_ret_Set_lab_CLBeaconIdentityConstraint_rab_)
    }
}

public extension CLLocationManagerMock.PropertyExpectation where Signature == () -> Int {
    static var hash: Self {
        .init(method: CLLocationManagerMock.Methods.hash_sync_ret_Int)
    }
}

public extension CLLocationManagerMock.PropertyExpectation where Signature == () -> AnyClass? {
    static var superclass: Self {
        .init(method: CLLocationManagerMock.Methods.superclass_sync_ret_AnyClass_opt_)
    }
}

public extension CLLocationManagerMock.PropertyExpectation where Signature == () -> String {
    static var description: Self {
        .init(method: CLLocationManagerMock.Methods.description_sync_ret_String)
    }
}

public extension CLLocationManagerMock.PropertyExpectation where Signature == () -> String {
    static var debugDescription: Self {
        .init(method: CLLocationManagerMock.Methods.debugDescription_sync_ret_String)
    }
}

open class GenericTestMockableMock<ConstrainedValue: Equatable, Value>: GenericTestMockable, Mock {
    public typealias ConstrainedValue = ConstrainedValue
    public typealias Value = Value

    enum Methods {
        static var doSomething_syncwith_value_Value_ret_Void: MockMethod {
            .init {
                "doSomething(with: \($0[0] ?? "nil"))"
            }
        }

        static var doSomething_syncwith_value_ConstrainedValue_ret_Void: MockMethod {
            .init {
                "doSomething(with: \($0[0] ?? "nil"))"
            }
        }

        static var doSomethingWithInput_sync_input_I_ret_OwhereValue_eq__lp_I_rp__ret_O: MockMethod {
            .init {
                "doSomethingWithInput<I, O>(\($0[0] ?? "nil"))"
            }
        }
    }

    public struct MethodExpectation<Signature> {
        public let expectation: Recorder.Expectation

        init(method: MockMethod, parameters: [AnyParameter]) {
            self.expectation = .init(
                method: method,
                parameters: parameters
            )
        }

        public static func doSomething(with value: Parameter<Value>) -> Self
        where Signature == (_ value: Value) -> Void {
            .init(
                method: Methods.doSomething_syncwith_value_Value_ret_Void,
                parameters: [value.anyParameter]
            )
        }

        public static func doSomething(with value: Parameter<ConstrainedValue>) -> Self
        where Signature == (_ value: ConstrainedValue) -> Void {
            .init(
                method: Methods.doSomething_syncwith_value_ConstrainedValue_ret_Void,
                parameters: [value.anyParameter]
            )
        }

        public static func doSomethingWithInput<I, O>(_ input: Parameter<I>) -> Self
        where Signature == (_ input: I) -> O, Value == (I) -> O {
            .init(
                method: Methods.doSomethingWithInput_sync_input_I_ret_OwhereValue_eq__lp_I_rp__ret_O,
                parameters: [input.anyParameter]
            )
        }
    }

    public let recorder = Recorder()

    private let fileID: String
    private let filePath: StaticString
    private let line: UInt
    private let column: Int

    public init(
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column
    ) {
        self.fileID = fileID
        self.filePath = filePath
        self.line = line
        self.column = column
    }

    private func _record(
        _ expectation: Recorder.Expectation,
        _ fileID: String,
        _ filePath: StaticString,
        _ line: UInt,
        _ column: Int,
        _ perform: some Any
    ) {
        guard isEnabled else {
            handleFatalFailure(
                "Setting expectation on disabled mock is not allowed",
                fileID: fileID,
                filePath: filePath,
                line: line,
                column: column
            )
        }
        recorder.record(
            .init(
                expectation,
                perform,
                fileID,
                filePath,
                line,
                column
            )
        )
    }

    private func _perform(_ method: MockMethod, _ parameters: [Any?] = []) -> Any {
        let invocation = Invocation(
            method: method,
            parameters: parameters
        )
        guard let stub = recorder.next() else {
            handleFatalFailure(
                "Expected no calls but received `\(invocation)`",
                fileID: fileID,
                filePath: filePath,
                line: line,
                column: column
            )
        }

        guard stub.matches(invocation) else {
            handleFatalFailure(
                "Unexpected call: expected `\(stub.expectation)`, but received `\(invocation)`",
                fileID: stub.fileID,
                filePath: stub.filePath,
                line: stub.line,
                column: stub.column
            )
        }

        defer { recorder.checkVerification() }
        return stub.perform
    }

    public func doSomething(with value: Value) {
        let perform = _perform(
            Methods.doSomething_syncwith_value_Value_ret_Void,
            [value]
        ) as! (_ value: Value) -> Void
        return perform(value)
    }

    public func doSomething(with value: ConstrainedValue) {
        let perform = _perform(
            Methods.doSomething_syncwith_value_ConstrainedValue_ret_Void,
            [value]
        ) as! (_ value: ConstrainedValue) -> Void
        return perform(value)
    }

    public func doSomethingWithInput<I, O>(_ input: I) -> O {
        let perform = _perform(
            Methods.doSomethingWithInput_sync_input_I_ret_OwhereValue_eq__lp_I_rp__ret_O,
            [input]
        ) as! (_ input: I) -> O
        return perform(input)
    }

    public func expect(
        _ expectation: MethodExpectation<(_ value: Value) -> Void>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ value: Value) -> Void = { _ in }
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    public func expect(
        _ expectation: MethodExpectation<(_ value: ConstrainedValue) -> Void>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ value: ConstrainedValue) -> Void = { _ in }
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    public func expect<I, O>(
        _ expectation: MethodExpectation<(_ input: I) -> O>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ input: I) -> O
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }
}

open class Test3rdPartyProtocolMock<Input, Output>: Test3rdPartyProtocol, Mock {
    public typealias Input = Input
    public typealias Output = Output

    enum Methods {
        static var doSomething_sync_string_Input_ret_Output: MockMethod {
            .init {
                "doSomething(\($0[0] ?? "nil"))"
            }
        }
    }

    public struct MethodExpectation<Signature> {
        public let expectation: Recorder.Expectation

        init(method: MockMethod, parameters: [AnyParameter]) {
            self.expectation = .init(
                method: method,
                parameters: parameters
            )
        }

        public static func doSomething(_ string: Parameter<Input>) -> Self
        where Signature == (_ string: Input) -> Output {
            .init(
                method: Methods.doSomething_sync_string_Input_ret_Output,
                parameters: [string.anyParameter]
            )
        }
    }

    public let recorder = Recorder()

    private let fileID: String
    private let filePath: StaticString
    private let line: UInt
    private let column: Int

    public init(
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column
    ) {
        self.fileID = fileID
        self.filePath = filePath
        self.line = line
        self.column = column
    }

    private func _record(
        _ expectation: Recorder.Expectation,
        _ fileID: String,
        _ filePath: StaticString,
        _ line: UInt,
        _ column: Int,
        _ perform: some Any
    ) {
        guard isEnabled else {
            handleFatalFailure(
                "Setting expectation on disabled mock is not allowed",
                fileID: fileID,
                filePath: filePath,
                line: line,
                column: column
            )
        }
        recorder.record(
            .init(
                expectation,
                perform,
                fileID,
                filePath,
                line,
                column
            )
        )
    }

    private func _perform(_ method: MockMethod, _ parameters: [Any?] = []) -> Any {
        let invocation = Invocation(
            method: method,
            parameters: parameters
        )
        guard let stub = recorder.next() else {
            handleFatalFailure(
                "Expected no calls but received `\(invocation)`",
                fileID: fileID,
                filePath: filePath,
                line: line,
                column: column
            )
        }

        guard stub.matches(invocation) else {
            handleFatalFailure(
                "Unexpected call: expected `\(stub.expectation)`, but received `\(invocation)`",
                fileID: stub.fileID,
                filePath: stub.filePath,
                line: stub.line,
                column: stub.column
            )
        }

        defer { recorder.checkVerification() }
        return stub.perform
    }

    public func doSomething(_ string: Input) -> Output {
        let perform = _perform(
            Methods.doSomething_sync_string_Input_ret_Output,
            [string]
        ) as! (_ string: Input) -> Output
        return perform(string)
    }

    public func expect(
        _ expectation: MethodExpectation<(_ string: Input) -> Output>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ string: Input) -> Output
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }
}

open class TestMockableMock: TestMockable, @unchecked Sendable, Mock {
    enum Methods {
        static var forceUnwrappedResult_sync_ret_String_impopt_: MockMethod {
            .init { _ in
                "forceUnwrappedResult()"
            }
        }

        static var newAPI_sync_ret_Void: MockMethod {
            .init { _ in
                "newAPI()"
            }
        }

        static var noParamsVoid_sync_ret_Void: MockMethod {
            .init { _ in
                "noParamsVoid()"
            }
        }

        static var noParamsVoidAsync_async_ret_Void: MockMethod {
            .init { _ in
                "noParamsVoidAsync()"
            }
        }

        static var noParamsVoidAsyncThrowing_async_ret_Void: MockMethod {
            .init { _ in
                "noParamsVoidAsyncThrowing()"
            }
        }

        static var noParamsResult_sync_ret_Swift_Int: MockMethod {
            .init { _ in
                "noParamsResult()"
            }
        }

        static var noParamsResult_sync_ret_Int_opt_: MockMethod {
            .init { _ in
                "noParamsResult()"
            }
        }

        static var noParamsImplicitOptionalResult_sync_ret_Int_impopt_: MockMethod {
            .init { _ in
                "noParamsImplicitOptionalResult()"
            }
        }

        static var noParamsArrayResult_sync_ret__lsb_Int_rsb_: MockMethod {
            .init { _ in
                "noParamsArrayResult()"
            }
        }

        static var noParamsDictionaryResult_sync_ret__lsb_String_col_Int_rsb_: MockMethod {
            .init { _ in
                "noParamsDictionaryResult()"
            }
        }

        static var noParamsClosureResult_sync_ret__lp_Int_rp__ret_Void: MockMethod {
            .init { _ in
                "noParamsClosureResult()"
            }
        }

        static var noParamsResultAsync_async_ret_Int: MockMethod {
            .init { _ in
                "noParamsResultAsync()"
            }
        }

        static var noParamsAsyncThrowingResult_async_ret_Int: MockMethod {
            .init { _ in
                "noParamsAsyncThrowingResult()"
            }
        }

        static var func_sync_ret_Void: MockMethod {
            .init { _ in
                "`func`()"
            }
        }

        static var withSelf_sync_self_Self_ret_Self: MockMethod {
            .init {
                "withSelf(\($0[0] ?? "nil"))"
            }
        }

        static var withOptionalClosure_sync_closure__lp__lp_Int_rp__ret_Void_rp__opt__ret_Void: MockMethod {
            .init {
                "withOptionalClosure(\($0[0] ?? "nil"))"
            }
        }

        static var withAnnotatedClosure_sync_closure__lp__lp_Int_rp__ret_Void_rp__opt__ret_Void: MockMethod {
            .init {
                "withAnnotatedClosure(\($0[0] ?? "nil"))"
            }
        }

        static var withParamsVoid_syncint_int_Swift_Int_label_labelString_String__string_String__optional_Int_opt___implicitOptional_Int_impopt___inout_inoutInt__array__lsb_Int_rsb___dictionary__lsb_String_col_Int_rsb___escapingClosure__lp_Int_rp__ret_Void_ret_Void: MockMethod {
            .init {
                "withParamsVoid(int: \($0[0] ?? "nil"), label: \"\($0[1]!)\", \"\($0[2]!)\", \($0[3] ?? "nil"), \($0[4] ?? "nil"), \($0[5] ?? "nil"), \($0[6] ?? "nil"), \($0[7] ?? "nil"), \($0[8] ?? "nil"))"
            }
        }

        static var withParamsVoidAsync_asyncint_int_Int_label_labelString_String__string_String__optional_Int_opt__ret_Void: MockMethod {
            .init {
                "withParamsVoidAsync(int: \($0[0] ?? "nil"), label: \"\($0[1]!)\", \"\($0[2]!)\", \($0[3] ?? "nil"))"
            }
        }

        static var withParamsVoidAsyncThrowing_asyncint_int_Int_label_labelString_String__string_String__optional_Int_opt__ret_Void: MockMethod {
            .init {
                "withParamsVoidAsyncThrowing(int: \($0[0] ?? "nil"), label: \"\($0[1]!)\", \"\($0[2]!)\", \($0[3] ?? "nil"))"
            }
        }

        static var withParamsResult_syncint_int_Int_label_labelString_String__string_String_ret_Int: MockMethod {
            .init {
                "withParamsResult(int: \($0[0] ?? "nil"), label: \"\($0[1]!)\", \"\($0[2]!)\")"
            }
        }

        static var withParamsResult_syncotherInt_otherInt_Int_label_labelString_String__string_String_ret_Int: MockMethod {
            .init {
                "withParamsResult(otherInt: \($0[0] ?? "nil"), label: \"\($0[1]!)\", \"\($0[2]!)\")"
            }
        }

        static var withParamsResultAsync_asyncint_int_Int_label_labelString_String__string_String_ret_Int: MockMethod {
            .init {
                "withParamsResultAsync(int: \($0[0] ?? "nil"), label: \"\($0[1]!)\", \"\($0[2]!)\")"
            }
        }

        static var withParamsAsyncThrowingResult_asyncint_int_Int_label_labelString_String__string_String_ret_Int: MockMethod {
            .init {
                "withParamsAsyncThrowingResult(int: \($0[0] ?? "nil"), label: \"\($0[1]!)\", \"\($0[2]!)\")"
            }
        }

        static var generic_syncparameter1_parameter1_P1__parameter2_P2_ret_IntwhereP2_col_Hashable: MockMethod {
            .init {
                "generic<P1: Equatable, P2>(parameter1: \($0[0] ?? "nil"), \($0[1] ?? "nil"))"
            }
        }

        static var generic_syncsome_some_someTestGenericProtocol_lab_Int_rab__any_any_anyTestGenericProtocol_lab_String_rab__ret_Int: MockMethod {
            .init {
                "generic(some: \($0[0] ?? "nil"), any: \($0[1] ?? "nil"))"
            }
        }

        static var discardableResult_sync_ret_String: MockMethod {
            .init { _ in
                "discardableResult()"
            }
        }

        static var closureAliasResult_sync_closure_ClosureAlias_lab_Int_rab__ret_ClosureAlias_lab_Int_rab_: MockMethod {
            .init {
                "closureAliasResult(\($0[0] ?? "nil"))"
            }
        }

        static var closureAliasResultEquivalent_sync_closure__lp_Int_rp__ret_Void_ret__lp_Int_rp__ret_Void: MockMethod {
            .init {
                "closureAliasResultEquivalent(\($0[0] ?? "nil"))"
            }
        }

        static var property_sync_ret_OnlyProperty: MockMethod {
            .init { _ in
                "property"
            }
        }

        static var throwingProperty_sync_ret_Int: MockMethod {
            .init { _ in
                "throwingProperty"
            }
        }

        static var asyncProperty_async_ret_Int: MockMethod {
            .init { _ in
                "asyncProperty"
            }
        }

        static var asyncThrowingProperty_async_ret_Int: MockMethod {
            .init { _ in
                "asyncThrowingProperty"
            }
        }

        static var readwriteProperty_sync_ret_Int: MockMethod {
            .init { _ in
                "readwriteProperty"
            }
        }

        static var set_readwriteProperty_sync_ret_Int: MockMethod {
            .init {
                "readwriteProperty = \($0[0] ?? "nil")"
            }
        }

        static var forceUnwrapped_sync_ret_String_impopt_: MockMethod {
            .init { _ in
                "forceUnwrapped"
            }
        }

        static var set_forceUnwrapped_sync_ret_String_impopt_: MockMethod {
            .init {
                "forceUnwrapped = \($0[0] ?? "nil")"
            }
        }

        static var subscript_get_by_key_key_String_Int: MockMethod {
            .init {
                "[key: \"\($0[0]!)\"]"
            }
        }

        static var subscript_set_by_key_key_String_Int: MockMethod {
            .init {
                "[key: \"\($0[0]!)\"] = \($0.last! ?? "nil")"
            }
        }

        static var subscript_get_by_key_key_Int_String: MockMethod {
            .init {
                "[key: \($0[0] ?? "nil")]"
            }
        }
    }

    public struct MethodExpectation<Signature> {
        public let expectation: Recorder.Expectation

        init(method: MockMethod, parameters: [AnyParameter]) {
            self.expectation = .init(
                method: method,
                parameters: parameters
            )
        }

        public static func forceUnwrappedResult() -> Self
        where Signature == () -> String? {
            .init(
                method: Methods.forceUnwrappedResult_sync_ret_String_impopt_,
                parameters: []
            )
        }

        @available(iOS 15.0, *)
        public static func newAPI() -> Self
        where Signature == () -> Void {
            .init(
                method: Methods.newAPI_sync_ret_Void,
                parameters: []
            )
        }

        public static func noParamsVoid() -> Self
        where Signature == () -> Void {
            .init(
                method: Methods.noParamsVoid_sync_ret_Void,
                parameters: []
            )
        }

        public static func noParamsVoidAsync() -> Self
        where Signature == () async -> Void {
            .init(
                method: Methods.noParamsVoidAsync_async_ret_Void,
                parameters: []
            )
        }

        public static func noParamsVoidAsyncThrowing() -> Self
        where Signature == () async throws -> Void {
            .init(
                method: Methods.noParamsVoidAsyncThrowing_async_ret_Void,
                parameters: []
            )
        }

        public static func noParamsResult() -> Self
        where Signature == () -> Swift.Int {
            .init(
                method: Methods.noParamsResult_sync_ret_Swift_Int,
                parameters: []
            )
        }

        public static func noParamsResult() -> Self
        where Signature == () -> Int? {
            .init(
                method: Methods.noParamsResult_sync_ret_Int_opt_,
                parameters: []
            )
        }

        public static func noParamsImplicitOptionalResult() -> Self
        where Signature == () -> Int? {
            .init(
                method: Methods.noParamsImplicitOptionalResult_sync_ret_Int_impopt_,
                parameters: []
            )
        }

        public static func noParamsArrayResult() -> Self
        where Signature == () -> [Int] {
            .init(
                method: Methods.noParamsArrayResult_sync_ret__lsb_Int_rsb_,
                parameters: []
            )
        }

        public static func noParamsDictionaryResult() -> Self
        where Signature == () -> [String: Int] {
            .init(
                method: Methods.noParamsDictionaryResult_sync_ret__lsb_String_col_Int_rsb_,
                parameters: []
            )
        }

        public static func noParamsClosureResult() -> Self
        where Signature == () -> (Int) -> Void {
            .init(
                method: Methods.noParamsClosureResult_sync_ret__lp_Int_rp__ret_Void,
                parameters: []
            )
        }

        public static func noParamsResultAsync() -> Self
        where Signature == () async -> Int {
            .init(
                method: Methods.noParamsResultAsync_async_ret_Int,
                parameters: []
            )
        }

        public static func noParamsAsyncThrowingResult() -> Self
        where Signature == () async throws -> Int {
            .init(
                method: Methods.noParamsAsyncThrowingResult_async_ret_Int,
                parameters: []
            )
        }

        public static func `func`() -> Self
        where Signature == () -> Void {
            .init(
                method: Methods.func_sync_ret_Void,
                parameters: []
            )
        }

        public static func withSelf(_ self: Parameter<TestMockableMock>) -> Self
        where Signature == (_ self: TestMockableMock) -> TestMockableMock {
            .init(
                method: Methods.withSelf_sync_self_Self_ret_Self,
                parameters: [self.anyParameter]
            )
        }

        public static func withOptionalClosure(_ closure: Parameter<((Int) -> Void)?>) -> Self
        where Signature == (_ closure: ((Int) -> Void)?) -> Void {
            .init(
                method: Methods.withOptionalClosure_sync_closure__lp__lp_Int_rp__ret_Void_rp__opt__ret_Void,
                parameters: [closure.anyParameter]
            )
        }

        public static func withAnnotatedClosure(_ closure: Parameter<(@MainActor @Sendable (Int) -> Void)?>) -> Self
        where Signature == (_ closure: (@MainActor @Sendable (Int) -> Void)?) -> Void {
            .init(
                method: Methods.withAnnotatedClosure_sync_closure__lp__lp_Int_rp__ret_Void_rp__opt__ret_Void,
                parameters: [closure.anyParameter]
            )
        }

        public static func withParamsVoid(int: Parameter<Swift.Int>, label labelString: Parameter<String>, _ string: Parameter<String>, _ optional: Parameter<Int?>, _ implicitOptional: Parameter<Int?>, _ `inout`: Parameter<Int>, _ array: Parameter<[Int]>, _ dictionary: Parameter<[String: Int]>, _ escapingClosure: Parameter<(Int) -> Void>) -> Self
        where Signature == (_ int: Swift.Int, _ labelString: String, _ string: String, _ optional: Int?, _ implicitOptional: Int?, _ `inout`: inout Int, _ array: [Int], _ dictionary: [String: Int], _ escapingClosure: (Int) -> Void) -> Void {
            .init(
                method: Methods.withParamsVoid_syncint_int_Swift_Int_label_labelString_String__string_String__optional_Int_opt___implicitOptional_Int_impopt___inout_inoutInt__array__lsb_Int_rsb___dictionary__lsb_String_col_Int_rsb___escapingClosure__lp_Int_rp__ret_Void_ret_Void,
                parameters: [int.anyParameter, labelString.anyParameter, string.anyParameter, optional.anyParameter, implicitOptional.anyParameter, `inout`.anyParameter, array.anyParameter, dictionary.anyParameter, escapingClosure.anyParameter]
            )
        }

        public static func withParamsVoidAsync(int: Parameter<Int>, label labelString: Parameter<String>, _ string: Parameter<String>, _ optional: Parameter<Int?>) -> Self
        where Signature == (_ int: Int, _ labelString: String, _ string: String, _ optional: Int?) async -> Void {
            .init(
                method: Methods.withParamsVoidAsync_asyncint_int_Int_label_labelString_String__string_String__optional_Int_opt__ret_Void,
                parameters: [int.anyParameter, labelString.anyParameter, string.anyParameter, optional.anyParameter]
            )
        }

        public static func withParamsVoidAsyncThrowing(int: Parameter<Int>, label labelString: Parameter<String>, _ string: Parameter<String>, _ optional: Parameter<Int?>) -> Self
        where Signature == (_ int: Int, _ labelString: String, _ string: String, _ optional: Int?) async throws -> Void {
            .init(
                method: Methods.withParamsVoidAsyncThrowing_asyncint_int_Int_label_labelString_String__string_String__optional_Int_opt__ret_Void,
                parameters: [int.anyParameter, labelString.anyParameter, string.anyParameter, optional.anyParameter]
            )
        }

        public static func withParamsResult(int: Parameter<Int>, label labelString: Parameter<String>, _ string: Parameter<String>) -> Self
        where Signature == (_ int: Int, _ labelString: String, _ string: String) -> Int {
            .init(
                method: Methods.withParamsResult_syncint_int_Int_label_labelString_String__string_String_ret_Int,
                parameters: [int.anyParameter, labelString.anyParameter, string.anyParameter]
            )
        }

        public static func withParamsResult(otherInt: Parameter<Int>, label labelString: Parameter<String>, _ string: Parameter<String>) -> Self
        where Signature == (_ otherInt: Int, _ labelString: String, _ string: String) -> Int {
            .init(
                method: Methods.withParamsResult_syncotherInt_otherInt_Int_label_labelString_String__string_String_ret_Int,
                parameters: [otherInt.anyParameter, labelString.anyParameter, string.anyParameter]
            )
        }

        public static func withParamsResultAsync(int: Parameter<Int>, label labelString: Parameter<String>, _ string: Parameter<String>) -> Self
        where Signature == (_ int: Int, _ labelString: String, _ string: String) async -> Int {
            .init(
                method: Methods.withParamsResultAsync_asyncint_int_Int_label_labelString_String__string_String_ret_Int,
                parameters: [int.anyParameter, labelString.anyParameter, string.anyParameter]
            )
        }

        public static func withParamsAsyncThrowingResult(int: Parameter<Int>, label labelString: Parameter<String>, _ string: Parameter<String>) -> Self
        where Signature == (_ int: Int, _ labelString: String, _ string: String) async throws -> Int {
            .init(
                method: Methods.withParamsAsyncThrowingResult_asyncint_int_Int_label_labelString_String__string_String_ret_Int,
                parameters: [int.anyParameter, labelString.anyParameter, string.anyParameter]
            )
        }

        public static func generic<P1: Equatable, P2>(parameter1: Parameter<P1>, _ parameter2: Parameter<P2>) -> Self
        where Signature == (_ parameter1: P1, _ parameter2: P2) -> Int, P2: Hashable {
            .init(
                method: Methods.generic_syncparameter1_parameter1_P1__parameter2_P2_ret_IntwhereP2_col_Hashable,
                parameters: [parameter1.anyParameter, parameter2.anyParameter]
            )
        }

        @available(macOS 13, iOS 16, *)
        public static func generic(some: Parameter<some TestGenericProtocol<Int>>, any: Parameter<any TestGenericProtocol<String>>) -> Self
        where Signature == (_ some: any TestGenericProtocol<Int>, _ any: any TestGenericProtocol<String>) -> Int {
            .init(
                method: Methods.generic_syncsome_some_someTestGenericProtocol_lab_Int_rab__any_any_anyTestGenericProtocol_lab_String_rab__ret_Int,
                parameters: [some.anyParameter, any.anyParameter]
            )
        }

        @discardableResult
        public static func discardableResult() -> Self
        where Signature == () -> String {
            .init(
                method: Methods.discardableResult_sync_ret_String,
                parameters: []
            )
        }

        public static func closureAliasResult(_ closure: Parameter<ClosureAlias<Int>>) -> Self
        where Signature == (_ closure: (Int) -> Void) -> (Int) -> Void {
            .init(
                method: Methods.closureAliasResult_sync_closure_ClosureAlias_lab_Int_rab__ret_ClosureAlias_lab_Int_rab_,
                parameters: [closure.anyParameter]
            )
        }

        public static func closureAliasResultEquivalent(_ closure: Parameter<(Int) -> Void>) -> Self
        where Signature == (_ closure: (Int) -> Void) -> (Int) -> Void {
            .init(
                method: Methods.closureAliasResultEquivalent_sync_closure__lp_Int_rp__ret_Void_ret__lp_Int_rp__ret_Void,
                parameters: [closure.anyParameter]
            )
        }
    }

    public struct PropertyExpectation<Signature> {
        private let method: MockMethod

        init(method: MockMethod) {
            self.method = method
        }

        public var getterExpectation: Recorder.Expectation {
            .init(
                method: method,
                parameters: []
            )
        }

        public func setterExpectation(_ newValue: AnyParameter) -> Recorder.Expectation {
            .init(
                method: method,
                parameters: [newValue]
            )
        }
    }

    public struct SubscriptExpectation<Signature> {
        private let method: MockMethod
        private let parameters: [AnyParameter]

        init(method: MockMethod, parameters: [AnyParameter]) {
            self.method = method
            self.parameters = parameters
        }

        public var getterExpectation: Recorder.Expectation {
            .init(
                method: method,
                parameters: parameters
            )
        }

        public func setterExpectation(_ newValue: AnyParameter) -> Recorder.Expectation {
            .init(
                method: method,
                parameters: parameters + [newValue]
            )
        }

        public static var `subscript`: TestMockableMock.SubscriptExpectations { .init() }
    }

    public struct SubscriptExpectations {
        public subscript(key: Parameter<String>) -> TestMockableMock.SubscriptExpectation<(_ key: String) -> Int> {
            .init(
                method: Methods.subscript_get_by_key_key_String_Int,
                parameters: [key.anyParameter]
            )
        }

        public subscript(key: Parameter<String>) -> TestMockableMock.SubscriptExpectation<(String, _ newValue: Int) -> Void> {
            .init(
                method: Methods.subscript_set_by_key_key_String_Int,
                parameters: [key.anyParameter]
            )
        }

        public subscript(key: Parameter<Int>) -> TestMockableMock.SubscriptExpectation<(_ key: Int) -> String> {
            .init(
                method: Methods.subscript_get_by_key_key_Int_String,
                parameters: [key.anyParameter]
            )
        }
    }

    public let recorder = Recorder()

    private let fileID: String
    private let filePath: StaticString
    private let line: UInt
    private let column: Int

    public init(
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column
    ) {
        self.fileID = fileID
        self.filePath = filePath
        self.line = line
        self.column = column
    }

    private func _record(
        _ expectation: Recorder.Expectation,
        _ fileID: String,
        _ filePath: StaticString,
        _ line: UInt,
        _ column: Int,
        _ perform: some Any
    ) {
        guard isEnabled else {
            handleFatalFailure(
                "Setting expectation on disabled mock is not allowed",
                fileID: fileID,
                filePath: filePath,
                line: line,
                column: column
            )
        }
        recorder.record(
            .init(
                expectation,
                perform,
                fileID,
                filePath,
                line,
                column
            )
        )
    }

    private func _perform(_ method: MockMethod, _ parameters: [Any?] = []) -> Any {
        let invocation = Invocation(
            method: method,
            parameters: parameters
        )
        guard let stub = recorder.next() else {
            handleFatalFailure(
                "Expected no calls but received `\(invocation)`",
                fileID: fileID,
                filePath: filePath,
                line: line,
                column: column
            )
        }

        guard stub.matches(invocation) else {
            handleFatalFailure(
                "Unexpected call: expected `\(stub.expectation)`, but received `\(invocation)`",
                fileID: stub.fileID,
                filePath: stub.filePath,
                line: stub.line,
                column: stub.column
            )
        }

        defer { recorder.checkVerification() }
        return stub.perform
    }

    public func forceUnwrappedResult() -> String! {
        let perform = _perform(Methods.forceUnwrappedResult_sync_ret_String_impopt_) as! () -> String?
        return perform()
    }

    @available(iOS 15.0, *)
    public func newAPI() {
        let perform = _perform(Methods.newAPI_sync_ret_Void) as! () -> Void
        return perform()
    }

    public func noParamsVoid() {
        let perform = _perform(Methods.noParamsVoid_sync_ret_Void) as! () -> Void
        return perform()
    }

    public func noParamsVoidAsync() async {
        let perform = _perform(Methods.noParamsVoidAsync_async_ret_Void) as! () async -> Void
        return await perform()
    }

    public func noParamsVoidAsyncThrowing() async throws {
        let perform = _perform(Methods.noParamsVoidAsyncThrowing_async_ret_Void) as! () async throws -> Void
        return try await perform()
    }

    public func noParamsResult() -> Swift.Int {
        let perform = _perform(Methods.noParamsResult_sync_ret_Swift_Int) as! () -> Swift.Int
        return perform()
    }

    public func noParamsResult() -> Int? {
        let perform = _perform(Methods.noParamsResult_sync_ret_Int_opt_) as! () -> Int?
        return perform()
    }

    public func noParamsImplicitOptionalResult() -> Int! {
        let perform = _perform(Methods.noParamsImplicitOptionalResult_sync_ret_Int_impopt_) as! () -> Int?
        return perform()
    }

    public func noParamsArrayResult() -> [Int] {
        let perform = _perform(Methods.noParamsArrayResult_sync_ret__lsb_Int_rsb_) as! () -> [Int]
        return perform()
    }

    public func noParamsDictionaryResult() -> [String: Int] {
        let perform = _perform(Methods.noParamsDictionaryResult_sync_ret__lsb_String_col_Int_rsb_) as! () -> [String: Int]
        return perform()
    }

    public func noParamsClosureResult() -> (Int) -> Void {
        let perform = _perform(Methods.noParamsClosureResult_sync_ret__lp_Int_rp__ret_Void) as! () -> (Int) -> Void
        return perform()
    }

    public func noParamsResultAsync() async -> Int {
        let perform = _perform(Methods.noParamsResultAsync_async_ret_Int) as! () async -> Int
        return await perform()
    }

    public func noParamsAsyncThrowingResult() async throws -> Int {
        let perform = _perform(Methods.noParamsAsyncThrowingResult_async_ret_Int) as! () async throws -> Int
        return try await perform()
    }

    public func `func`() {
        let perform = _perform(Methods.func_sync_ret_Void) as! () -> Void
        return perform()
    }

    public func withSelf(_ self: TestMockableMock) -> Self {
        let perform = _perform(
            Methods.withSelf_sync_self_Self_ret_Self,
            [self]
        ) as! (_ self: TestMockableMock) -> Self
        return perform(self)
    }

    public func withOptionalClosure(_ closure: ((Int) -> Void)?) {
        let perform = _perform(
            Methods.withOptionalClosure_sync_closure__lp__lp_Int_rp__ret_Void_rp__opt__ret_Void,
            [closure]
        ) as! (_ closure: ((Int) -> Void)?) -> Void
        return perform(closure)
    }

    public func withAnnotatedClosure(_ closure: (@MainActor @Sendable (Int) -> Void)?) {
        let perform = _perform(
            Methods.withAnnotatedClosure_sync_closure__lp__lp_Int_rp__ret_Void_rp__opt__ret_Void,
            [closure]
        ) as! (_ closure: (@MainActor @Sendable (Int) -> Void)?) -> Void
        return perform(closure)
    }

    public func withParamsVoid(int: Swift.Int, label labelString: String, _ string: String, _ optional: Int?, _ implicitOptional: Int!, _ `inout`: inout Int, _ array: [Int], _ dictionary: [String: Int], _ escapingClosure: @escaping (Int) -> Void) {
        let perform = _perform(
            Methods.withParamsVoid_syncint_int_Swift_Int_label_labelString_String__string_String__optional_Int_opt___implicitOptional_Int_impopt___inout_inoutInt__array__lsb_Int_rsb___dictionary__lsb_String_col_Int_rsb___escapingClosure__lp_Int_rp__ret_Void_ret_Void,
            [int, labelString, string, optional, implicitOptional, `inout`, array, dictionary, escapingClosure]
        ) as! (_ int: Swift.Int, _ labelString: String, _ string: String, _ optional: Int?, _ implicitOptional: Int?, _ `inout`: inout Int, _ array: [Int], _ dictionary: [String: Int], _ escapingClosure: (Int) -> Void) -> Void
        return perform(int, labelString, string, optional, implicitOptional, &`inout`, array, dictionary, escapingClosure)
    }

    public func withParamsVoidAsync(int: Int, label labelString: String, _ string: String, _ optional: Int?) async {
        let perform = _perform(
            Methods.withParamsVoidAsync_asyncint_int_Int_label_labelString_String__string_String__optional_Int_opt__ret_Void,
            [int, labelString, string, optional]
        ) as! (_ int: Int, _ labelString: String, _ string: String, _ optional: Int?) async -> Void
        return await perform(int, labelString, string, optional)
    }

    public func withParamsVoidAsyncThrowing(int: Int, label labelString: String, _ string: String, _ optional: Int?) async throws {
        let perform = _perform(
            Methods.withParamsVoidAsyncThrowing_asyncint_int_Int_label_labelString_String__string_String__optional_Int_opt__ret_Void,
            [int, labelString, string, optional]
        ) as! (_ int: Int, _ labelString: String, _ string: String, _ optional: Int?) async throws -> Void
        return try await perform(int, labelString, string, optional)
    }

    public func withParamsResult(int: Int, label labelString: String, _ string: String) -> Int {
        let perform = _perform(
            Methods.withParamsResult_syncint_int_Int_label_labelString_String__string_String_ret_Int,
            [int, labelString, string]
        ) as! (_ int: Int, _ labelString: String, _ string: String) -> Int
        return perform(int, labelString, string)
    }

    public func withParamsResult(otherInt: Int, label labelString: String, _ string: String) -> Int {
        let perform = _perform(
            Methods.withParamsResult_syncotherInt_otherInt_Int_label_labelString_String__string_String_ret_Int,
            [otherInt, labelString, string]
        ) as! (_ otherInt: Int, _ labelString: String, _ string: String) -> Int
        return perform(otherInt, labelString, string)
    }

    public func withParamsResultAsync(int: Int, label labelString: String, _ string: String) async -> Int {
        let perform = _perform(
            Methods.withParamsResultAsync_asyncint_int_Int_label_labelString_String__string_String_ret_Int,
            [int, labelString, string]
        ) as! (_ int: Int, _ labelString: String, _ string: String) async -> Int
        return await perform(int, labelString, string)
    }

    public func withParamsAsyncThrowingResult(int: Int, label labelString: String, _ string: String) async throws -> Int {
        let perform = _perform(
            Methods.withParamsAsyncThrowingResult_asyncint_int_Int_label_labelString_String__string_String_ret_Int,
            [int, labelString, string]
        ) as! (_ int: Int, _ labelString: String, _ string: String) async throws -> Int
        return try await perform(int, labelString, string)
    }

    public func generic<P1: Equatable, P2>(parameter1: P1, _ parameter2: P2) -> Int {
        let perform = _perform(
            Methods.generic_syncparameter1_parameter1_P1__parameter2_P2_ret_IntwhereP2_col_Hashable,
            [parameter1, parameter2]
        ) as! (_ parameter1: P1, _ parameter2: P2) -> Int
        return perform(parameter1, parameter2)
    }

    @available(macOS 13, iOS 16, *)
    public func generic(some: some TestGenericProtocol<Int>, any: any TestGenericProtocol<String>) -> Int {
        let perform = _perform(
            Methods.generic_syncsome_some_someTestGenericProtocol_lab_Int_rab__any_any_anyTestGenericProtocol_lab_String_rab__ret_Int,
            [some, any]
        ) as! (_ some: any TestGenericProtocol<Int>, _ any: any TestGenericProtocol<String>) -> Int
        return perform(some, any)
    }

    @discardableResult
    public func discardableResult() -> String {
        let perform = _perform(Methods.discardableResult_sync_ret_String) as! () -> String
        return perform()
    }

    public func closureAliasResult(_ closure: @escaping ClosureAlias<Int>) -> (Int) -> Void {
        let perform = _perform(
            Methods.closureAliasResult_sync_closure_ClosureAlias_lab_Int_rab__ret_ClosureAlias_lab_Int_rab_,
            [closure]
        ) as! (_ closure: (Int) -> Void) -> (Int) -> Void
        return perform(closure)
    }

    public func closureAliasResultEquivalent(_ closure: @escaping (Int) -> Void) -> (Int) -> Void {
        let perform = _perform(
            Methods.closureAliasResultEquivalent_sync_closure__lp_Int_rp__ret_Void_ret__lp_Int_rp__ret_Void,
            [closure]
        ) as! (_ closure: (Int) -> Void) -> (Int) -> Void
        return perform(closure)
    }

    public var property: OnlyProperty {
        let perform = _perform(Methods.property_sync_ret_OnlyProperty) as! () -> OnlyProperty
        return perform()
    }

    public var throwingProperty: Int {
        get throws {
            let perform = _perform(Methods.throwingProperty_sync_ret_Int) as! () throws -> Int
            return try perform()
        }
    }

    public var asyncProperty: Int {
        get async {
            let perform = _perform(Methods.asyncProperty_async_ret_Int) as! () async -> Int
            return await perform()
        }
    }

    public var asyncThrowingProperty: Int {
        get async throws {
            let perform = _perform(Methods.asyncThrowingProperty_async_ret_Int) as! () async throws -> Int
            return try await perform()
        }
    }

    public var readwriteProperty: Int {
        get {
            let perform = _perform(Methods.readwriteProperty_sync_ret_Int) as! () -> Int
            return perform()
        }
        set {
            let perform = _perform(
                Methods.set_readwriteProperty_sync_ret_Int,
                [newValue]
            ) as! (_ newValue: Int) -> Void
            return perform(newValue)
        }
    }

    public var forceUnwrapped: String! {
        get {
            let perform = _perform(Methods.forceUnwrapped_sync_ret_String_impopt_) as! () -> String?
            return perform()
        }
        set {
            let perform = _perform(
                Methods.set_forceUnwrapped_sync_ret_String_impopt_,
                [newValue]
            ) as! (_ newValue: String?) -> Void
            return perform(newValue)
        }
    }

    public subscript(key: String) -> Int {
        get {
            let perform = _perform(
                Methods.subscript_get_by_key_key_String_Int,
                [key]
            ) as! (_ key: String) -> Int
            return perform(key)
        }
        set {
            let perform = _perform(
                Methods.subscript_set_by_key_key_String_Int,
                [key, newValue]
            ) as! (String, _ newValue: Int) -> Void
            return perform(key, newValue)
        }
    }

    public subscript(key: Int) -> String {
        let perform = _perform(
            Methods.subscript_get_by_key_key_Int_String,
            [key]
        ) as! (_ key: Int) -> String
        return perform(key)
    }

    public func expect(
        _ expectation: MethodExpectation<() -> String?>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping () -> String?
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    @available(iOS 15.0, *)
    public func expect(
        _ expectation: MethodExpectation<() -> Void>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping () -> Void = {}
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    public func expect(
        _ expectation: MethodExpectation<() async -> Void>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping () async -> Void = {}
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    public func expect(
        _ expectation: MethodExpectation<() async throws -> Void>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping () async throws -> Void = {}
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    public func expect(
        _ expectation: MethodExpectation<() -> Swift.Int>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping () -> Swift.Int
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    public func expect(
        _ expectation: MethodExpectation<() -> Int?>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping () -> Int?
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    public func expect(
        _ expectation: MethodExpectation<() -> [Int]>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping () -> [Int]
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    public func expect(
        _ expectation: MethodExpectation<() -> [String: Int]>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping () -> [String: Int]
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    public func expect(
        _ expectation: MethodExpectation<() -> (Int) -> Void>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping () -> (Int) -> Void
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    public func expect(
        _ expectation: MethodExpectation<() async -> Int>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping () async -> Int
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    public func expect(
        _ expectation: MethodExpectation<() async throws -> Int>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping () async throws -> Int
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    public func expect(
        _ expectation: MethodExpectation<(_ self: TestMockableMock) -> TestMockableMock>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ self: TestMockableMock) -> TestMockableMock
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    public func expect(
        _ expectation: MethodExpectation<(_ closure: ((Int) -> Void)?) -> Void>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ closure: ((Int) -> Void)?) -> Void = { _ in }
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    public func expect(
        _ expectation: MethodExpectation<(_ closure: (@MainActor @Sendable (Int) -> Void)?) -> Void>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ closure: (@MainActor @Sendable (Int) -> Void)?) -> Void = { _ in }
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    public func expect(
        _ expectation: MethodExpectation < (_ int: Swift.Int, _ labelString: String, _ string: String, _ optional: Int?, _ implicitOptional: Int?, _ `inout`: inout Int, _ array: [Int], _ dictionary: [String: Int], _ escapingClosure: (Int) -> Void) -> Void>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ int: Swift.Int, _ labelString: String, _ string: String, _ optional: Int?, _ implicitOptional: Int?, _ `inout`: inout Int, _ array: [Int], _ dictionary: [String: Int], _ escapingClosure: (Int) -> Void) -> Void = { _, _, _, _, _, _, _, _, _ in }
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    public func expect(
        _ expectation: MethodExpectation<(_ int: Int, _ labelString: String, _ string: String, _ optional: Int?) async -> Void>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ int: Int, _ labelString: String, _ string: String, _ optional: Int?) async -> Void = { _, _, _, _ in }
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    public func expect(
        _ expectation: MethodExpectation<(_ int: Int, _ labelString: String, _ string: String, _ optional: Int?) async throws -> Void>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ int: Int, _ labelString: String, _ string: String, _ optional: Int?) async throws -> Void = { _, _, _, _ in }
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    public func expect(
        _ expectation: MethodExpectation<(_ int: Int, _ labelString: String, _ string: String) -> Int>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ int: Int, _ labelString: String, _ string: String) -> Int
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    public func expect(
        _ expectation: MethodExpectation<(_ int: Int, _ labelString: String, _ string: String) async -> Int>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ int: Int, _ labelString: String, _ string: String) async -> Int
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    public func expect(
        _ expectation: MethodExpectation<(_ int: Int, _ labelString: String, _ string: String) async throws -> Int>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ int: Int, _ labelString: String, _ string: String) async throws -> Int
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    public func expect<P1: Equatable, P2>(
        _ expectation: MethodExpectation<(_ parameter1: P1, _ parameter2: P2) -> Int>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ parameter1: P1, _ parameter2: P2) -> Int
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    @available(macOS 13, iOS 16, *)
    public func expect(
        _ expectation: MethodExpectation<(_ some: any TestGenericProtocol<Int>, _ any: any TestGenericProtocol<String>) -> Int>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ some: any TestGenericProtocol<Int>, _ any: any TestGenericProtocol<String>) -> Int
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    public func expect(
        _ expectation: MethodExpectation<() -> String>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping () -> String
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    public func expect(
        _ expectation: MethodExpectation<(_ closure: (Int) -> Void) -> (Int) -> Void>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ closure: (Int) -> Void) -> (Int) -> Void
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    public func expect(
        _ expectation: PropertyExpectation<() -> OnlyProperty>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping () -> OnlyProperty
    ) {
        _record(
            expectation.getterExpectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    public func expect(
        _ expectation: PropertyExpectation<() throws -> Int>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping () throws -> Int
    ) {
        _record(
            expectation.getterExpectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    public func expect(
        _ expectation: PropertyExpectation<() async -> Int>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping () async -> Int
    ) {
        _record(
            expectation.getterExpectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    public func expect(
        _ expectation: PropertyExpectation<() async throws -> Int>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping () async throws -> Int
    ) {
        _record(
            expectation.getterExpectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    public func expect(
        _ expectation: PropertyExpectation<() -> Int>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping () -> Int
    ) {
        _record(
            expectation.getterExpectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    public func expect(
        _ expectation: PropertyExpectation<() -> String?>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping () -> String?
    ) {
        _record(
            expectation.getterExpectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    public func expect(
        set expectation: PropertyExpectation<(_ newValue: OnlyProperty) -> Void>,
        to newValue: Parameter<OnlyProperty>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ newValue: OnlyProperty) -> Void = { _ in }
    ) {
        _record(
            expectation.setterExpectation(newValue.anyParameter),
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    public func expect(
        set expectation: PropertyExpectation<(_ newValue: Int) -> Void>,
        to newValue: Parameter<Int>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ newValue: Int) -> Void = { _ in }
    ) {
        _record(
            expectation.setterExpectation(newValue.anyParameter),
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    public func expect(
        set expectation: PropertyExpectation<(_ newValue: String?) -> Void>,
        to newValue: Parameter<String?>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ newValue: String?) -> Void = { _ in }
    ) {
        _record(
            expectation.setterExpectation(newValue.anyParameter),
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    public func expect(
        _ expectation: SubscriptExpectation<(_ key: String) -> Int>,
        file: StaticString = #filePath,
        line: UInt = #line,
        perform: @escaping (_ key: String) -> Int
    ) {
        _record(
            expectation.getterExpectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    public func expect(
        _ expectation: SubscriptExpectation<(_ key: Int) -> String>,
        file: StaticString = #filePath,
        line: UInt = #line,
        perform: @escaping (_ key: Int) -> String
    ) {
        _record(
            expectation.getterExpectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    public func expect(
        set expectation: SubscriptExpectation<(String, _ newValue: Int) -> Void>,
        to newValue: Parameter<Int>,
        file: StaticString = #filePath,
        line: UInt = #line,
        perform: @escaping (String, _ newValue: Int) -> Void = { _, _ in }
    ) {
        _record(
            expectation.setterExpectation(newValue.anyParameter),
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }
}

public extension TestMockableMock.PropertyExpectation where Signature == () -> OnlyProperty {
    static var property: Self {
        .init(method: TestMockableMock.Methods.property_sync_ret_OnlyProperty)
    }
}

public extension TestMockableMock.PropertyExpectation where Signature == () throws -> Int {
    static var throwingProperty: Self {
        .init(method: TestMockableMock.Methods.throwingProperty_sync_ret_Int)
    }
}

public extension TestMockableMock.PropertyExpectation where Signature == () async -> Int {
    static var asyncProperty: Self {
        .init(method: TestMockableMock.Methods.asyncProperty_async_ret_Int)
    }
}

public extension TestMockableMock.PropertyExpectation where Signature == () async throws -> Int {
    static var asyncThrowingProperty: Self {
        .init(method: TestMockableMock.Methods.asyncThrowingProperty_async_ret_Int)
    }
}

public extension TestMockableMock.PropertyExpectation where Signature == () -> Int {
    static var readwriteProperty: Self {
        .init(method: TestMockableMock.Methods.readwriteProperty_sync_ret_Int)
    }
}

public extension TestMockableMock.PropertyExpectation where Signature == (_ newValue: Int) -> Void {
    static var readwriteProperty: Self {
        .init(method: TestMockableMock.Methods.set_readwriteProperty_sync_ret_Int)
    }
}

public extension TestMockableMock.PropertyExpectation where Signature == () -> String? {
    static var forceUnwrapped: Self {
        .init(method: TestMockableMock.Methods.forceUnwrapped_sync_ret_String_impopt_)
    }
}

public extension TestMockableMock.PropertyExpectation where Signature == (_ newValue: String?) -> Void {
    static var forceUnwrapped: Self {
        .init(method: TestMockableMock.Methods.set_forceUnwrapped_sync_ret_String_impopt_)
    }
}

open class TestMockableClassMock: TestMockableClass, Mock {
    enum Methods {
        static var noParamsVoid_sync_ret_Void: MockMethod {
            .init { _ in
                "noParamsVoid()"
            }
        }

        static var noParamsVoidAsync_async_ret_Void: MockMethod {
            .init { _ in
                "noParamsVoidAsync()"
            }
        }

        static var noParamsVoidAsyncThrowing_async_ret_Void: MockMethod {
            .init { _ in
                "noParamsVoidAsyncThrowing()"
            }
        }

        static var noParamsResult_sync_ret_Int: MockMethod {
            .init { _ in
                "noParamsResult()"
            }
        }

        static var noParamsResultAsync_async_ret_Int: MockMethod {
            .init { _ in
                "noParamsResultAsync()"
            }
        }

        static var noParamsAsyncThrowingResult_async_ret_Int: MockMethod {
            .init { _ in
                "noParamsAsyncThrowingResult()"
            }
        }

        static var withParamsVoid_syncint_int_Int_label_labelString_String__string_String_ret_Void: MockMethod {
            .init {
                "withParamsVoid(int: \($0[0] ?? "nil"), label: \"\($0[1]!)\", \"\($0[2]!)\")"
            }
        }

        static var withParamsVoidAsync_asyncint_int_Int_label_labelString_String__string_String_ret_Void: MockMethod {
            .init {
                "withParamsVoidAsync(int: \($0[0] ?? "nil"), label: \"\($0[1]!)\", \"\($0[2]!)\")"
            }
        }

        static var withParamsVoidAsyncThrowing_asyncint_int_Int_label_labelString_String__string_String_ret_Void: MockMethod {
            .init {
                "withParamsVoidAsyncThrowing(int: \($0[0] ?? "nil"), label: \"\($0[1]!)\", \"\($0[2]!)\")"
            }
        }

        static var withParamsResult_syncint_int_Int_label_labelString_String__string_String_ret_Int: MockMethod {
            .init {
                "withParamsResult(int: \($0[0] ?? "nil"), label: \"\($0[1]!)\", \"\($0[2]!)\")"
            }
        }

        static var withParamsResultAsync_asyncint_int_Int_label_labelString_String__string_String_ret_Int: MockMethod {
            .init {
                "withParamsResultAsync(int: \($0[0] ?? "nil"), label: \"\($0[1]!)\", \"\($0[2]!)\")"
            }
        }

        static var withParamsAsyncThrowingResult_asyncint_int_Int_label_labelString_String__string_String_ret_Int: MockMethod {
            .init {
                "withParamsAsyncThrowingResult(int: \($0[0] ?? "nil"), label: \"\($0[1]!)\", \"\($0[2]!)\")"
            }
        }

        static var openMethod_sync_ret_Void: MockMethod {
            .init { _ in
                "openMethod()"
            }
        }

        static var superNoParamsVoid_sync_ret_Void: MockMethod {
            .init { _ in
                "superNoParamsVoid()"
            }
        }

        static var readwriteProperty_sync_ret_Int: MockMethod {
            .init { _ in
                "readwriteProperty"
            }
        }

        static var set_readwriteProperty_sync_ret_Int: MockMethod {
            .init {
                "readwriteProperty = \($0[0] ?? "nil")"
            }
        }

        static var privateSettableProperty_sync_ret_Int: MockMethod {
            .init { _ in
                "privateSettableProperty"
            }
        }

        static var sideEffectProperty_sync_ret_Int: MockMethod {
            .init { _ in
                "sideEffectProperty"
            }
        }

        static var set_sideEffectProperty_sync_ret_Int: MockMethod {
            .init {
                "sideEffectProperty = \($0[0] ?? "nil")"
            }
        }
    }

    public struct MethodExpectation<Signature> {
        public let expectation: Recorder.Expectation

        init(method: MockMethod, parameters: [AnyParameter]) {
            self.expectation = .init(
                method: method,
                parameters: parameters
            )
        }

        public static func noParamsVoid() -> Self
        where Signature == () -> Void {
            .init(
                method: Methods.noParamsVoid_sync_ret_Void,
                parameters: []
            )
        }

        public static func noParamsVoidAsync() -> Self
        where Signature == () async -> Void {
            .init(
                method: Methods.noParamsVoidAsync_async_ret_Void,
                parameters: []
            )
        }

        public static func noParamsVoidAsyncThrowing() -> Self
        where Signature == () async throws -> Void {
            .init(
                method: Methods.noParamsVoidAsyncThrowing_async_ret_Void,
                parameters: []
            )
        }

        public static func noParamsResult() -> Self
        where Signature == () -> Int {
            .init(
                method: Methods.noParamsResult_sync_ret_Int,
                parameters: []
            )
        }

        public static func noParamsResultAsync() -> Self
        where Signature == () async -> Int {
            .init(
                method: Methods.noParamsResultAsync_async_ret_Int,
                parameters: []
            )
        }

        public static func noParamsAsyncThrowingResult() -> Self
        where Signature == () async throws -> Int {
            .init(
                method: Methods.noParamsAsyncThrowingResult_async_ret_Int,
                parameters: []
            )
        }

        public static func withParamsVoid(int: Parameter<Int>, label labelString: Parameter<String>, _ string: Parameter<String>) -> Self
        where Signature == (_ int: Int, _ labelString: String, _ string: String) -> Void {
            .init(
                method: Methods.withParamsVoid_syncint_int_Int_label_labelString_String__string_String_ret_Void,
                parameters: [int.anyParameter, labelString.anyParameter, string.anyParameter]
            )
        }

        public static func withParamsVoidAsync(int: Parameter<Int>, label labelString: Parameter<String>, _ string: Parameter<String>) -> Self
        where Signature == (_ int: Int, _ labelString: String, _ string: String) async -> Void {
            .init(
                method: Methods.withParamsVoidAsync_asyncint_int_Int_label_labelString_String__string_String_ret_Void,
                parameters: [int.anyParameter, labelString.anyParameter, string.anyParameter]
            )
        }

        public static func withParamsVoidAsyncThrowing(int: Parameter<Int>, label labelString: Parameter<String>, _ string: Parameter<String>) -> Self
        where Signature == (_ int: Int, _ labelString: String, _ string: String) async throws -> Void {
            .init(
                method: Methods.withParamsVoidAsyncThrowing_asyncint_int_Int_label_labelString_String__string_String_ret_Void,
                parameters: [int.anyParameter, labelString.anyParameter, string.anyParameter]
            )
        }

        public static func withParamsResult(int: Parameter<Int>, label labelString: Parameter<String>, _ string: Parameter<String>) -> Self
        where Signature == (_ int: Int, _ labelString: String, _ string: String) -> Int {
            .init(
                method: Methods.withParamsResult_syncint_int_Int_label_labelString_String__string_String_ret_Int,
                parameters: [int.anyParameter, labelString.anyParameter, string.anyParameter]
            )
        }

        public static func withParamsResultAsync(int: Parameter<Int>, label labelString: Parameter<String>, _ string: Parameter<String>) -> Self
        where Signature == (_ int: Int, _ labelString: String, _ string: String) async -> Int {
            .init(
                method: Methods.withParamsResultAsync_asyncint_int_Int_label_labelString_String__string_String_ret_Int,
                parameters: [int.anyParameter, labelString.anyParameter, string.anyParameter]
            )
        }

        public static func withParamsAsyncThrowingResult(int: Parameter<Int>, label labelString: Parameter<String>, _ string: Parameter<String>) -> Self
        where Signature == (_ int: Int, _ labelString: String, _ string: String) async throws -> Int {
            .init(
                method: Methods.withParamsAsyncThrowingResult_asyncint_int_Int_label_labelString_String__string_String_ret_Int,
                parameters: [int.anyParameter, labelString.anyParameter, string.anyParameter]
            )
        }

        public static func openMethod() -> Self
        where Signature == () -> Void {
            .init(
                method: Methods.openMethod_sync_ret_Void,
                parameters: []
            )
        }

        public static func superNoParamsVoid() -> Self
        where Signature == () -> Void {
            .init(
                method: Methods.superNoParamsVoid_sync_ret_Void,
                parameters: []
            )
        }
    }

    public struct PropertyExpectation<Signature> {
        private let method: MockMethod

        init(method: MockMethod) {
            self.method = method
        }

        public var getterExpectation: Recorder.Expectation {
            .init(
                method: method,
                parameters: []
            )
        }

        public func setterExpectation(_ newValue: AnyParameter) -> Recorder.Expectation {
            .init(
                method: method,
                parameters: [newValue]
            )
        }
    }

    public let recorder = Recorder()

    private let fileID: String
    private let filePath: StaticString
    private let line: UInt
    private let column: Int

    @available(*, unavailable)
    public required init() {
        fatalError()
    }

    public init(
        int: Int,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column
    ) {
        self.fileID = fileID
        self.filePath = filePath
        self.line = line
        self.column = column
        self.autoForwardingEnabled = true
        super.init(int: int)
        self.autoForwardingEnabled = false
    }

    public init(
        string: String,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column
    ) {
        self.fileID = fileID
        self.filePath = filePath
        self.line = line
        self.column = column
        self.autoForwardingEnabled = true
        super.init(string: string)
        self.autoForwardingEnabled = false
    }

    public init(
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column
    ) {
        self.fileID = fileID
        self.filePath = filePath
        self.line = line
        self.column = column
        self.autoForwardingEnabled = true
        super.init()
        self.autoForwardingEnabled = false
    }

    public var autoForwardingEnabled: Bool

    public var isEnabled: Bool {
        !autoForwardingEnabled
    }

    private func _record(
        _ expectation: Recorder.Expectation,
        _ fileID: String,
        _ filePath: StaticString,
        _ line: UInt,
        _ column: Int,
        _ perform: some Any
    ) {
        guard isEnabled else {
            handleFatalFailure(
                "Setting expectation on disabled mock is not allowed",
                fileID: fileID,
                filePath: filePath,
                line: line,
                column: column
            )
        }
        recorder.record(
            .init(
                expectation,
                perform,
                fileID,
                filePath,
                line,
                column
            )
        )
    }

    private func _perform(_ method: MockMethod, _ parameters: [Any?] = []) -> Any {
        let invocation = Invocation(
            method: method,
            parameters: parameters
        )
        guard let stub = recorder.next() else {
            handleFatalFailure(
                "Expected no calls but received `\(invocation)`",
                fileID: fileID,
                filePath: filePath,
                line: line,
                column: column
            )
        }

        guard stub.matches(invocation) else {
            handleFatalFailure(
                "Unexpected call: expected `\(stub.expectation)`, but received `\(invocation)`",
                fileID: stub.fileID,
                filePath: stub.filePath,
                line: stub.line,
                column: stub.column
            )
        }

        defer { recorder.checkVerification() }
        return stub.perform
    }

    override public func noParamsVoid() {
        guard !autoForwardingEnabled else {
            return super.noParamsVoid()
        }
        let perform = _perform(Methods.noParamsVoid_sync_ret_Void) as! (_ forwardToOriginal: () -> Void) -> Void
        return perform(super.noParamsVoid)
    }

    override public func noParamsVoidAsync() async {
        guard !autoForwardingEnabled else {
            return await super.noParamsVoidAsync()
        }
        let perform = _perform(Methods.noParamsVoidAsync_async_ret_Void) as! (_ forwardToOriginal: () async -> Void) async -> Void
        return await perform(super.noParamsVoidAsync)
    }

    override public func noParamsVoidAsyncThrowing() async throws {
        guard !autoForwardingEnabled else {
            return try await super.noParamsVoidAsyncThrowing()
        }
        let perform = _perform(Methods.noParamsVoidAsyncThrowing_async_ret_Void) as! (_ forwardToOriginal: () async throws -> Void) async throws -> Void
        return try await perform(super.noParamsVoidAsyncThrowing)
    }

    override public func noParamsResult() -> Int {
        guard !autoForwardingEnabled else {
            return super.noParamsResult()
        }
        let perform = _perform(Methods.noParamsResult_sync_ret_Int) as! (_ forwardToOriginal: () -> Int) -> Int
        return perform(super.noParamsResult)
    }

    override public func noParamsResultAsync() async -> Int {
        guard !autoForwardingEnabled else {
            return await super.noParamsResultAsync()
        }
        let perform = _perform(Methods.noParamsResultAsync_async_ret_Int) as! (_ forwardToOriginal: () async -> Int) async -> Int
        return await perform(super.noParamsResultAsync)
    }

    override public func noParamsAsyncThrowingResult() async throws -> Int {
        guard !autoForwardingEnabled else {
            return try await super.noParamsAsyncThrowingResult()
        }
        let perform = _perform(Methods.noParamsAsyncThrowingResult_async_ret_Int) as! (_ forwardToOriginal: () async throws -> Int) async throws -> Int
        return try await perform(super.noParamsAsyncThrowingResult)
    }

    override public func withParamsVoid(int: Int, label labelString: String, _ string: String) {
        guard !autoForwardingEnabled else {
            return super.withParamsVoid(int: int, label: labelString, string)
        }
        let perform = _perform(
            Methods.withParamsVoid_syncint_int_Int_label_labelString_String__string_String_ret_Void,
            [int, labelString, string]
        ) as! (_ forwardToOriginal: (_ int: Int, _ labelString: String, _ string: String) -> Void, _ int: Int, _ labelString: String, _ string: String) -> Void
        return perform(super.withParamsVoid(int:label:_:), int, labelString, string)
    }

    override public func withParamsVoidAsync(int: Int, label labelString: String, _ string: String) async {
        guard !autoForwardingEnabled else {
            return await super.withParamsVoidAsync(int: int, label: labelString, string)
        }
        let perform = _perform(
            Methods.withParamsVoidAsync_asyncint_int_Int_label_labelString_String__string_String_ret_Void,
            [int, labelString, string]
        ) as! (_ forwardToOriginal: (_ int: Int, _ labelString: String, _ string: String) async -> Void, _ int: Int, _ labelString: String, _ string: String) async -> Void
        return await perform(super.withParamsVoidAsync(int:label:_:), int, labelString, string)
    }

    override public func withParamsVoidAsyncThrowing(int: Int, label labelString: String, _ string: String) async throws {
        guard !autoForwardingEnabled else {
            return try await super.withParamsVoidAsyncThrowing(int: int, label: labelString, string)
        }
        let perform = _perform(
            Methods.withParamsVoidAsyncThrowing_asyncint_int_Int_label_labelString_String__string_String_ret_Void,
            [int, labelString, string]
        ) as! (_ forwardToOriginal: (_ int: Int, _ labelString: String, _ string: String) async throws -> Void, _ int: Int, _ labelString: String, _ string: String) async throws -> Void
        return try await perform(super.withParamsVoidAsyncThrowing(int:label:_:), int, labelString, string)
    }

    override public func withParamsResult(int: Int, label labelString: String, _ string: String) -> Int {
        guard !autoForwardingEnabled else {
            return super.withParamsResult(int: int, label: labelString, string)
        }
        let perform = _perform(
            Methods.withParamsResult_syncint_int_Int_label_labelString_String__string_String_ret_Int,
            [int, labelString, string]
        ) as! (_ forwardToOriginal: (_ int: Int, _ labelString: String, _ string: String) -> Int, _ int: Int, _ labelString: String, _ string: String) -> Int
        return perform(super.withParamsResult(int:label:_:), int, labelString, string)
    }

    override public func withParamsResultAsync(int: Int, label labelString: String, _ string: String) async -> Int {
        guard !autoForwardingEnabled else {
            return await super.withParamsResultAsync(int: int, label: labelString, string)
        }
        let perform = _perform(
            Methods.withParamsResultAsync_asyncint_int_Int_label_labelString_String__string_String_ret_Int,
            [int, labelString, string]
        ) as! (_ forwardToOriginal: (_ int: Int, _ labelString: String, _ string: String) async -> Int, _ int: Int, _ labelString: String, _ string: String) async -> Int
        return await perform(super.withParamsResultAsync(int:label:_:), int, labelString, string)
    }

    override public func withParamsAsyncThrowingResult(int: Int, label labelString: String, _ string: String) async throws -> Int {
        guard !autoForwardingEnabled else {
            return try await super.withParamsAsyncThrowingResult(int: int, label: labelString, string)
        }
        let perform = _perform(
            Methods.withParamsAsyncThrowingResult_asyncint_int_Int_label_labelString_String__string_String_ret_Int,
            [int, labelString, string]
        ) as! (_ forwardToOriginal: (_ int: Int, _ labelString: String, _ string: String) async throws -> Int, _ int: Int, _ labelString: String, _ string: String) async throws -> Int
        return try await perform(super.withParamsAsyncThrowingResult(int:label:_:), int, labelString, string)
    }

    override public func openMethod() {
        guard !autoForwardingEnabled else {
            return super.openMethod()
        }
        let perform = _perform(Methods.openMethod_sync_ret_Void) as! (_ forwardToOriginal: () -> Void) -> Void
        return perform(super.openMethod)
    }

    override public func superNoParamsVoid() {
        guard !autoForwardingEnabled else {
            return super.superNoParamsVoid()
        }
        let perform = _perform(Methods.superNoParamsVoid_sync_ret_Void) as! (_ forwardToOriginal: () -> Void) -> Void
        return perform(super.superNoParamsVoid)
    }

    override public var readwriteProperty: Int {
        get {
            guard !autoForwardingEnabled else {
                return super.readwriteProperty
            }
            let perform = _perform(Methods.readwriteProperty_sync_ret_Int) as! (_ forwardToOriginal: () -> Int) -> Int
            return perform { super.readwriteProperty }
        }
        set {
            guard !autoForwardingEnabled else {
                super.readwriteProperty = newValue
                return
            }
            let perform = _perform(
                Methods.set_readwriteProperty_sync_ret_Int,
                [newValue]
            ) as! (_ forwardToOriginal: (_ newValue: Int) -> Void, _ newValue: Int) -> Void
            return perform({ super.readwriteProperty = $0 }, newValue)
        }
    }

    override public var privateSettableProperty: Int {
        guard !autoForwardingEnabled else {
            return super.privateSettableProperty
        }
        let perform = _perform(Methods.privateSettableProperty_sync_ret_Int) as! (_ forwardToOriginal: () -> Int) -> Int
        return perform { super.privateSettableProperty }
    }

    override public var sideEffectProperty: Int {
        get {
            guard !autoForwardingEnabled else {
                return super.sideEffectProperty
            }
            let perform = _perform(Methods.sideEffectProperty_sync_ret_Int) as! (_ forwardToOriginal: () -> Int) -> Int
            return perform { super.sideEffectProperty }
        }
        set {
            guard !autoForwardingEnabled else {
                super.sideEffectProperty = newValue
                return
            }
            let perform = _perform(
                Methods.set_sideEffectProperty_sync_ret_Int,
                [newValue]
            ) as! (_ forwardToOriginal: (_ newValue: Int) -> Void, _ newValue: Int) -> Void
            return perform({ super.sideEffectProperty = $0 }, newValue)
        }
    }

    public func expect(
        _ expectation: MethodExpectation<() -> Void>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ forwardToOriginal: () -> Void) -> Void = { _forwardToSuper in
            _forwardToSuper()
        }
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    public func expect(
        _ expectation: MethodExpectation<() async -> Void>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ forwardToOriginal: () async -> Void) async -> Void = { _forwardToSuper in
            await _forwardToSuper()
        }
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    public func expect(
        _ expectation: MethodExpectation<() async throws -> Void>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ forwardToOriginal: () async throws -> Void) async throws -> Void = { _forwardToSuper in
            try await _forwardToSuper()
        }
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    public func expect(
        _ expectation: MethodExpectation<() -> Int>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ forwardToOriginal: () -> Int) -> Int = { _forwardToSuper in
            _forwardToSuper()
        }
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    public func expect(
        _ expectation: MethodExpectation<() async -> Int>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ forwardToOriginal: () async -> Int) async -> Int = { _forwardToSuper in
            await _forwardToSuper()
        }
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    public func expect(
        _ expectation: MethodExpectation<() async throws -> Int>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ forwardToOriginal: () async throws -> Int) async throws -> Int = { _forwardToSuper in
            try await _forwardToSuper()
        }
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    public func expect(
        _ expectation: MethodExpectation<(_ int: Int, _ labelString: String, _ string: String) -> Void>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ forwardToOriginal: (_ int: Int, _ labelString: String, _ string: String) -> Void, _ int: Int, _ labelString: String, _ string: String) -> Void = { _forwardToSuper, int, labelString, string in
            _forwardToSuper(int, labelString, string)
        }
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    public func expect(
        _ expectation: MethodExpectation<(_ int: Int, _ labelString: String, _ string: String) async -> Void>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ forwardToOriginal: (_ int: Int, _ labelString: String, _ string: String) async -> Void, _ int: Int, _ labelString: String, _ string: String) async -> Void = { _forwardToSuper, int, labelString, string in
            await _forwardToSuper(int, labelString, string)
        }
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    public func expect(
        _ expectation: MethodExpectation<(_ int: Int, _ labelString: String, _ string: String) async throws -> Void>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ forwardToOriginal: (_ int: Int, _ labelString: String, _ string: String) async throws -> Void, _ int: Int, _ labelString: String, _ string: String) async throws -> Void = { _forwardToSuper, int, labelString, string in
            try await _forwardToSuper(int, labelString, string)
        }
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    public func expect(
        _ expectation: MethodExpectation<(_ int: Int, _ labelString: String, _ string: String) -> Int>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ forwardToOriginal: (_ int: Int, _ labelString: String, _ string: String) -> Int, _ int: Int, _ labelString: String, _ string: String) -> Int = { _forwardToSuper, int, labelString, string in
            _forwardToSuper(int, labelString, string)
        }
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    public func expect(
        _ expectation: MethodExpectation<(_ int: Int, _ labelString: String, _ string: String) async -> Int>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ forwardToOriginal: (_ int: Int, _ labelString: String, _ string: String) async -> Int, _ int: Int, _ labelString: String, _ string: String) async -> Int = { _forwardToSuper, int, labelString, string in
            await _forwardToSuper(int, labelString, string)
        }
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    public func expect(
        _ expectation: MethodExpectation<(_ int: Int, _ labelString: String, _ string: String) async throws -> Int>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ forwardToOriginal: (_ int: Int, _ labelString: String, _ string: String) async throws -> Int, _ int: Int, _ labelString: String, _ string: String) async throws -> Int = { _forwardToSuper, int, labelString, string in
            try await _forwardToSuper(int, labelString, string)
        }
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    public func expect(
        _ expectation: PropertyExpectation<() -> Int>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ forwardToOriginal: () -> Int) -> Int = { $0() }
    ) {
        _record(
            expectation.getterExpectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    public func expect(
        set expectation: PropertyExpectation<(_ newValue: Int) -> Void>,
        to newValue: Parameter<Int>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ forwardToOriginal: (_ newValue: Int) -> Void, _ newValue: Int) -> Void = { $0($1) }
    ) {
        _record(
            expectation.setterExpectation(newValue.anyParameter),
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }
}

public extension TestMockableClassMock.PropertyExpectation where Signature == () -> Int {
    static var readwriteProperty: Self {
        .init(method: TestMockableClassMock.Methods.readwriteProperty_sync_ret_Int)
    }
}

public extension TestMockableClassMock.PropertyExpectation where Signature == (_ newValue: Int) -> Void {
    static var readwriteProperty: Self {
        .init(method: TestMockableClassMock.Methods.set_readwriteProperty_sync_ret_Int)
    }
}

public extension TestMockableClassMock.PropertyExpectation where Signature == () -> Int {
    static var privateSettableProperty: Self {
        .init(method: TestMockableClassMock.Methods.privateSettableProperty_sync_ret_Int)
    }
}

public extension TestMockableClassMock.PropertyExpectation where Signature == () -> Int {
    static var sideEffectProperty: Self {
        .init(method: TestMockableClassMock.Methods.sideEffectProperty_sync_ret_Int)
    }
}

public extension TestMockableClassMock.PropertyExpectation where Signature == (_ newValue: Int) -> Void {
    static var sideEffectProperty: Self {
        .init(method: TestMockableClassMock.Methods.set_sideEffectProperty_sync_ret_Int)
    }
}
