import Foundation
import SyntaxParser

struct MockTemplate {
    let types: [Syntax.TypeInfo]
    let imports: [String]
    let testableImports: [String]

    func renderImports() -> [String] {
        let regularImports = Set(["XCTest", "UltiMock"] + imports).subtracting(testableImports).sorted()
        let testables = Set(testableImports).sorted()

        return regularImports.map { "import \($0)" } +
            testables.map { "@testable import \($0)" }
    }

    @StringBuilder
    func render() -> String {
        let objcClassNames = objectiveCClassNames()
        renderImports()
        "\n// Generated by UltiMock. DO NOT EDIT!"

        let mockedTypes = types.filter { $0.annotations["AutoMockable"] != nil && !$0.isExtension }
            .map {
                MockedTypeInfo($0)
            }

        for type in mockedTypes {
            type.definition(objcClassNames: objcClassNames)
        }
    }
}

extension MockTemplate {
    private func objectiveCClassNames() -> Set<String> {
        var cache: [String: Bool] = [:]
        var names: Set<String> = []
        let lookup = Dictionary(uniqueKeysWithValues: types.map { ($0.name, $0) })

        for type in types where type.kind == .class {
            var visited: Set<String> = []
            if inheritsFromNSObject(type.name, lookup: lookup, cache: &cache, visited: &visited) {
                names.insert(type.name)
            }
        }

        return names
    }

    private func inheritsFromNSObject(
        _ typeName: String,
        lookup: [String: Syntax.TypeInfo],
        cache: inout [String: Bool],
        visited: inout Set<String>
    ) -> Bool {
        if let cached = cache[typeName] {
            return cached
        }

        if isNSObjectTypeName(typeName) {
            cache[typeName] = true
            return true
        }

        guard let type = lookup[typeName], type.kind == .class else {
            cache[typeName] = false
            return false
        }

        if visited.contains(typeName) {
            cache[typeName] = false
            return false
        }

        visited.insert(typeName)
        var inherits = false
        for inherited in type.inheritedTypes {
            if inheritsFromNSObject(inherited, lookup: lookup, cache: &cache, visited: &visited) {
                inherits = true
                break
            }
        }
        visited.remove(typeName)

        cache[typeName] = inherits
        return inherits
    }

    private func isNSObjectTypeName(_ name: String) -> Bool {
        name == "NSObject" || name.hasSuffix(".NSObject")
    }
}
