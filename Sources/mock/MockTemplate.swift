import Foundation
import SyntaxParser

struct MockTemplate {
    let types: [Syntax.TypeInfo]
    let imports: [String]
    let testableImports: [String]

    func renderImports() -> [String] {
        let regularImports = Set(["XCTest", "UltiMock"] + imports).subtracting(testableImports).sorted()
        let testables = Set(testableImports).sorted()

        return regularImports.map { "import \($0)" } +
            testables.map { "@testable import \($0)" }
    }

    @StringBuilder
    func render() -> String {
        let objcClassNames = objectiveCClassNames()
        renderImports()
        "\n// Generated by UltiMock. DO NOT EDIT!"
        for type in types.filter({ $0.annotations["AutoMockable"] != nil && !$0.isExtension }) {
            ""
            let typeAliases: [String: String] = type.annotations["typealias", default: []]
                .reduce(into: [:]) { partialResult, statement in
                    let parts = statement.split(separator: "=", maxSplits: 1).map { String($0).trimmed }
                    guard
                        let rawKey = parts.first?.unquoted,
                        let rawValue = parts.last?.unquoted,
                        !rawKey.isEmpty,
                        !rawValue.isEmpty
                    else {
                        return
                    }

                    partialResult[rawKey] = rawValue
                }
            let skipped = Set(type.annotations["skip", default: []])
            let methods = type.allMethods.filter {
                !$0.isStatic
                    && !$0.isClass
                    && !$0.definedInExtension
                    && !$0.isPrivate
                    && !skipped.contains($0.unbacktickedCallName)
                    && $0.callName != "deinit"
            }
            let properties = type.allVariables.filter { !$0.isStatic && !$0.definedInExtension && !skipped.contains($0.unbacktickedName) }
            let subscripts = type.allSubscripts.unique(by: \.getterSignature) { old, new in old.isReadOnly ? new : old }

            let mockAccessLevel = type.mockAccessLevel
            let mockTypeName = "\(type.name)Mock"

            let namespacedTypes: [String: String] = (type.kind == .protocol) ? type.associatedTypes
                .reduce(into: [:]) { partialResult, associatedType in
                    partialResult[associatedType.name] = "\(mockTypeName).\(associatedType.name)"
                } : [:]

            if type.kind == .protocol {
                let refinedAssociatedTypes = type.refinedAssociatedTypes

                let associatedTypes = type.associatedTypes
                    .filter {
                        typeAliases.values.contains($0.name)
                            || refinedAssociatedTypes[$0.name] == nil
                            && typeAliases[$0.name] == nil
                    }
                    .sorted(by: \.name, <)

                let sendable = type.based["Sendable"].map { ", @unchecked \($0)" } ?? ""

                """
                \(type.mockClassAccessLevel) class \(mockTypeName)\(type.genericParameters(associatedTypes)): \(type.name)\(sendable), Mock {
                """
                for associatedType in associatedTypes {
                    "    \(mockAccessLevel) typealias \(associatedType.name) = \(associatedType.name)"
                }
                for (left, right) in refinedAssociatedTypes.merging(typeAliases, uniquingKeysWith: { _, new in new }) {
                    "    \(mockAccessLevel) typealias \(left) = \(right)"
                }
            } else {
                """
                \(type.mockClassAccessLevel) class \(mockTypeName): \(type.name), Mock {
                """
            }
            """

                enum Methods {
            """

            methods.map(\.definition).indented(2)
            properties.flatMap(\.definitions).indented(2)
            subscripts.unique(by: \.getterSignature) { old, new in old.isReadOnly ? new : old }
                .flatMap(\.definitions)
                .indented(2)

            let mocksClass = type.kind == .class

            """
                }

                \(mockAccessLevel) struct MethodExpectation<Signature> {
                    \(mockAccessLevel) let expectation: Recorder.Expectation

                    init(method: MockMethod, parameters: [AnyParameter]) {
                        self.expectation = .init(
                            method: method,
                            parameters: parameters
                        )
                    }
            """

            methods.map {
                "\n" + $0.expectationConstructor(mockTypeName, forwarding: mocksClass)
                    .indented(2)
            }

            """
                }
            """

            if !properties.isEmpty {
                """

                    \(mockAccessLevel) struct PropertyExpectation<Signature> {
                        private let method: MockMethod

                        init(method: MockMethod) {
                            self.method = method
                        }

                        \(mockAccessLevel) var getterExpectation: Recorder.Expectation {
                            .init(
                                method: method,
                                parameters: []
                            )
                        }

                        \(mockAccessLevel) func setterExpectation(_ newValue: AnyParameter) -> Recorder.Expectation {
                            .init(
                                method: method,
                                parameters: [newValue]
                            )
                        }
                    }
                """
                propertyExpectationExpectMethods(
                    mockAccessLevel: mockAccessLevel,
                    supportsForwarding: mocksClass,
                    hasWritableProperties: properties.contains { !$0.isReadOnly }
                )
            }

            if !subscripts.isEmpty {
                """

                    \(mockAccessLevel) struct SubscriptExpectation<Signature> {
                        private let method: MockMethod
                        private let parameters: [AnyParameter]

                        init(method: MockMethod, parameters: [AnyParameter]) {
                            self.method = method
                            self.parameters = parameters
                        }

                        \(mockAccessLevel) var getterExpectation: Recorder.Expectation {
                            .init(
                                method: method,
                                parameters: parameters
                            )
                        }

                        \(mockAccessLevel) func setterExpectation(_ newValue: AnyParameter) -> Recorder.Expectation {
                            .init(
                                method: method,
                                parameters: parameters + [newValue]
                            )
                        }

                        \(mockAccessLevel) static var `subscript`: \(mockTypeName).SubscriptExpectations { .init() }
                    }

                    \(mockAccessLevel) struct SubscriptExpectations {
                """
                subscripts.map {
                    "\n" + $0.expectationConstructor(mockTypeName)
                        .indented(2)
                }
                """
                    }
                """
            }

            """

                public let recorder = Recorder()

                private let fileID: String
                private let filePath: StaticString
                private let line: UInt
                private let column: Int

            """

            if type.kind == .protocol {
                """
                    public init(
                        fileID: String = #fileID,
                        filePath: StaticString = #filePath,
                        line: UInt = #line,
                        column: Int = #column
                    ) {
                        self.fileID = fileID
                        self.filePath = filePath
                        self.line = line
                        self.column = column
                    }
                """
            }

            let requiredInitializers = type.implements.values
                .flatMap(\.methods)
                .filter(\.isInitializer)
                + type.allMethods
                .filter(\.isInitializer)
                .filter(\.isRequired)

            for method in requiredInitializers {
                """

                    @available(*, unavailable)
                    \(mockAccessLevel) \("required") \(method.name) {
                        fatalError()
                    }
                """
            }

            let initializers = type.allMethods.filter(\.isInitializer).unique(by: \.name)
            for method in initializers {
                """

                    public \(method.name.dropLast())\(method.parameters.isEmpty ? "" : ", ")
                        fileID: String = #fileID,
                        filePath: StaticString = #filePath,
                        line: UInt = #line,
                        column: Int = #column
                    ) {
                        self.fileID = fileID
                        self.filePath = filePath
                        self.line = line
                        self.column = column
                        self.autoForwardingEnabled = true
                        super.init(\(method.forwardedLabeledParameters))
                        self.autoForwardingEnabled = false
                    }
                """
            }

            // Defining default initializer
            if initializers.isEmpty, type.kind == .class {
                """

                    \(type.mockAccessLevel) init(
                        fileID: String = #fileID,
                        filePath: StaticString = #filePath,
                        line: UInt = #line,
                        column: Int = #column
                    ) {
                        self.fileID = fileID
                        self.filePath = filePath
                        self.line = line
                        self.column = column
                        self.autoForwardingEnabled = true
                        super.init()
                        self.autoForwardingEnabled = false
                    }
                """
            }

            if mocksClass {
                """

                    public var autoForwardingEnabled: Bool

                    public var isEnabled: Bool {
                        !autoForwardingEnabled
                    }
                """
            }

            """

                private func _record<P>(
                    _ expectation: Recorder.Expectation, 
                    _ fileID: String,
                    _ filePath: StaticString,
                    _ line: UInt,
                    _ column: Int,
                    _ perform: P
                ) {
                    guard isEnabled else {
                        handleFatalFailure(
                            "Setting expectation on disabled mock is not allowed",
                            fileID: fileID,
                            filePath: filePath,
                            line: line,
                            column: column
                        )            
                    }
                    recorder.record(
                        .init(
                            expectation, 
                            perform,
                            fileID,
                            filePath, 
                            line,
                            column
                        )
                    )
                }

                private func _perform(_ method: MockMethod, _ parameters: [Any?] = []) -> Any {
                    let invocation = Invocation(
                        method: method,
                        parameters: parameters
                    )
                    guard let stub = recorder.next() else {
                        handleFatalFailure(
                            "Expected no calls but received `\\(invocation)`", 
                            fileID: fileID,
                            filePath: filePath,
                            line: line,
                            column: column
                        )
                    }

                    guard stub.matches(invocation) else {
                        handleFatalFailure(
                            "Unexpected call: expected `\\(stub.expectation)`, but received `\\(invocation)`",
                            fileID: stub.fileID,
                            filePath: stub.filePath,
                            line: stub.line,
                            column: stub.column
                        )
                    }

                    defer { recorder.checkVerification() }
                    return stub.perform
                }
            """

            let isObjc = objcClassNames.contains(type.name)

            methods
                .filter { method in
                    !isObjc || !method.isAsync
                }
                .map {
                    "\n" + $0.implementation(mockTypeName, override: mocksClass)
                        .indented(1)
                }

            properties.map {
                "\n" + $0.implementation(override: mocksClass)
                    .indented(1)
            }

            subscripts.map {
                "\n" + $0.implementation
                    .indented(1)
            }

            methods.unique(by: \.rawSignature)
                .map { "\n" + $0.mockExpect(mockTypeName, forwarding: mocksClass) }

            subscripts.unique(by: \.getterSignature)
                .map { "\n" + $0.mockExpectGetter }

            subscripts.unique(by: \.setterSignature)
                .map { "\n" + $0.mockExpectSetter }
            """
            }
            """
            properties.flatMap {
                $0.expectationExtensions(type.mockClassAccessLevel, mockTypeName, namespacedTypes, forwarding: mocksClass)
            }
            .map { "\n" + $0 }
        }
    }
}

extension MockTemplate {
    @StringBuilder
    private func propertyExpectationExpectMethods(
        mockAccessLevel: String,
        supportsForwarding: Bool,
        hasWritableProperties: Bool
    ) -> String {
        let getterVariants: [PropertyGetterVariant] = [
            .init(isAsync: false, isThrowing: false),
            .init(isAsync: false, isThrowing: true),
            .init(isAsync: true, isThrowing: false),
            .init(isAsync: true, isThrowing: true)
        ]

        getterVariants.map { variant in
            propertyGetterExpectFunction(
                accessLevel: mockAccessLevel,
                supportsForwarding: supportsForwarding,
                variant: variant
            )
        }

        if hasWritableProperties {
            propertySetterExpectFunction(
                accessLevel: mockAccessLevel,
                supportsForwarding: supportsForwarding
            )
        }
    }

    private func propertyGetterExpectFunction(
        accessLevel: String,
        supportsForwarding: Bool,
        variant: PropertyGetterVariant
    ) -> String {
        let signature = "()\(variant.specifierClause) -> Return"
        let performType: String
        let defaultClause: String
        if supportsForwarding {
            performType = "(_ forwardToOriginal: \(signature))\(variant.specifierClause) -> Return"
            defaultClause = " = { \(variant.defaultForwardInvocation) }"
        } else {
            performType = signature
            defaultClause = ""
        }

        return """
            \(accessLevel) func expect<Return>(
                _ expectation: PropertyExpectation<\(signature)>,
                fileID: String = #fileID,
                filePath: StaticString = #filePath,
                line: UInt = #line,
                column: Int = #column,
                perform: @escaping \(performType)\(defaultClause)
            ) {
                _record(
                    expectation.getterExpectation,
                    fileID,
                    filePath, 
                    line,
                    column,
                    perform
                )
            }
        """
    }

    private func propertySetterExpectFunction(
        accessLevel: String,
        supportsForwarding: Bool
    ) -> String {
        let signature = "(_ newValue: Value) -> Void"
        let performType: String
        let defaultClause: String
        if supportsForwarding {
            performType = "(_ forwardToOriginal: \(signature), _ newValue: Value) -> Void"
            defaultClause = " = { $0($1) }"
        } else {
            performType = signature
            defaultClause = " = { _ in }"
        }

        return """
            \(accessLevel) func expect<Value>(
                set expectation: PropertyExpectation<\(signature)>,
                to newValue: Parameter<Value>,
                fileID: String = #fileID,
                filePath: StaticString = #filePath,
                line: UInt = #line,
                column: Int = #column,
                perform: @escaping \(performType)\(defaultClause)
            ) {
                _record(
                    expectation.setterExpectation(newValue.anyParameter),
                    fileID,
                    filePath, 
                    line,
                    column,
                    perform
                )
            }
        """
    }
}

private struct PropertyGetterVariant {
    let isAsync: Bool
    let isThrowing: Bool

    var specifierClause: String {
        switch (isAsync, isThrowing) {
        case (false, false):
            ""
        case (false, true):
            " throws"
        case (true, false):
            " async"
        case (true, true):
            " async throws"
        }
    }

    var defaultForwardInvocation: String {
        switch (isAsync, isThrowing) {
        case (false, false):
            "$0()"
        case (false, true):
            "try $0()"
        case (true, false):
            "await $0()"
        case (true, true):
            "try await $0()"
        }
    }
}

extension MockTemplate {
    private func objectiveCClassNames() -> Set<String> {
        var cache: [String: Bool] = [:]
        var names: Set<String> = []
        let lookup = Dictionary(uniqueKeysWithValues: types.map { ($0.name, $0) })

        for type in types where type.kind == .class {
            var visited: Set<String> = []
            if inheritsFromNSObject(type.name, lookup: lookup, cache: &cache, visited: &visited) {
                names.insert(type.name)
            }
        }

        return names
    }

    private func inheritsFromNSObject(
        _ typeName: String,
        lookup: [String: Syntax.TypeInfo],
        cache: inout [String: Bool],
        visited: inout Set<String>
    ) -> Bool {
        if let cached = cache[typeName] {
            return cached
        }

        if isNSObjectTypeName(typeName) {
            cache[typeName] = true
            return true
        }

        guard let type = lookup[typeName], type.kind == .class else {
            cache[typeName] = false
            return false
        }

        if visited.contains(typeName) {
            cache[typeName] = false
            return false
        }

        visited.insert(typeName)
        var inherits = false
        for inherited in type.inheritedTypes {
            if inheritsFromNSObject(inherited, lookup: lookup, cache: &cache, visited: &visited) {
                inherits = true
                break
            }
        }
        visited.remove(typeName)

        cache[typeName] = inherits
        return inherits
    }

    private func isNSObjectTypeName(_ name: String) -> Bool {
        name == "NSObject" || name.hasSuffix(".NSObject")
    }
}
