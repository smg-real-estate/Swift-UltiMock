import Foundation
import SourceryRuntime

struct MockTemplate {
    let types: Types
    let type: [String: Type]
    let functions: [SourceryMethod]
    let imports: [String]
    let testableImports: [String]

    @StringBuilder
    func render() -> String {
        Set(["XCTest", "UltiMock"] + imports)
            .subtracting(testableImports)
            .sorted()
            .map {
                "import \($0)"
            }

        Set(testableImports)
            .sorted()
            .map {
                "@testable import \($0)"
            }

        "\n// Generated by UltiMock. DO NOT EDIT!"
        for type in types.types.filter({ $0.annotations["AutoMockable"] != nil && !$0.isExtension }) {
            ""
            let typeAliases: [String: String] = type.annotations.array(of: String.self, for: "typealias")
                .reduce(into: [:]) { partialResult, statement in
                    let parts = statement.split(separator: "=", maxSplits: 1).map(\.trimmed)
                    if !parts.isEmpty {
                        partialResult[parts[0]] = parts.last
                    }
                }
            let skipped = type.annotations.array(of: String.self, for: "skip")
            let methods = type.allMethods.filter {
                !$0.isStatic
                    && !$0.isClass
                    && !$0.definedInExtension
                    && !$0.isPrivate
                    && !skipped.contains($0.unbacktickedCallName)
            }
            let properties = type.allVariables.filter { !$0.isStatic && !$0.definedInExtension && !skipped.contains($0.unbacktickedName) }
            let subscripts = type.allSubscripts.unique(by: \.getterSignature) { old, new in old.isReadOnly ? new : old }

            let mockAccessLevel = type.mockAccessLevel
            let mockTypeName = "\(type.name)Mock"

            let namespacedTypes: [String: String] = (type as? SourceryRuntime.`Protocol`)?.associatedTypes
                .values
                .reduce(into: [:]) { partialResult, type in
                    partialResult[type.name] = "\(mockTypeName).\(type.name)"
                } ?? [:]

            if let type = type as? SourceryRuntime.`Protocol` {
                let refinedAssociatedTypes = type.refinedAssociatedTypes
                let associatedTypes = type.associatedTypes
                    .values
                    .filter {
                        typeAliases.values.contains($0.name)
                            || refinedAssociatedTypes[$0.name] == nil
                            && typeAliases[$0.name] == nil
                    }
                    .sorted(by: \.name, <)

                let sendable = type.based["Sendable"].map { ", @unchecked \($0)" } ?? ""

                """
                \(type.mockClassAccessLevel) class \(mockTypeName)\(type.genericParameters(associatedTypes)): \(type.name)\(sendable), Mock {
                """
                for associatedType in associatedTypes {
                    "    \(mockAccessLevel) typealias \(associatedType.name) = \(associatedType.name)"
                }
                for (left, right) in refinedAssociatedTypes.merging(typeAliases, uniquingKeysWith: { _, new in new }) {
                    "    \(mockAccessLevel) typealias \(left) = \(right)"
                }
            } else {
                """
                \(type.mockClassAccessLevel) class \(mockTypeName): \(type.name), Mock {
                """
            }
            """

                enum Methods {
            """

            methods.map(\.definition).indented(2)
            properties.flatMap(\.definitions).indented(2)
            subscripts.unique(by: \.getterSignature) { old, new in old.isReadOnly ? new : old }
                .flatMap(\.definitions)
                .indented(2)

            let mocksClass = type is SourceryRuntime.Class

            """
                }

                \(mockAccessLevel) struct MethodExpectation<Signature> {
                    \(mockAccessLevel) let expectation: Recorder.Expectation

                    init(method: MockMethod, parameters: [AnyParameter]) {
                        self.expectation = .init(
                            method: method,
                            parameters: parameters
                        )
                    }
            """

            methods.map {
                "\n" + $0.expectationConstructor(mockTypeName, forwarding: mocksClass)
                    .indented(2)
            }

            """
                }
            """

            if !properties.isEmpty {
                """

                    \(mockAccessLevel) struct PropertyExpectation<Signature> {
                        private let method: MockMethod

                        init(method: MockMethod) {
                            self.method = method
                        }

                        \(mockAccessLevel) var getterExpectation: Recorder.Expectation {
                            .init(
                                method: method,
                                parameters: []
                            )
                        }

                        \(mockAccessLevel) func setterExpectation(_ newValue: AnyParameter) -> Recorder.Expectation {
                            .init(
                                method: method,
                                parameters: [newValue]
                            )
                        }
                    }
                """
            }

            if !subscripts.isEmpty {
                """

                    \(mockAccessLevel) struct SubscriptExpectation<Signature> {
                        private let method: MockMethod
                        private let parameters: [AnyParameter]

                        init(method: MockMethod, parameters: [AnyParameter]) {
                            self.method = method
                            self.parameters = parameters
                        }

                        \(mockAccessLevel) var getterExpectation: Recorder.Expectation {
                            .init(
                                method: method,
                                parameters: parameters
                            )
                        }

                        \(mockAccessLevel) func setterExpectation(_ newValue: AnyParameter) -> Recorder.Expectation {
                            .init(
                                method: method,
                                parameters: parameters + [newValue]
                            )
                        }

                        \(mockAccessLevel) static var `subscript`: \(mockTypeName).SubscriptExpectations { .init() }
                    }

                    \(mockAccessLevel) struct SubscriptExpectations {
                """
                subscripts.map {
                    "\n" + $0.expectationConstructor(mockTypeName)
                        .indented(2)
                }
                """
                    }
                """
            }

            """

                public let recorder = Recorder()

                private let fileID: String
                private let filePath: StaticString
                private let line: UInt
                private let column: Int

            """

            if type is SourceryRuntime.`Protocol` {
                """
                    public init(
                        fileID: String = #fileID,
                        filePath: StaticString = #filePath,
                        line: UInt = #line,
                        column: Int = #column
                    ) {
                        self.fileID = fileID
                        self.filePath = filePath
                        self.line = line
                        self.column = column
                    }
                """
            }

            let requiredInitializers = type.implements.values
                .flatMap(\.methods)
                .filter(\.isInitializer)
                + type.allMethods
                .filter(\.isInitializer)
                .filter(\.isRequired)

            for method in requiredInitializers {
                """

                    @available(*, unavailable)
                    \(mockAccessLevel) \("required") \(method.name) {
                        fatalError()
                    }
                """
            }

            let initializers = type.allMethods.filter(\.isInitializer).unique(by: \.name)
            for method in initializers {
                """

                    public \(method.name.dropLast())\(method.parameters.isEmpty ? "" : ", ")
                        fileID: String = #fileID,
                        filePath: StaticString = #filePath,
                        line: UInt = #line,
                        column: Int = #column
                    ) {
                        self.fileID = fileID
                        self.filePath = filePath
                        self.line = line
                        self.column = column
                        self.autoForwardingEnabled = true
                        super.init(\(method.forwardedLabeledParameters))
                        self.autoForwardingEnabled = false
                    }
                """
            }

            // Defining default initializer
            if initializers.isEmpty, type is SourceryRuntime.Class {
                """

                    \(type.mockAccessLevel) init(
                        fileID: String = #fileID,
                        filePath: StaticString = #filePath,
                        line: UInt = #line,
                        column: Int = #column
                    ) {
                        self.fileID = fileID
                        self.filePath = filePath
                        self.line = line
                        self.column = column
                        self.autoForwardingEnabled = true
                        super.init()
                        self.autoForwardingEnabled = false
                    }
                """
            }

            if mocksClass {
                """

                    public var autoForwardingEnabled: Bool

                    public var isEnabled: Bool {
                        !autoForwardingEnabled
                    }
                """
            }

            """

                private func _record<P>(
                    _ expectation: Recorder.Expectation, 
                    _ fileID: String,
                    _ filePath: StaticString,
                    _ line: UInt,
                    _ column: Int,
                    _ perform: P
                ) {
                    guard isEnabled else {
                        handleFatalFailure(
                            "Setting expectation on disabled mock is not allowed",
                            fileID: fileID,
                            filePath: filePath,
                            line: line,
                            column: column
                        )            
                    }
                    recorder.record(
                        .init(
                            expectation, 
                            perform,
                            fileID,
                            filePath, 
                            line,
                            column
                        )
                    )
                }

                private func _perform(_ method: MockMethod, _ parameters: [Any?] = []) -> Any {
                    let invocation = Invocation(
                        method: method,
                        parameters: parameters
                    )
                    guard let stub = recorder.next() else {
                        handleFatalFailure(
                            "Expected no calls but received `\\(invocation)`", 
                            fileID: fileID,
                            filePath: filePath,
                            line: line,
                            column: column
                        )
                    }

                    guard stub.matches(invocation) else {
                        handleFatalFailure(
                            "Unexpected call: expected `\\(stub.expectation)`, but received `\\(invocation)`",
                            fileID: stub.fileID,
                            filePath: stub.filePath,
                            line: stub.line,
                            column: stub.column
                        )
                    }

                    defer { recorder.checkVerification() }
                    return stub.perform
                }
            """

            let isObjc = type.supertype?.name == "NSObject"

            methods
                .filter { method in
                    !isObjc || !method.isAsync
                }
                .map {
                    "\n" + $0.implementation(mockTypeName, override: mocksClass)
                        .indented(1)
                }

            properties.map {
                "\n" + $0.implementation(override: mocksClass)
                    .indented(1)
            }

            subscripts.map {
                "\n" + $0.implementation
                    .indented(1)
            }

            methods.unique(by: \.rawSignature)
                .map { "\n" + $0.mockExpect(mockTypeName, forwarding: mocksClass) }

            properties.unique(by: \.getterSignature)
                .map { "\n" + $0.mockExpectGetter(forwarding: mocksClass) }

            properties.unique(by: \.setterSignature)
                .map { "\n" + $0.mockExpectSetter(forwarding: mocksClass) }

            subscripts.unique(by: \.getterSignature)
                .map { "\n" + $0.mockExpectGetter }

            subscripts.unique(by: \.setterSignature)
                .map { "\n" + $0.mockExpectSetter }
            """
            }
            """
            properties.flatMap {
                $0.expectationExtensions(type.mockClassAccessLevel, mockTypeName, namespacedTypes, forwarding: mocksClass)
            }
            .map { "\n" + $0 }
        }
    }
}

extension Dictionary {
    func array<T>(of type: T.Type = T.self, for key: Key) -> [T] {
        if let array = self[key] as? [T] {
            return array
        }
        if let singleValue = self[key] as? T {
            return [singleValue]
        }
        return []
    }
}
