import CoreLocation
import TestPackage
import UltiMock
import XCTest

// Generated by UltiMock. DO NOT EDIT!

open class TestMockableMock: TestMockable, @unchecked Sendable, Mock {

    enum Methods {
        static var forceUnwrappedResult_sync_ret_String_impopt_: MockMethod {
            .init { _ in
                "forceUnwrappedResult()"
            }
        }
        static var newAPI_sync_ret_Void: MockMethod {
            .init { _ in
                "newAPI()"
            }
        }
        static var noParamsVoid_sync_ret_Void: MockMethod {
            .init { _ in
                "noParamsVoid()"
            }
        }
        static var noParamsVoidAsync_sync_ret_Void: MockMethod {
            .init { _ in
                "noParamsVoidAsync()"
            }
        }
        static var noParamsVoidAsyncThrowing_sync_ret_Void: MockMethod {
            .init { _ in
                "noParamsVoidAsyncThrowing()"
            }
        }
        static var noParamsResult_sync_ret_Swift_Int: MockMethod {
            .init { _ in
                "noParamsResult()"
            }
        }
        static var noParamsResult_sync_ret_Int_opt_: MockMethod {
            .init { _ in
                "noParamsResult()"
            }
        }
        static var noParamsImplicitOptionalResult_sync_ret_Int_impopt_: MockMethod {
            .init { _ in
                "noParamsImplicitOptionalResult()"
            }
        }
        static var noParamsArrayResult_sync_ret__lsb_Int_rsb_: MockMethod {
            .init { _ in
                "noParamsArrayResult()"
            }
        }
        static var noParamsDictionaryResult_sync_ret__lsb_String_col_Int_rsb_: MockMethod {
            .init { _ in
                "noParamsDictionaryResult()"
            }
        }
        static var noParamsClosureResult_sync_ret__lp_Int_rp__ret_Void: MockMethod {
            .init { _ in
                "noParamsClosureResult()"
            }
        }
        static var noParamsResultAsync_sync_ret_Int: MockMethod {
            .init { _ in
                "noParamsResultAsync()"
            }
        }
        static var noParamsAsyncThrowingResult_sync_ret_Int: MockMethod {
            .init { _ in
                "noParamsAsyncThrowingResult()"
            }
        }
        static var func_sync_ret_Void: MockMethod {
            .init { _ in
                "`func`()"
            }
        }
        static var withSelf_sync__self_Self_ret_Self: MockMethod {
            .init {
                "withSelf(_: \($0[0] ?? "nil"))"
            }
        }
        static var withOptionalClosure_sync__closure__lp__lp_Int_rp__ret_Void_rp__opt__ret_Void: MockMethod {
            .init {
                "withOptionalClosure(_: \($0[0] ?? "nil"))"
            }
        }
        static var withAnnotatedClosure_sync__closure__lp_@MainActor@Sendable_lp_Int_rp__ret_Void_rp__opt__ret_Void: MockMethod {
            .init {
                "withAnnotatedClosure(_: \($0[0] ?? "nil"))"
            }
        }
        static var withParamsVoid_syncint_int_Swift_Int_label_labelString_String___string_String___optional_Int_opt____implicitOptional_Int_impopt____inout_inoutInt___array__lsb_Int_rsb____dictionary__lsb_String_col_Int_rsb____escapingClosure_@escaping_lp_Int_rp__ret_Void_ret_Void: MockMethod {
            .init {
                "withParamsVoid(int: \($0[0] ?? "nil"), label: \"\($0[1]!)\", _: \"\($0[2]!)\", _: \($0[3] ?? "nil"), _: \($0[4] ?? "nil"), _: \($0[5] ?? "nil"), _: \($0[6] ?? "nil"), _: \($0[7] ?? "nil"), _: \($0[8] ?? "nil"))"
            }
        }
        static var withParamsVoidAsync_syncint_int_Int_label_labelString_String___string_String___optional_Int_opt__ret_Void: MockMethod {
            .init {
                "withParamsVoidAsync(int: \($0[0] ?? "nil"), label: \"\($0[1]!)\", _: \"\($0[2]!)\", _: \($0[3] ?? "nil"))"
            }
        }
        static var withParamsVoidAsyncThrowing_syncint_int_Int_label_labelString_String___string_String___optional_Int_opt__ret_Void: MockMethod {
            .init {
                "withParamsVoidAsyncThrowing(int: \($0[0] ?? "nil"), label: \"\($0[1]!)\", _: \"\($0[2]!)\", _: \($0[3] ?? "nil"))"
            }
        }
        static var withParamsResult_syncint_int_Int_label_labelString_String___string_String_ret_Int: MockMethod {
            .init {
                "withParamsResult(int: \($0[0] ?? "nil"), label: \"\($0[1]!)\", _: \"\($0[2]!)\")"
            }
        }
        static var withParamsResult_syncotherInt_otherInt_Int_label_labelString_String___string_String_ret_Int: MockMethod {
            .init {
                "withParamsResult(otherInt: \($0[0] ?? "nil"), label: \"\($0[1]!)\", _: \"\($0[2]!)\")"
            }
        }
        static var withParamsResultAsync_syncint_int_Int_label_labelString_String___string_String_ret_Int: MockMethod {
            .init {
                "withParamsResultAsync(int: \($0[0] ?? "nil"), label: \"\($0[1]!)\", _: \"\($0[2]!)\")"
            }
        }
        static var withParamsAsyncThrowingResult_syncint_int_Int_label_labelString_String___string_String_ret_Int: MockMethod {
            .init {
                "withParamsAsyncThrowingResult(int: \($0[0] ?? "nil"), label: \"\($0[1]!)\", _: \"\($0[2]!)\")"
            }
        }
        static var generic_syncparameter1_parameter1_P1___parameter2_P2_ret_Int: MockMethod {
            .init {
                "generic(parameter1: \($0[0] ?? "nil"), _: \($0[1] ?? "nil"))"
            }
        }
        static var generic_syncsome_some_someTestGenericProtocol_lab_Int_rab__any_any_anyTestGenericProtocol_lab_String_rab__ret_Int: MockMethod {
            .init {
                "generic(some: \($0[0] ?? "nil"), any: \($0[1] ?? "nil"))"
            }
        }
        static var discardableResult_sync_ret_String: MockMethod {
            .init { _ in
                "discardableResult()"
            }
        }
        static var closureAliasResult_sync__closure_@escapingClosureAlias_lab_Int_rab__ret_ClosureAlias_lab_Int_rab_: MockMethod {
            .init {
                "closureAliasResult(_: \($0[0] ?? "nil"))"
            }
        }
        static var closureAliasResultEquivalent_sync__closure_@escaping_lp_Int_rp__ret_Void_ret__lp_Int_rp__ret_Void: MockMethod {
            .init {
                "closureAliasResultEquivalent(_: \($0[0] ?? "nil"))"
            }
        }
        static var property_sync_ret_OnlyProperty: MockMethod {
            .init { _ in
                "property"
            }
        }
        static var set_property_sync_ret_OnlyProperty: MockMethod {
            .init {
                "property = \($0[0] ?? "nil")"
            }
        }
        static var throwingProperty_sync_ret_Int: MockMethod {
            .init { _ in
                "throwingProperty"
            }
        }
        static var set_throwingProperty_sync_ret_Int: MockMethod {
            .init {
                "throwingProperty = \($0[0] ?? "nil")"
            }
        }
        static var asyncProperty_sync_ret_Int: MockMethod {
            .init { _ in
                "asyncProperty"
            }
        }
        static var set_asyncProperty_sync_ret_Int: MockMethod {
            .init {
                "asyncProperty = \($0[0] ?? "nil")"
            }
        }
        static var asyncThrowingProperty_sync_ret_Int: MockMethod {
            .init { _ in
                "asyncThrowingProperty"
            }
        }
        static var set_asyncThrowingProperty_sync_ret_Int: MockMethod {
            .init {
                "asyncThrowingProperty = \($0[0] ?? "nil")"
            }
        }
        static var readwriteProperty_sync_ret_Int: MockMethod {
            .init { _ in
                "readwriteProperty"
            }
        }
        static var set_readwriteProperty_sync_ret_Int: MockMethod {
            .init {
                "readwriteProperty = \($0[0] ?? "nil")"
            }
        }
        static var forceUnwrapped_sync_ret_String_impopt_: MockMethod {
            .init { _ in
                "forceUnwrapped"
            }
        }
        static var set_forceUnwrapped_sync_ret_String_impopt_: MockMethod {
            .init {
                "forceUnwrapped = \($0[0] ?? "nil")"
            }
        }
        static var subscript_get_by_key_key_String_Int: MockMethod {
            .init {
                "[key: \"\($0[0]!)\"]"
            }
        }
        static var subscript_set_by_key_key_String_Int: MockMethod {
            .init {
                "[key: \"\($0[0]!)\"] = \($0.last! ?? "nil")"
            }
        }
        static var subscript_get_by_key_key_Int_String: MockMethod {
            .init {
                "[key: \($0[0] ?? "nil")]"
            }
        }
        static var subscript_set_by_key_key_Int_String: MockMethod {
            .init {
                "[key: \($0[0] ?? "nil")] = \($0.last! ?? "nil")"
            }
        }
    }

    public struct MethodExpectation<Signature> {
        public let expectation: Recorder.Expectation

        init(method: MockMethod, parameters: [AnyParameter]) {
            self.expectation = .init(
                method: method,
                parameters: parameters
            )
        }

        internal static func forceUnwrappedResult() -> Self
        where Signature == () -> String! {
            .init(
                method: Methods.forceUnwrappedResult_sync_ret_String_impopt_,
                parameters: []
            )
        }

        internal static func newAPI() -> Self
        where Signature == () -> Void {
            .init(
                method: Methods.newAPI_sync_ret_Void,
                parameters: []
            )
        }

        internal static func noParamsVoid() -> Self
        where Signature == () -> Void {
            .init(
                method: Methods.noParamsVoid_sync_ret_Void,
                parameters: []
            )
        }

        internal static func noParamsVoidAsync() -> Self
        where Signature == () -> Void {
            .init(
                method: Methods.noParamsVoidAsync_sync_ret_Void,
                parameters: []
            )
        }

        internal static func noParamsVoidAsyncThrowing() -> Self
        where Signature == () -> Void {
            .init(
                method: Methods.noParamsVoidAsyncThrowing_sync_ret_Void,
                parameters: []
            )
        }

        internal static func noParamsResult() -> Self
        where Signature == () -> Swift.Int {
            .init(
                method: Methods.noParamsResult_sync_ret_Swift_Int,
                parameters: []
            )
        }

        internal static func noParamsResult() -> Self
        where Signature == () -> Int? {
            .init(
                method: Methods.noParamsResult_sync_ret_Int_opt_,
                parameters: []
            )
        }

        internal static func noParamsImplicitOptionalResult() -> Self
        where Signature == () -> Int! {
            .init(
                method: Methods.noParamsImplicitOptionalResult_sync_ret_Int_impopt_,
                parameters: []
            )
        }

        internal static func noParamsArrayResult() -> Self
        where Signature == () -> [Int] {
            .init(
                method: Methods.noParamsArrayResult_sync_ret__lsb_Int_rsb_,
                parameters: []
            )
        }

        internal static func noParamsDictionaryResult() -> Self
        where Signature == () -> [String: Int] {
            .init(
                method: Methods.noParamsDictionaryResult_sync_ret__lsb_String_col_Int_rsb_,
                parameters: []
            )
        }

        internal static func noParamsClosureResult() -> Self
        where Signature == () -> (Int) -> Void {
            .init(
                method: Methods.noParamsClosureResult_sync_ret__lp_Int_rp__ret_Void,
                parameters: []
            )
        }

        internal static func noParamsResultAsync() -> Self
        where Signature == () -> Int {
            .init(
                method: Methods.noParamsResultAsync_sync_ret_Int,
                parameters: []
            )
        }

        internal static func noParamsAsyncThrowingResult() -> Self
        where Signature == () -> Int {
            .init(
                method: Methods.noParamsAsyncThrowingResult_sync_ret_Int,
                parameters: []
            )
        }

        internal static func `func`() -> Self
        where Signature == () -> Void {
            .init(
                method: Methods.func_sync_ret_Void,
                parameters: []
            )
        }

        internal static func withSelf(_ self: Parameter<TestMockableMock>) -> Self
        where Signature == (_ self: TestMockableMock) -> TestMockableMock {
            .init(
                method: Methods.withSelf_sync__self_Self_ret_Self,
                parameters: [self.anyParameter]
            )
        }

        internal static func withOptionalClosure(_ closure: Parameter<((Int) -> Void)?>) -> Self
        where Signature == (_ closure: ((Int) -> Void)?) -> Void {
            .init(
                method: Methods.withOptionalClosure_sync__closure__lp__lp_Int_rp__ret_Void_rp__opt__ret_Void,
                parameters: [closure.anyParameter]
            )
        }

        internal static func withAnnotatedClosure(_ closure: Parameter<(@MainActor @Sendable (Int) -> Void)?>) -> Self
        where Signature == (_ closure: (@MainActor @Sendable (Int) -> Void)?) -> Void {
            .init(
                method: Methods.withAnnotatedClosure_sync__closure__lp_@MainActor@Sendable_lp_Int_rp__ret_Void_rp__opt__ret_Void,
                parameters: [closure.anyParameter]
            )
        }

        internal static func withParamsVoid(int: Parameter<Swift.Int>, label labelString: Parameter<String>, _ string: Parameter<String>, _ optional: Parameter<Int?>, _ implicitOptional: Parameter<Int!>, _ `inout`: Parameter<Int>, _ array: Parameter<[Int]>, _ dictionary: Parameter<[String: Int]>, _ escapingClosure: Parameter<@escaping (Int) -> Void>) -> Self
        where Signature == (_ int: Swift.Int, _ labelString: String, _ string: String, _ optional: Int?, _ implicitOptional: Int!, _ `inout`: inout Int, _ array: [Int], _ dictionary: [String: Int], _ escapingClosure: @escaping (Int) -> Void) -> Void {
            .init(
                method: Methods.withParamsVoid_syncint_int_Swift_Int_label_labelString_String___string_String___optional_Int_opt____implicitOptional_Int_impopt____inout_inoutInt___array__lsb_Int_rsb____dictionary__lsb_String_col_Int_rsb____escapingClosure_@escaping_lp_Int_rp__ret_Void_ret_Void,
                parameters: [int.anyParameter, labelString.anyParameter, string.anyParameter, optional.anyParameter, implicitOptional.anyParameter, `inout`.anyParameter, array.anyParameter, dictionary.anyParameter, escapingClosure.anyParameter]
            )
        }

        internal static func withParamsVoidAsync(int: Parameter<Int>, label labelString: Parameter<String>, _ string: Parameter<String>, _ optional: Parameter<Int?>) -> Self
        where Signature == (_ int: Int, _ labelString: String, _ string: String, _ optional: Int?) -> Void {
            .init(
                method: Methods.withParamsVoidAsync_syncint_int_Int_label_labelString_String___string_String___optional_Int_opt__ret_Void,
                parameters: [int.anyParameter, labelString.anyParameter, string.anyParameter, optional.anyParameter]
            )
        }

        internal static func withParamsVoidAsyncThrowing(int: Parameter<Int>, label labelString: Parameter<String>, _ string: Parameter<String>, _ optional: Parameter<Int?>) -> Self
        where Signature == (_ int: Int, _ labelString: String, _ string: String, _ optional: Int?) -> Void {
            .init(
                method: Methods.withParamsVoidAsyncThrowing_syncint_int_Int_label_labelString_String___string_String___optional_Int_opt__ret_Void,
                parameters: [int.anyParameter, labelString.anyParameter, string.anyParameter, optional.anyParameter]
            )
        }

        internal static func withParamsResult(int: Parameter<Int>, label labelString: Parameter<String>, _ string: Parameter<String>) -> Self
        where Signature == (_ int: Int, _ labelString: String, _ string: String) -> Int {
            .init(
                method: Methods.withParamsResult_syncint_int_Int_label_labelString_String___string_String_ret_Int,
                parameters: [int.anyParameter, labelString.anyParameter, string.anyParameter]
            )
        }

        internal static func withParamsResult(otherInt: Parameter<Int>, label labelString: Parameter<String>, _ string: Parameter<String>) -> Self
        where Signature == (_ otherInt: Int, _ labelString: String, _ string: String) -> Int {
            .init(
                method: Methods.withParamsResult_syncotherInt_otherInt_Int_label_labelString_String___string_String_ret_Int,
                parameters: [otherInt.anyParameter, labelString.anyParameter, string.anyParameter]
            )
        }

        internal static func withParamsResultAsync(int: Parameter<Int>, label labelString: Parameter<String>, _ string: Parameter<String>) -> Self
        where Signature == (_ int: Int, _ labelString: String, _ string: String) -> Int {
            .init(
                method: Methods.withParamsResultAsync_syncint_int_Int_label_labelString_String___string_String_ret_Int,
                parameters: [int.anyParameter, labelString.anyParameter, string.anyParameter]
            )
        }

        internal static func withParamsAsyncThrowingResult(int: Parameter<Int>, label labelString: Parameter<String>, _ string: Parameter<String>) -> Self
        where Signature == (_ int: Int, _ labelString: String, _ string: String) -> Int {
            .init(
                method: Methods.withParamsAsyncThrowingResult_syncint_int_Int_label_labelString_String___string_String_ret_Int,
                parameters: [int.anyParameter, labelString.anyParameter, string.anyParameter]
            )
        }

        internal static func generic(parameter1: Parameter<P1>, _ parameter2: Parameter<P2>) -> Self
        where Signature == (_ parameter1: P1, _ parameter2: P2) -> Int {
            .init(
                method: Methods.generic_syncparameter1_parameter1_P1___parameter2_P2_ret_Int,
                parameters: [parameter1.anyParameter, parameter2.anyParameter]
            )
        }

        internal static func generic(some: Parameter<some TestGenericProtocol<Int>>, any: Parameter<any TestGenericProtocol<String>>) -> Self
        where Signature == (_ some: any TestGenericProtocol<Int>, _ any: any TestGenericProtocol<String>) -> Int {
            .init(
                method: Methods.generic_syncsome_some_someTestGenericProtocol_lab_Int_rab__any_any_anyTestGenericProtocol_lab_String_rab__ret_Int,
                parameters: [some.anyParameter, any.anyParameter]
            )
        }

        internal static func discardableResult() -> Self
        where Signature == () -> String {
            .init(
                method: Methods.discardableResult_sync_ret_String,
                parameters: []
            )
        }

        internal static func closureAliasResult(_ closure: Parameter<@escaping ClosureAlias<Int>>) -> Self
        where Signature == (_ closure: @escaping ClosureAlias<Int>) -> ClosureAlias<Int> {
            .init(
                method: Methods.closureAliasResult_sync__closure_@escapingClosureAlias_lab_Int_rab__ret_ClosureAlias_lab_Int_rab_,
                parameters: [closure.anyParameter]
            )
        }

        internal static func closureAliasResultEquivalent(_ closure: Parameter<@escaping (Int) -> Void>) -> Self
        where Signature == (_ closure: @escaping (Int) -> Void) -> (Int) -> Void {
            .init(
                method: Methods.closureAliasResultEquivalent_sync__closure_@escaping_lp_Int_rp__ret_Void_ret__lp_Int_rp__ret_Void,
                parameters: [closure.anyParameter]
            )
        }
    }

    public struct PropertyExpectation<Signature> {
        private let method: MockMethod

        init(method: MockMethod) {
            self.method = method
        }

        public var getterExpectation: Recorder.Expectation {
            .init(
                method: method,
                parameters: []
            )
        }

        public func setterExpectation(_ newValue: AnyParameter) -> Recorder.Expectation {
            .init(
                method: method,
                parameters: [newValue]
            )
        }
    }

    public struct SubscriptExpectation<Signature> {
        private let method: MockMethod
        private let parameters: [AnyParameter]

        init(method: MockMethod, parameters: [AnyParameter]) {
            self.method = method
            self.parameters = parameters
        }

        public var getterExpectation: Recorder.Expectation {
            .init(
                method: method,
                parameters: parameters
            )
        }

        public func setterExpectation(_ newValue: AnyParameter) -> Recorder.Expectation {
            .init(
                method: method,
                parameters: parameters + [newValue]
            )
        }

        public static var `subscript`: TestMockableMock.SubscriptExpectations { .init() }
    }

    public struct SubscriptExpectations {

        internal subscript(key: Parameter<String>) -> TestMockableMock.SubscriptExpectation<(_ key: String) -> Int> {
            .init(
                method: Methods.subscript_get_by_key_key_String_Int,
                parameters: [key.anyParameter]
            )
        }
        
        internal subscript(key: Parameter<String>) -> TestMockableMock.SubscriptExpectation<(String, _ newValue: Int) -> Void> {
            .init(
                method: Methods.subscript_set_by_key_key_String_Int,
                parameters: [key.anyParameter]
            )
        }

        internal subscript(key: Parameter<Int>) -> TestMockableMock.SubscriptExpectation<(_ key: Int) -> String> {
            .init(
                method: Methods.subscript_get_by_key_key_Int_String,
                parameters: [key.anyParameter]
            )
        }
        
        internal subscript(key: Parameter<Int>) -> TestMockableMock.SubscriptExpectation<(Int, _ newValue: String) -> Void> {
            .init(
                method: Methods.subscript_set_by_key_key_Int_String,
                parameters: [key.anyParameter]
            )
        }
    }

    public let recorder = Recorder()

    private let fileID: String
    private let filePath: StaticString
    private let line: UInt
    private let column: Int

    public init(
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column
    ) {
        self.fileID = fileID
        self.filePath = filePath
        self.line = line
        self.column = column
    }

    private func _record<P>(
        _ expectation: Recorder.Expectation, 
        _ fileID: String,
        _ filePath: StaticString,
        _ line: UInt,
        _ column: Int,
        _ perform: P
    ) {
        guard isEnabled else {
            handleFatalFailure(
                "Setting expectation on disabled mock is not allowed",
                fileID: fileID,
                filePath: filePath,
                line: line,
                column: column
            )            
        }
        recorder.record(
            .init(
                expectation, 
                perform,
                fileID,
                filePath, 
                line,
                column
            )
        )
    }

    private func _perform(_ method: MockMethod, _ parameters: [Any?] = []) -> Any {
        let invocation = Invocation(
            method: method,
            parameters: parameters
        )
        guard let stub = recorder.next() else {
            handleFatalFailure(
                "Expected no calls but received `\(invocation)`", 
                fileID: fileID,
                filePath: filePath,
                line: line,
                column: column
            )
        }

        guard stub.matches(invocation) else {
            handleFatalFailure(
                "Unexpected call: expected `\(stub.expectation)`, but received `\(invocation)`",
                fileID: stub.fileID,
                filePath: stub.filePath,
                line: stub.line,
                column: stub.column
            )
        }

        defer { recorder.checkVerification() }
        return stub.perform
    }

    internal func forceUnwrappedResult() -> String! {
        let perform = _perform(Methods.forceUnwrappedResult_sync_ret_String_impopt_) as! () -> String!
        return perform()
    }

    internal func newAPI() -> Void {
        let perform = _perform(Methods.newAPI_sync_ret_Void) as! () -> Void
        return perform()
    }

    internal func noParamsVoid() -> Void {
        let perform = _perform(Methods.noParamsVoid_sync_ret_Void) as! () -> Void
        return perform()
    }

    internal func noParamsVoidAsync() -> Void {
        let perform = _perform(Methods.noParamsVoidAsync_sync_ret_Void) as! () -> Void
        return perform()
    }

    internal func noParamsVoidAsyncThrowing() -> Void {
        let perform = _perform(Methods.noParamsVoidAsyncThrowing_sync_ret_Void) as! () -> Void
        return perform()
    }

    internal func noParamsResult() -> Swift.Int {
        let perform = _perform(Methods.noParamsResult_sync_ret_Swift_Int) as! () -> Swift.Int
        return perform()
    }

    internal func noParamsResult() -> Int? {
        let perform = _perform(Methods.noParamsResult_sync_ret_Int_opt_) as! () -> Int?
        return perform()
    }

    internal func noParamsImplicitOptionalResult() -> Int! {
        let perform = _perform(Methods.noParamsImplicitOptionalResult_sync_ret_Int_impopt_) as! () -> Int!
        return perform()
    }

    internal func noParamsArrayResult() -> [Int] {
        let perform = _perform(Methods.noParamsArrayResult_sync_ret__lsb_Int_rsb_) as! () -> [Int]
        return perform()
    }

    internal func noParamsDictionaryResult() -> [String: Int] {
        let perform = _perform(Methods.noParamsDictionaryResult_sync_ret__lsb_String_col_Int_rsb_) as! () -> [String: Int]
        return perform()
    }

    internal func noParamsClosureResult() -> (Int) -> Void {
        let perform = _perform(Methods.noParamsClosureResult_sync_ret__lp_Int_rp__ret_Void) as! () -> (Int) -> Void
        return perform()
    }

    internal func noParamsResultAsync() -> Int {
        let perform = _perform(Methods.noParamsResultAsync_sync_ret_Int) as! () -> Int
        return perform()
    }

    internal func noParamsAsyncThrowingResult() -> Int {
        let perform = _perform(Methods.noParamsAsyncThrowingResult_sync_ret_Int) as! () -> Int
        return perform()
    }

    internal func `func`() -> Void {
        let perform = _perform(Methods.func_sync_ret_Void) as! () -> Void
        return perform()
    }

    internal func withSelf(_ self: TestMockableMock) -> Self {
        let perform = _perform(
            Methods.withSelf_sync__self_Self_ret_Self,
            [self]
        ) as! (_ self: TestMockableMock) -> Self
        return perform(self)
    }

    internal func withOptionalClosure(_ closure: ((Int) -> Void)?) -> Void {
        let perform = _perform(
            Methods.withOptionalClosure_sync__closure__lp__lp_Int_rp__ret_Void_rp__opt__ret_Void,
            [closure]
        ) as! (_ closure: ((Int) -> Void)?) -> Void
        return perform(closure)
    }

    internal func withAnnotatedClosure(_ closure: (@MainActor @Sendable (Int) -> Void)?) -> Void {
        let perform = _perform(
            Methods.withAnnotatedClosure_sync__closure__lp_@MainActor@Sendable_lp_Int_rp__ret_Void_rp__opt__ret_Void,
            [closure]
        ) as! (_ closure: (@MainActor @Sendable (Int) -> Void)?) -> Void
        return perform(closure)
    }

    internal func withParamsVoid(int: Swift.Int, label labelString: String, _ string: String, _ optional: Int?, _ implicitOptional: Int!, _ `inout`: inout Int, _ array: [Int], _ dictionary: [String: Int], _ escapingClosure: @escaping (Int) -> Void) -> Void {
        let perform = _perform(
            Methods.withParamsVoid_syncint_int_Swift_Int_label_labelString_String___string_String___optional_Int_opt____implicitOptional_Int_impopt____inout_inoutInt___array__lsb_Int_rsb____dictionary__lsb_String_col_Int_rsb____escapingClosure_@escaping_lp_Int_rp__ret_Void_ret_Void,
            [int, labelString, string, optional, implicitOptional, `inout`, array, dictionary, escapingClosure]
        ) as! (_ int: Swift.Int, _ labelString: String, _ string: String, _ optional: Int?, _ implicitOptional: Int!, _ `inout`: inout Int, _ array: [Int], _ dictionary: [String: Int], _ escapingClosure: @escaping (Int) -> Void) -> Void
        return perform(int, labelString, string, optional, implicitOptional, `inout`, array, dictionary, escapingClosure)
    }

    internal func withParamsVoidAsync(int: Int, label labelString: String, _ string: String, _ optional: Int?) -> Void {
        let perform = _perform(
            Methods.withParamsVoidAsync_syncint_int_Int_label_labelString_String___string_String___optional_Int_opt__ret_Void,
            [int, labelString, string, optional]
        ) as! (_ int: Int, _ labelString: String, _ string: String, _ optional: Int?) -> Void
        return perform(int, labelString, string, optional)
    }

    internal func withParamsVoidAsyncThrowing(int: Int, label labelString: String, _ string: String, _ optional: Int?) -> Void {
        let perform = _perform(
            Methods.withParamsVoidAsyncThrowing_syncint_int_Int_label_labelString_String___string_String___optional_Int_opt__ret_Void,
            [int, labelString, string, optional]
        ) as! (_ int: Int, _ labelString: String, _ string: String, _ optional: Int?) -> Void
        return perform(int, labelString, string, optional)
    }

    internal func withParamsResult(int: Int, label labelString: String, _ string: String) -> Int {
        let perform = _perform(
            Methods.withParamsResult_syncint_int_Int_label_labelString_String___string_String_ret_Int,
            [int, labelString, string]
        ) as! (_ int: Int, _ labelString: String, _ string: String) -> Int
        return perform(int, labelString, string)
    }

    internal func withParamsResult(otherInt: Int, label labelString: String, _ string: String) -> Int {
        let perform = _perform(
            Methods.withParamsResult_syncotherInt_otherInt_Int_label_labelString_String___string_String_ret_Int,
            [otherInt, labelString, string]
        ) as! (_ otherInt: Int, _ labelString: String, _ string: String) -> Int
        return perform(otherInt, labelString, string)
    }

    internal func withParamsResultAsync(int: Int, label labelString: String, _ string: String) -> Int {
        let perform = _perform(
            Methods.withParamsResultAsync_syncint_int_Int_label_labelString_String___string_String_ret_Int,
            [int, labelString, string]
        ) as! (_ int: Int, _ labelString: String, _ string: String) -> Int
        return perform(int, labelString, string)
    }

    internal func withParamsAsyncThrowingResult(int: Int, label labelString: String, _ string: String) -> Int {
        let perform = _perform(
            Methods.withParamsAsyncThrowingResult_syncint_int_Int_label_labelString_String___string_String_ret_Int,
            [int, labelString, string]
        ) as! (_ int: Int, _ labelString: String, _ string: String) -> Int
        return perform(int, labelString, string)
    }

    internal func generic(parameter1: P1, _ parameter2: P2) -> Int {
        let perform = _perform(
            Methods.generic_syncparameter1_parameter1_P1___parameter2_P2_ret_Int,
            [parameter1, parameter2]
        ) as! (_ parameter1: P1, _ parameter2: P2) -> Int
        return perform(parameter1, parameter2)
    }

    internal func generic(some: some TestGenericProtocol<Int>, any: any TestGenericProtocol<String>) -> Int {
        let perform = _perform(
            Methods.generic_syncsome_some_someTestGenericProtocol_lab_Int_rab__any_any_anyTestGenericProtocol_lab_String_rab__ret_Int,
            [some, any]
        ) as! (_ some: any TestGenericProtocol<Int>, _ any: any TestGenericProtocol<String>) -> Int
        return perform(some, any)
    }

    internal func discardableResult() -> String {
        let perform = _perform(Methods.discardableResult_sync_ret_String) as! () -> String
        return perform()
    }

    internal func closureAliasResult(_ closure: @escaping ClosureAlias<Int>) -> ClosureAlias<Int> {
        let perform = _perform(
            Methods.closureAliasResult_sync__closure_@escapingClosureAlias_lab_Int_rab__ret_ClosureAlias_lab_Int_rab_,
            [closure]
        ) as! (_ closure: @escaping ClosureAlias<Int>) -> ClosureAlias<Int>
        return perform(closure)
    }

    internal func closureAliasResultEquivalent(_ closure: @escaping (Int) -> Void) -> (Int) -> Void {
        let perform = _perform(
            Methods.closureAliasResultEquivalent_sync__closure_@escaping_lp_Int_rp__ret_Void_ret__lp_Int_rp__ret_Void,
            [closure]
        ) as! (_ closure: @escaping (Int) -> Void) -> (Int) -> Void
        return perform(closure)
    }

    internal var property: OnlyProperty {
        get {
            let perform = _perform(Methods.property_sync_ret_OnlyProperty) as! () -> OnlyProperty
            return perform()
        }
        set {
            let perform = _perform(
                Methods.set_property_sync_ret_OnlyProperty,
                [newValue]
            ) as! (_ newValue: OnlyProperty) -> Void
            return perform(newValue)
        }
    }

    internal var throwingProperty: Int {
        get {
            let perform = _perform(Methods.throwingProperty_sync_ret_Int) as! () -> Int
            return perform()
        }
        set {
            let perform = _perform(
                Methods.set_throwingProperty_sync_ret_Int,
                [newValue]
            ) as! (_ newValue: Int) -> Void
            return perform(newValue)
        }
    }

    internal var asyncProperty: Int {
        get {
            let perform = _perform(Methods.asyncProperty_sync_ret_Int) as! () -> Int
            return perform()
        }
        set {
            let perform = _perform(
                Methods.set_asyncProperty_sync_ret_Int,
                [newValue]
            ) as! (_ newValue: Int) -> Void
            return perform(newValue)
        }
    }

    internal var asyncThrowingProperty: Int {
        get {
            let perform = _perform(Methods.asyncThrowingProperty_sync_ret_Int) as! () -> Int
            return perform()
        }
        set {
            let perform = _perform(
                Methods.set_asyncThrowingProperty_sync_ret_Int,
                [newValue]
            ) as! (_ newValue: Int) -> Void
            return perform(newValue)
        }
    }

    internal var readwriteProperty: Int {
        get {
            let perform = _perform(Methods.readwriteProperty_sync_ret_Int) as! () -> Int
            return perform()
        }
        set {
            let perform = _perform(
                Methods.set_readwriteProperty_sync_ret_Int,
                [newValue]
            ) as! (_ newValue: Int) -> Void
            return perform(newValue)
        }
    }

    internal var forceUnwrapped: String! {
        get {
            let perform = _perform(Methods.forceUnwrapped_sync_ret_String_impopt_) as! () -> String!
            return perform()
        }
        set {
            let perform = _perform(
                Methods.set_forceUnwrapped_sync_ret_String_impopt_,
                [newValue]
            ) as! (_ newValue: String!) -> Void
            return perform(newValue)
        }
    }

    internal subscript(key: String) -> TypeName(name: "Int", isOptional: false, isImplicitlyUnwrappedOptional: false, unwrappedTypeName: "Int", actualTypeNameString: nil, isVoid: false, isClosure: false, closureDescription: nil, attributes: []) {
        get {
            let perform = _perform(
                Methods.subscript_get_by_key_key_String_Int,
                [key]
            ) as! (_ key: String) -> Int
            return perform(key)
        }
        set {
            let perform = _perform(
                Methods.subscript_set_by_key_key_String_Int,
                [key, newValue]
            ) as! (String, _ newValue: Int) -> Void
            return perform(key, newValue)
        }
    }

    internal subscript(key: Int) -> TypeName(name: "String", isOptional: false, isImplicitlyUnwrappedOptional: false, unwrappedTypeName: "String", actualTypeNameString: nil, isVoid: false, isClosure: false, closureDescription: nil, attributes: []) {
        get {
            let perform = _perform(
                Methods.subscript_get_by_key_key_Int_String,
                [key]
            ) as! (_ key: Int) -> String
            return perform(key)
        }
        set {
            let perform = _perform(
                Methods.subscript_set_by_key_key_Int_String,
                [key, newValue]
            ) as! (Int, _ newValue: String) -> Void
            return perform(key, newValue)
        }
    }

    
    internal func expect(
        _ expectation: MethodExpectation<() -> String!>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping () -> String!
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    
    internal func expect(
        _ expectation: MethodExpectation<() -> Void>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping () -> Void = {}
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    
    internal func expect(
        _ expectation: MethodExpectation<() -> Swift.Int>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping () -> Swift.Int
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    
    internal func expect(
        _ expectation: MethodExpectation<() -> Int?>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping () -> Int?
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    
    internal func expect(
        _ expectation: MethodExpectation<() -> Int!>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping () -> Int!
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    
    internal func expect(
        _ expectation: MethodExpectation<() -> [Int]>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping () -> [Int]
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    
    internal func expect(
        _ expectation: MethodExpectation<() -> [String: Int]>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping () -> [String: Int]
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    
    internal func expect(
        _ expectation: MethodExpectation<() -> (Int) -> Void>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping () -> (Int) -> Void
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    
    internal func expect(
        _ expectation: MethodExpectation<() -> Int>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping () -> Int
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    
    internal func expect(
        _ expectation: MethodExpectation<(_ self: TestMockableMock) -> TestMockableMock>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ self: TestMockableMock) -> TestMockableMock
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    
    internal func expect(
        _ expectation: MethodExpectation<(_ closure: ((Int) -> Void)?) -> Void>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ closure: ((Int) -> Void)?) -> Void = { _ in }
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    
    internal func expect(
        _ expectation: MethodExpectation<(_ closure: (@MainActor @Sendable (Int) -> Void)?) -> Void>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ closure: (@MainActor @Sendable (Int) -> Void)?) -> Void = { _ in }
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    
    internal func expect(
        _ expectation: MethodExpectation<(_ int: Swift.Int, _ labelString: String, _ string: String, _ optional: Int?, _ implicitOptional: Int!, _ `inout`: inout Int, _ array: [Int], _ dictionary: [String: Int], _ escapingClosure: @escaping (Int) -> Void) -> Void>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ int: Swift.Int, _ labelString: String, _ string: String, _ optional: Int?, _ implicitOptional: Int!, _ `inout`: inout Int, _ array: [Int], _ dictionary: [String: Int], _ escapingClosure: @escaping (Int) -> Void) -> Void = { _, _, _, _, _, _, _, _, _ in }
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    
    internal func expect(
        _ expectation: MethodExpectation<(_ int: Int, _ labelString: String, _ string: String, _ optional: Int?) -> Void>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ int: Int, _ labelString: String, _ string: String, _ optional: Int?) -> Void = { _, _, _, _ in }
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    
    internal func expect(
        _ expectation: MethodExpectation<(_ int: Int, _ labelString: String, _ string: String) -> Int>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ int: Int, _ labelString: String, _ string: String) -> Int
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    
    internal func expect(
        _ expectation: MethodExpectation<(_ parameter1: P1, _ parameter2: P2) -> Int>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ parameter1: P1, _ parameter2: P2) -> Int
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    
    internal func expect(
        _ expectation: MethodExpectation<(_ some: any TestGenericProtocol<Int>, _ any: any TestGenericProtocol<String>) -> Int>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ some: any TestGenericProtocol<Int>, _ any: any TestGenericProtocol<String>) -> Int
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    
    internal func expect(
        _ expectation: MethodExpectation<() -> String>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping () -> String
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    
    internal func expect(
        _ expectation: MethodExpectation<(_ closure: @escaping ClosureAlias<Int>) -> ClosureAlias<Int>>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ closure: @escaping ClosureAlias<Int>) -> ClosureAlias<Int>
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    
    internal func expect(
        _ expectation: MethodExpectation<(_ closure: @escaping (Int) -> Void) -> (Int) -> Void>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ closure: @escaping (Int) -> Void) -> (Int) -> Void
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    public func expect(
        _ expectation: PropertyExpectation<() -> OnlyProperty>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping () -> OnlyProperty
    ) {
        _record(
            expectation.getterExpectation,
            fileID,
            filePath, 
            line,
            column,
            perform
        )
    }

    public func expect(
        _ expectation: PropertyExpectation<() -> Int>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping () -> Int
    ) {
        _record(
            expectation.getterExpectation,
            fileID,
            filePath, 
            line,
            column,
            perform
        )
    }

    public func expect(
        _ expectation: PropertyExpectation<() -> String!>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping () -> String!
    ) {
        _record(
            expectation.getterExpectation,
            fileID,
            filePath, 
            line,
            column,
            perform
        )
    }

    public func expect(
        set expectation: PropertyExpectation<(_ newValue: OnlyProperty) -> Void>,
        to newValue: Parameter<OnlyProperty>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ newValue: OnlyProperty) -> Void = { _ in }
    ) {
        _record(
            expectation.setterExpectation(newValue.anyParameter),
            fileID,
            filePath, 
            line,
            column,
            perform
        )
    }

    public func expect(
        set expectation: PropertyExpectation<(_ newValue: Int) -> Void>,
        to newValue: Parameter<Int>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ newValue: Int) -> Void = { _ in }
    ) {
        _record(
            expectation.setterExpectation(newValue.anyParameter),
            fileID,
            filePath, 
            line,
            column,
            perform
        )
    }

    public func expect(
        set expectation: PropertyExpectation<(_ newValue: String!) -> Void>,
        to newValue: Parameter<String!>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ newValue: String!) -> Void = { _ in }
    ) {
        _record(
            expectation.setterExpectation(newValue.anyParameter),
            fileID,
            filePath, 
            line,
            column,
            perform
        )
    }

    public func expect(
        _ expectation: SubscriptExpectation<(_ key: String) -> Int>,
        file: StaticString = #filePath,
        line: UInt = #line,
        perform: @escaping (_ key: String) -> Int
    ) {
        _record(
            expectation.getterExpectation,
            fileID,
            filePath, 
            line,
            column,
            perform
        )
    }

    public func expect(
        _ expectation: SubscriptExpectation<(_ key: Int) -> String>,
        file: StaticString = #filePath,
        line: UInt = #line,
        perform: @escaping (_ key: Int) -> String
    ) {
        _record(
            expectation.getterExpectation,
            fileID,
            filePath, 
            line,
            column,
            perform
        )
    }

    public func expect(
        set expectation: SubscriptExpectation<(String, _ newValue: Int) -> Void>,
        to newValue: Parameter<Int>,
        file: StaticString = #filePath,
        line: UInt = #line,
        perform: @escaping (String, _ newValue: Int) -> Void = {  _, _ in  }
    ) {
        _record(
            expectation.setterExpectation(newValue.anyParameter),
            fileID,
            filePath, 
            line,
            column,
            perform
        )
    }

    public func expect(
        set expectation: SubscriptExpectation<(Int, _ newValue: String) -> Void>,
        to newValue: Parameter<String>,
        file: StaticString = #filePath,
        line: UInt = #line,
        perform: @escaping (Int, _ newValue: String) -> Void = {  _, _ in  }
    ) {
        _record(
            expectation.setterExpectation(newValue.anyParameter),
            fileID,
            filePath, 
            line,
            column,
            perform
        )
    }
}

public extension TestMockableMock.PropertyExpectation where Signature == () -> OnlyProperty {
    static var property: Self {
        .init(method: TestMockableMock.Methods.property_sync_ret_OnlyProperty)
    }
}

public extension TestMockableMock.PropertyExpectation where Signature == (_ newValue: OnlyProperty) -> Void {
    static var property: Self {
        .init(method: TestMockableMock.Methods.set_property_sync_ret_OnlyProperty)
    }
}

public extension TestMockableMock.PropertyExpectation where Signature == () -> Int {
    static var throwingProperty: Self {
        .init(method: TestMockableMock.Methods.throwingProperty_sync_ret_Int)
    }
}

public extension TestMockableMock.PropertyExpectation where Signature == (_ newValue: Int) -> Void {
    static var throwingProperty: Self {
        .init(method: TestMockableMock.Methods.set_throwingProperty_sync_ret_Int)
    }
}

public extension TestMockableMock.PropertyExpectation where Signature == () -> Int {
    static var asyncProperty: Self {
        .init(method: TestMockableMock.Methods.asyncProperty_sync_ret_Int)
    }
}

public extension TestMockableMock.PropertyExpectation where Signature == (_ newValue: Int) -> Void {
    static var asyncProperty: Self {
        .init(method: TestMockableMock.Methods.set_asyncProperty_sync_ret_Int)
    }
}

public extension TestMockableMock.PropertyExpectation where Signature == () -> Int {
    static var asyncThrowingProperty: Self {
        .init(method: TestMockableMock.Methods.asyncThrowingProperty_sync_ret_Int)
    }
}

public extension TestMockableMock.PropertyExpectation where Signature == (_ newValue: Int) -> Void {
    static var asyncThrowingProperty: Self {
        .init(method: TestMockableMock.Methods.set_asyncThrowingProperty_sync_ret_Int)
    }
}

public extension TestMockableMock.PropertyExpectation where Signature == () -> Int {
    static var readwriteProperty: Self {
        .init(method: TestMockableMock.Methods.readwriteProperty_sync_ret_Int)
    }
}

public extension TestMockableMock.PropertyExpectation where Signature == (_ newValue: Int) -> Void {
    static var readwriteProperty: Self {
        .init(method: TestMockableMock.Methods.set_readwriteProperty_sync_ret_Int)
    }
}

public extension TestMockableMock.PropertyExpectation where Signature == () -> String! {
    static var forceUnwrapped: Self {
        .init(method: TestMockableMock.Methods.forceUnwrapped_sync_ret_String_impopt_)
    }
}

public extension TestMockableMock.PropertyExpectation where Signature == (_ newValue: String!) -> Void {
    static var forceUnwrapped: Self {
        .init(method: TestMockableMock.Methods.set_forceUnwrapped_sync_ret_String_impopt_)
    }
}

open class GenericTestMockableMock: GenericTestMockable, Mock {

    enum Methods {
        static var doSomething_syncwith_value_Value_ret_Void: MockMethod {
            .init {
                "doSomething(with: \($0[0] ?? "nil"))"
            }
        }
        static var doSomething_syncwith_value_ConstrainedValue_ret_Void: MockMethod {
            .init {
                "doSomething(with: \($0[0] ?? "nil"))"
            }
        }
        static var doSomethingWithInput_sync__input_I_ret_O: MockMethod {
            .init {
                "doSomethingWithInput(_: \($0[0] ?? "nil"))"
            }
        }
    }

    public struct MethodExpectation<Signature> {
        public let expectation: Recorder.Expectation

        init(method: MockMethod, parameters: [AnyParameter]) {
            self.expectation = .init(
                method: method,
                parameters: parameters
            )
        }

        internal static func doSomething(with value: Parameter<Value>) -> Self
        where Signature == (_ value: Value) -> Void {
            .init(
                method: Methods.doSomething_syncwith_value_Value_ret_Void,
                parameters: [value.anyParameter]
            )
        }

        internal static func doSomething(with value: Parameter<ConstrainedValue>) -> Self
        where Signature == (_ value: ConstrainedValue) -> Void {
            .init(
                method: Methods.doSomething_syncwith_value_ConstrainedValue_ret_Void,
                parameters: [value.anyParameter]
            )
        }

        internal static func doSomethingWithInput(_ input: Parameter<I>) -> Self
        where Signature == (_ input: I) -> O {
            .init(
                method: Methods.doSomethingWithInput_sync__input_I_ret_O,
                parameters: [input.anyParameter]
            )
        }
    }

    public let recorder = Recorder()

    private let fileID: String
    private let filePath: StaticString
    private let line: UInt
    private let column: Int

    public init(
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column
    ) {
        self.fileID = fileID
        self.filePath = filePath
        self.line = line
        self.column = column
    }

    private func _record<P>(
        _ expectation: Recorder.Expectation, 
        _ fileID: String,
        _ filePath: StaticString,
        _ line: UInt,
        _ column: Int,
        _ perform: P
    ) {
        guard isEnabled else {
            handleFatalFailure(
                "Setting expectation on disabled mock is not allowed",
                fileID: fileID,
                filePath: filePath,
                line: line,
                column: column
            )            
        }
        recorder.record(
            .init(
                expectation, 
                perform,
                fileID,
                filePath, 
                line,
                column
            )
        )
    }

    private func _perform(_ method: MockMethod, _ parameters: [Any?] = []) -> Any {
        let invocation = Invocation(
            method: method,
            parameters: parameters
        )
        guard let stub = recorder.next() else {
            handleFatalFailure(
                "Expected no calls but received `\(invocation)`", 
                fileID: fileID,
                filePath: filePath,
                line: line,
                column: column
            )
        }

        guard stub.matches(invocation) else {
            handleFatalFailure(
                "Unexpected call: expected `\(stub.expectation)`, but received `\(invocation)`",
                fileID: stub.fileID,
                filePath: stub.filePath,
                line: stub.line,
                column: stub.column
            )
        }

        defer { recorder.checkVerification() }
        return stub.perform
    }

    internal func doSomething(with value: Value) -> Void {
        let perform = _perform(
            Methods.doSomething_syncwith_value_Value_ret_Void,
            [value]
        ) as! (_ value: Value) -> Void
        return perform(value)
    }

    internal func doSomething(with value: ConstrainedValue) -> Void {
        let perform = _perform(
            Methods.doSomething_syncwith_value_ConstrainedValue_ret_Void,
            [value]
        ) as! (_ value: ConstrainedValue) -> Void
        return perform(value)
    }

    internal func doSomethingWithInput(_ input: I) -> O {
        let perform = _perform(
            Methods.doSomethingWithInput_sync__input_I_ret_O,
            [input]
        ) as! (_ input: I) -> O
        return perform(input)
    }

    
    internal func expect(
        _ expectation: MethodExpectation<(_ value: Value) -> Void>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ value: Value) -> Void = { _ in }
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    
    internal func expect(
        _ expectation: MethodExpectation<(_ value: ConstrainedValue) -> Void>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ value: ConstrainedValue) -> Void = { _ in }
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    
    internal func expect(
        _ expectation: MethodExpectation<(_ input: I) -> O>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ input: I) -> O
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }
}