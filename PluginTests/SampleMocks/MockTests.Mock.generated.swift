import UltiMock
import XCTest
@testable import TestableMockables

// Generated by UltiMock. DO NOT EDIT!

internal class InternalMockableMock: InternalMockable, Mock {

    enum Methods {
        static var doSomething_syncwith_internal_Internal_ret_Void: MockMethod {
            .init {
                "doSomething(with: \($0[0] ?? "nil"))"
            }
        }
        static var doSomething_syncwithAny_any_Any_ret_Void: MockMethod {
            .init {
                "doSomething(withAny: \($0[0] ?? "nil"))"
            }
        }
    }

    internal struct MethodExpectation<Signature> {
        internal let expectation: Recorder.Expectation

        init(method: MockMethod, parameters: [AnyParameter]) {
            self.expectation = .init(
                method: method,
                parameters: parameters
            )
        }

        internal static func doSomething(with internal: Parameter<Internal>) -> Self
        where Signature == (_ internal: Internal) -> Void {
            .init(
                method: Methods.doSomething_syncwith_internal_Internal_ret_Void,
                parameters: [`internal`.anyParameter]
            )
        }

        internal static func doSomething(withAny any: Parameter<Any>) -> Self
        where Signature == (_ any: Any) -> Void {
            .init(
                method: Methods.doSomething_syncwithAny_any_Any_ret_Void,
                parameters: [any.anyParameter]
            )
        }
    }

    public let recorder = Recorder()

    private let fileID: String
    private let filePath: StaticString
    private let line: UInt
    private let column: Int

    public init(
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column
    ) {
        self.fileID = fileID
        self.filePath = filePath
        self.line = line
        self.column = column
    }

    private func _record<P>(
        _ expectation: Recorder.Expectation, 
        _ fileID: String,
        _ filePath: StaticString,
        _ line: UInt,
        _ column: Int,
        _ perform: P
    ) {
        guard isEnabled else {
            handleFatalFailure(
                "Setting expectation on disabled mock is not allowed",
                fileID: fileID,
                filePath: filePath,
                line: line,
                column: column
            )            
        }
        recorder.record(
            .init(
                expectation, 
                perform,
                fileID,
                filePath, 
                line,
                column
            )
        )
    }

    private func _perform(_ method: MockMethod, _ parameters: [Any?] = []) -> Any {
        let invocation = Invocation(
            method: method,
            parameters: parameters
        )
        guard let stub = recorder.next() else {
            handleFatalFailure(
                "Expected no calls but received `\(invocation)`", 
                fileID: fileID,
                filePath: filePath,
                line: line,
                column: column
            )
        }

        guard stub.matches(invocation) else {
            handleFatalFailure(
                "Unexpected call: expected `\(stub.expectation)`, but received `\(invocation)`",
                fileID: stub.fileID,
                filePath: stub.filePath,
                line: stub.line,
                column: stub.column
            )
        }

        defer { recorder.checkVerification() }
        return stub.perform
    }

    internal func doSomething(with internal: Internal) -> Void {
        let perform = _perform(
            Methods.doSomething_syncwith_internal_Internal_ret_Void,
            [`internal`]
        ) as! (_ internal: Internal) -> Void
        return perform(`internal`)
    }

    internal func doSomething(withAny any: Any) -> Void {
        let perform = _perform(
            Methods.doSomething_syncwithAny_any_Any_ret_Void,
            [any]
        ) as! (_ any: Any) -> Void
        return perform(any)
    }

    
    internal func expect(
        _ expectation: MethodExpectation<(_ internal: Internal) -> Void>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ internal: Internal) -> Void = { _ in }
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    
    internal func expect(
        _ expectation: MethodExpectation<(_ any: Any) -> Void>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ any: Any) -> Void = { _ in }
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }
}

internal class InternalSubclassOfAPublicClassMock: InternalSubclassOfAPublicClass, Mock {

    enum Methods {
        static var doSomething_sync_ret_Void: MockMethod {
            .init { _ in
                "doSomething()"
            }
        }
        static var value_sync_ret_Int: MockMethod {
            .init { _ in
                "value"
            }
        }
        static var set_value_sync_ret_Int: MockMethod {
            .init {
                "value = \($0[0] ?? "nil")"
            }
        }
    }

    internal struct MethodExpectation<Signature> {
        internal let expectation: Recorder.Expectation

        init(method: MockMethod, parameters: [AnyParameter]) {
            self.expectation = .init(
                method: method,
                parameters: parameters
            )
        }

        public static func doSomething() -> Self
        where Signature == () -> Void {
            .init(
                method: Methods.doSomething_sync_ret_Void,
                parameters: []
            )
        }
    }

    internal struct PropertyExpectation<Signature> {
        private let method: MockMethod

        init(method: MockMethod) {
            self.method = method
        }

        internal var getterExpectation: Recorder.Expectation {
            .init(
                method: method,
                parameters: []
            )
        }

        internal func setterExpectation(_ newValue: AnyParameter) -> Recorder.Expectation {
            .init(
                method: method,
                parameters: [newValue]
            )
        }
    }

    public let recorder = Recorder()

    private let fileID: String
    private let filePath: StaticString
    private let line: UInt
    private let column: Int


    internal init(
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column
    ) {
        self.fileID = fileID
        self.filePath = filePath
        self.line = line
        self.column = column
        self.autoForwardingEnabled = true
        super.init()
        self.autoForwardingEnabled = false
    }

    public var autoForwardingEnabled: Bool

    public var isEnabled: Bool {
        !autoForwardingEnabled
    }

    private func _record<P>(
        _ expectation: Recorder.Expectation, 
        _ fileID: String,
        _ filePath: StaticString,
        _ line: UInt,
        _ column: Int,
        _ perform: P
    ) {
        guard isEnabled else {
            handleFatalFailure(
                "Setting expectation on disabled mock is not allowed",
                fileID: fileID,
                filePath: filePath,
                line: line,
                column: column
            )            
        }
        recorder.record(
            .init(
                expectation, 
                perform,
                fileID,
                filePath, 
                line,
                column
            )
        )
    }

    private func _perform(_ method: MockMethod, _ parameters: [Any?] = []) -> Any {
        let invocation = Invocation(
            method: method,
            parameters: parameters
        )
        guard let stub = recorder.next() else {
            handleFatalFailure(
                "Expected no calls but received `\(invocation)`", 
                fileID: fileID,
                filePath: filePath,
                line: line,
                column: column
            )
        }

        guard stub.matches(invocation) else {
            handleFatalFailure(
                "Unexpected call: expected `\(stub.expectation)`, but received `\(invocation)`",
                fileID: stub.fileID,
                filePath: stub.filePath,
                line: stub.line,
                column: stub.column
            )
        }

        defer { recorder.checkVerification() }
        return stub.perform
    }

    public override func doSomething() -> Void {
        guard !autoForwardingEnabled else {
            return super.doSomething()
        }
        let perform = _perform(Methods.doSomething_sync_ret_Void) as! (_ forwardToOriginal: () -> Void) -> Void
        return perform(super.doSomething)
    }

    public override var value: Int {
        get {
            guard !autoForwardingEnabled else {
                return super.value
            }
            let perform = _perform(Methods.value_sync_ret_Int) as! (_ forwardToOriginal: () -> Int) -> Int
            return perform({ super.value })
        }
        set {
            guard !autoForwardingEnabled else {
                super.value = newValue
                return
            }
            let perform = _perform(
                Methods.set_value_sync_ret_Int,
                [newValue]
            ) as! (_ forwardToOriginal: (_ newValue: Int) -> Void, _ newValue: Int) -> Void
            return perform({ super.value = $0 }, newValue)
        }
    }

    
    public func expect(
        _ expectation: MethodExpectation<() -> Void>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ forwardToOriginal: () -> Void) -> Void = { _forwardToSuper in
            _forwardToSuper()
        }
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    public func expect(
        _ expectation: PropertyExpectation<() -> Int>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ forwardToOriginal: () -> Int) -> Int = { $0() }
    ) {
        _record(
            expectation.getterExpectation,
            fileID,
            filePath, 
            line,
            column,
            perform
        )
    }

    public func expect(
        set expectation: PropertyExpectation<(_ newValue: Int) -> Void>,
        to newValue: Parameter<Int>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ forwardToOriginal: (_ newValue: Int) -> Void, _ newValue: Int) -> Void = { $0($1) }
    ) {
        _record(
            expectation.setterExpectation(newValue.anyParameter),
            fileID,
            filePath, 
            line,
            column,
            perform
        )
    }
}

internal extension InternalSubclassOfAPublicClassMock.PropertyExpectation where Signature == () -> Int {
    static var value: Self {
        .init(method: InternalSubclassOfAPublicClassMock.Methods.value_sync_ret_Int)
    }
}

internal extension InternalSubclassOfAPublicClassMock.PropertyExpectation where Signature == (_ newValue: Int) -> Void {
    static var value: Self {
        .init(method: InternalSubclassOfAPublicClassMock.Methods.set_value_sync_ret_Int)
    }
}

internal class ObjCMockableMock: ObjCMockable, Mock {

    enum Methods {
        static var doSomething_syncwith_int_Int_ret_Void: MockMethod {
            .init {
                "doSomething(with: \($0[0] ?? "nil"))"
            }
        }
    }

    internal struct MethodExpectation<Signature> {
        internal let expectation: Recorder.Expectation

        init(method: MockMethod, parameters: [AnyParameter]) {
            self.expectation = .init(
                method: method,
                parameters: parameters
            )
        }

        internal static func doSomething(with int: Parameter<Int>) -> Self
        where Signature == (_ int: Int) -> Void {
            .init(
                method: Methods.doSomething_syncwith_int_Int_ret_Void,
                parameters: [int.anyParameter]
            )
        }
    }

    public let recorder = Recorder()

    private let fileID: String
    private let filePath: StaticString
    private let line: UInt
    private let column: Int

    public init(
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column
    ) {
        self.fileID = fileID
        self.filePath = filePath
        self.line = line
        self.column = column
    }

    private func _record<P>(
        _ expectation: Recorder.Expectation, 
        _ fileID: String,
        _ filePath: StaticString,
        _ line: UInt,
        _ column: Int,
        _ perform: P
    ) {
        guard isEnabled else {
            handleFatalFailure(
                "Setting expectation on disabled mock is not allowed",
                fileID: fileID,
                filePath: filePath,
                line: line,
                column: column
            )            
        }
        recorder.record(
            .init(
                expectation, 
                perform,
                fileID,
                filePath, 
                line,
                column
            )
        )
    }

    private func _perform(_ method: MockMethod, _ parameters: [Any?] = []) -> Any {
        let invocation = Invocation(
            method: method,
            parameters: parameters
        )
        guard let stub = recorder.next() else {
            handleFatalFailure(
                "Expected no calls but received `\(invocation)`", 
                fileID: fileID,
                filePath: filePath,
                line: line,
                column: column
            )
        }

        guard stub.matches(invocation) else {
            handleFatalFailure(
                "Unexpected call: expected `\(stub.expectation)`, but received `\(invocation)`",
                fileID: stub.fileID,
                filePath: stub.filePath,
                line: stub.line,
                column: stub.column
            )
        }

        defer { recorder.checkVerification() }
        return stub.perform
    }

    @objc(doSomethingWith:)
    internal func doSomething(with int: Int) -> Void {
        let perform = _perform(
            Methods.doSomething_syncwith_int_Int_ret_Void,
            [int]
        ) as! (_ int: Int) -> Void
        return perform(int)
    }

    
    internal func expect(
        _ expectation: MethodExpectation<(_ int: Int) -> Void>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ int: Int) -> Void = { _ in }
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }
}

internal class RefinedGenericProtocolMock<Base: Identifiable>: RefinedGenericProtocol, Mock {
    internal typealias Base = Base
    internal typealias A = Base.ID
    internal typealias B = Base

    enum Methods {
        static var value_syncfor_key_A_ret_B: MockMethod {
            .init {
                "value(for: \($0[0] ?? "nil"))"
            }
        }
        static var a_sync_ret_A: MockMethod {
            .init { _ in
                "a"
            }
        }
        static var set_a_sync_ret_A: MockMethod {
            .init {
                "a = \($0[0] ?? "nil")"
            }
        }
        static var base_sync_ret_Base: MockMethod {
            .init { _ in
                "base"
            }
        }
        static var set_base_sync_ret_Base: MockMethod {
            .init {
                "base = \($0[0] ?? "nil")"
            }
        }
        static var subscript_get_by_key_key_A_B: MockMethod {
            .init {
                "[key: \($0[0] ?? "nil")]"
            }
        }
        static var subscript_set_by_key_key_A_B: MockMethod {
            .init {
                "[key: \($0[0] ?? "nil")] = \($0.last! ?? "nil")"
            }
        }
        static var subscript_get_by_key_key_Int_String: MockMethod {
            .init {
                "[key: \($0[0] ?? "nil")]"
            }
        }
        static var subscript_set_by_key_key_Int_String: MockMethod {
            .init {
                "[key: \($0[0] ?? "nil")] = \($0.last! ?? "nil")"
            }
        }
    }

    internal struct MethodExpectation<Signature> {
        internal let expectation: Recorder.Expectation

        init(method: MockMethod, parameters: [AnyParameter]) {
            self.expectation = .init(
                method: method,
                parameters: parameters
            )
        }

        internal static func value(for key: Parameter<A>) -> Self
        where Signature == (_ key: A) -> B {
            .init(
                method: Methods.value_syncfor_key_A_ret_B,
                parameters: [key.anyParameter]
            )
        }
    }

    internal struct PropertyExpectation<Signature> {
        private let method: MockMethod

        init(method: MockMethod) {
            self.method = method
        }

        internal var getterExpectation: Recorder.Expectation {
            .init(
                method: method,
                parameters: []
            )
        }

        internal func setterExpectation(_ newValue: AnyParameter) -> Recorder.Expectation {
            .init(
                method: method,
                parameters: [newValue]
            )
        }
    }

    internal struct SubscriptExpectation<Signature> {
        private let method: MockMethod
        private let parameters: [AnyParameter]

        init(method: MockMethod, parameters: [AnyParameter]) {
            self.method = method
            self.parameters = parameters
        }

        internal var getterExpectation: Recorder.Expectation {
            .init(
                method: method,
                parameters: parameters
            )
        }

        internal func setterExpectation(_ newValue: AnyParameter) -> Recorder.Expectation {
            .init(
                method: method,
                parameters: parameters + [newValue]
            )
        }

        internal static var `subscript`: RefinedGenericProtocolMock.SubscriptExpectations { .init() }
    }

    internal struct SubscriptExpectations {

        internal subscript(key: Parameter<A>) -> RefinedGenericProtocolMock.SubscriptExpectation<(_ key: A) -> B> {
            .init(
                method: Methods.subscript_get_by_key_key_A_B,
                parameters: [key.anyParameter]
            )
        }
        
        internal subscript(key: Parameter<A>) -> RefinedGenericProtocolMock.SubscriptExpectation<(A, _ newValue: B) -> Void> {
            .init(
                method: Methods.subscript_set_by_key_key_A_B,
                parameters: [key.anyParameter]
            )
        }

        internal subscript(key: Parameter<Int>) -> RefinedGenericProtocolMock.SubscriptExpectation<(_ key: Int) -> String> {
            .init(
                method: Methods.subscript_get_by_key_key_Int_String,
                parameters: [key.anyParameter]
            )
        }
        
        internal subscript(key: Parameter<Int>) -> RefinedGenericProtocolMock.SubscriptExpectation<(Int, _ newValue: String) -> Void> {
            .init(
                method: Methods.subscript_set_by_key_key_Int_String,
                parameters: [key.anyParameter]
            )
        }
    }

    public let recorder = Recorder()

    private let fileID: String
    private let filePath: StaticString
    private let line: UInt
    private let column: Int

    public init(
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column
    ) {
        self.fileID = fileID
        self.filePath = filePath
        self.line = line
        self.column = column
    }

    private func _record<P>(
        _ expectation: Recorder.Expectation, 
        _ fileID: String,
        _ filePath: StaticString,
        _ line: UInt,
        _ column: Int,
        _ perform: P
    ) {
        guard isEnabled else {
            handleFatalFailure(
                "Setting expectation on disabled mock is not allowed",
                fileID: fileID,
                filePath: filePath,
                line: line,
                column: column
            )            
        }
        recorder.record(
            .init(
                expectation, 
                perform,
                fileID,
                filePath, 
                line,
                column
            )
        )
    }

    private func _perform(_ method: MockMethod, _ parameters: [Any?] = []) -> Any {
        let invocation = Invocation(
            method: method,
            parameters: parameters
        )
        guard let stub = recorder.next() else {
            handleFatalFailure(
                "Expected no calls but received `\(invocation)`", 
                fileID: fileID,
                filePath: filePath,
                line: line,
                column: column
            )
        }

        guard stub.matches(invocation) else {
            handleFatalFailure(
                "Unexpected call: expected `\(stub.expectation)`, but received `\(invocation)`",
                fileID: stub.fileID,
                filePath: stub.filePath,
                line: stub.line,
                column: stub.column
            )
        }

        defer { recorder.checkVerification() }
        return stub.perform
    }

    internal func value(for key: A) -> B {
        let perform = _perform(
            Methods.value_syncfor_key_A_ret_B,
            [key]
        ) as! (_ key: A) -> B
        return perform(key)
    }

    internal var a: A {
        get {
            let perform = _perform(Methods.a_sync_ret_A) as! () -> A
            return perform()
        }
        set {
            let perform = _perform(
                Methods.set_a_sync_ret_A,
                [newValue]
            ) as! (_ newValue: A) -> Void
            return perform(newValue)
        }
    }

    internal var base: Base {
        get {
            let perform = _perform(Methods.base_sync_ret_Base) as! () -> Base
            return perform()
        }
        set {
            let perform = _perform(
                Methods.set_base_sync_ret_Base,
                [newValue]
            ) as! (_ newValue: Base) -> Void
            return perform(newValue)
        }
    }

    internal subscript(key: A) -> B {
        get {
            let perform = _perform(
                Methods.subscript_get_by_key_key_A_B,
                [key]
            ) as! (_ key: A) -> B
            return perform(key)
        }
        set {
            let perform = _perform(
                Methods.subscript_set_by_key_key_A_B,
                [key, newValue]
            ) as! (A, _ newValue: B) -> Void
            return perform(key, newValue)
        }
    }

    internal subscript(key: Int) -> String {
        get {
            let perform = _perform(
                Methods.subscript_get_by_key_key_Int_String,
                [key]
            ) as! (_ key: Int) -> String
            return perform(key)
        }
        set {
            let perform = _perform(
                Methods.subscript_set_by_key_key_Int_String,
                [key, newValue]
            ) as! (Int, _ newValue: String) -> Void
            return perform(key, newValue)
        }
    }

    
    internal func expect(
        _ expectation: MethodExpectation<(_ key: A) -> B>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ key: A) -> B
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    public func expect(
        _ expectation: PropertyExpectation<() -> A>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping () -> A
    ) {
        _record(
            expectation.getterExpectation,
            fileID,
            filePath, 
            line,
            column,
            perform
        )
    }

    public func expect(
        _ expectation: PropertyExpectation<() -> Base>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping () -> Base
    ) {
        _record(
            expectation.getterExpectation,
            fileID,
            filePath, 
            line,
            column,
            perform
        )
    }

    public func expect(
        set expectation: PropertyExpectation<(_ newValue: A) -> Void>,
        to newValue: Parameter<A>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ newValue: A) -> Void = { _ in }
    ) {
        _record(
            expectation.setterExpectation(newValue.anyParameter),
            fileID,
            filePath, 
            line,
            column,
            perform
        )
    }

    public func expect(
        set expectation: PropertyExpectation<(_ newValue: Base) -> Void>,
        to newValue: Parameter<Base>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ newValue: Base) -> Void = { _ in }
    ) {
        _record(
            expectation.setterExpectation(newValue.anyParameter),
            fileID,
            filePath, 
            line,
            column,
            perform
        )
    }

    public func expect(
        _ expectation: SubscriptExpectation<(_ key: A) -> B>,
        file: StaticString = #filePath,
        line: UInt = #line,
        perform: @escaping (_ key: A) -> B
    ) {
        _record(
            expectation.getterExpectation,
            fileID,
            filePath, 
            line,
            column,
            perform
        )
    }

    public func expect(
        _ expectation: SubscriptExpectation<(_ key: Int) -> String>,
        file: StaticString = #filePath,
        line: UInt = #line,
        perform: @escaping (_ key: Int) -> String
    ) {
        _record(
            expectation.getterExpectation,
            fileID,
            filePath, 
            line,
            column,
            perform
        )
    }

    public func expect(
        set expectation: SubscriptExpectation<(A, _ newValue: B) -> Void>,
        to newValue: Parameter<B>,
        file: StaticString = #filePath,
        line: UInt = #line,
        perform: @escaping (A, _ newValue: B) -> Void = {  _, _ in  }
    ) {
        _record(
            expectation.setterExpectation(newValue.anyParameter),
            fileID,
            filePath, 
            line,
            column,
            perform
        )
    }

    public func expect(
        set expectation: SubscriptExpectation<(Int, _ newValue: String) -> Void>,
        to newValue: Parameter<String>,
        file: StaticString = #filePath,
        line: UInt = #line,
        perform: @escaping (Int, _ newValue: String) -> Void = {  _, _ in  }
    ) {
        _record(
            expectation.setterExpectation(newValue.anyParameter),
            fileID,
            filePath, 
            line,
            column,
            perform
        )
    }
}

internal extension RefinedGenericProtocolMock.PropertyExpectation where Signature == () -> RefinedGenericProtocolMock.A {
    static var a: Self {
        .init(method: RefinedGenericProtocolMock.Methods.a_sync_ret_A)
    }
}

internal extension RefinedGenericProtocolMock.PropertyExpectation where Signature == (_ newValue: RefinedGenericProtocolMock.A) -> Void {
    static var a: Self {
        .init(method: RefinedGenericProtocolMock.Methods.set_a_sync_ret_A)
    }
}

internal extension RefinedGenericProtocolMock.PropertyExpectation where Signature == () -> RefinedGenericProtocolMock.Base {
    static var base: Self {
        .init(method: RefinedGenericProtocolMock.Methods.base_sync_ret_Base)
    }
}

internal extension RefinedGenericProtocolMock.PropertyExpectation where Signature == (_ newValue: RefinedGenericProtocolMock.Base) -> Void {
    static var base: Self {
        .init(method: RefinedGenericProtocolMock.Methods.set_base_sync_ret_Base)
    }
}

internal class SourceryIssue1Mock<Bar>: SourceryIssue1, Mock {
    internal typealias Bar = Bar

    enum Methods {
        static var value_sync_ret_Bar: MockMethod {
            .init { _ in
                "value"
            }
        }
    }

    internal struct MethodExpectation<Signature> {
        internal let expectation: Recorder.Expectation

        init(method: MockMethod, parameters: [AnyParameter]) {
            self.expectation = .init(
                method: method,
                parameters: parameters
            )
        }
    }

    internal struct PropertyExpectation<Signature> {
        private let method: MockMethod

        init(method: MockMethod) {
            self.method = method
        }

        internal var getterExpectation: Recorder.Expectation {
            .init(
                method: method,
                parameters: []
            )
        }

        internal func setterExpectation(_ newValue: AnyParameter) -> Recorder.Expectation {
            .init(
                method: method,
                parameters: [newValue]
            )
        }
    }

    public let recorder = Recorder()

    private let fileID: String
    private let filePath: StaticString
    private let line: UInt
    private let column: Int

    public init(
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column
    ) {
        self.fileID = fileID
        self.filePath = filePath
        self.line = line
        self.column = column
    }

    private func _record<P>(
        _ expectation: Recorder.Expectation, 
        _ fileID: String,
        _ filePath: StaticString,
        _ line: UInt,
        _ column: Int,
        _ perform: P
    ) {
        guard isEnabled else {
            handleFatalFailure(
                "Setting expectation on disabled mock is not allowed",
                fileID: fileID,
                filePath: filePath,
                line: line,
                column: column
            )            
        }
        recorder.record(
            .init(
                expectation, 
                perform,
                fileID,
                filePath, 
                line,
                column
            )
        )
    }

    private func _perform(_ method: MockMethod, _ parameters: [Any?] = []) -> Any {
        let invocation = Invocation(
            method: method,
            parameters: parameters
        )
        guard let stub = recorder.next() else {
            handleFatalFailure(
                "Expected no calls but received `\(invocation)`", 
                fileID: fileID,
                filePath: filePath,
                line: line,
                column: column
            )
        }

        guard stub.matches(invocation) else {
            handleFatalFailure(
                "Unexpected call: expected `\(stub.expectation)`, but received `\(invocation)`",
                fileID: stub.fileID,
                filePath: stub.filePath,
                line: stub.line,
                column: stub.column
            )
        }

        defer { recorder.checkVerification() }
        return stub.perform
    }

    internal var value: Bar {
        get {
            let perform = _perform(Methods.value_sync_ret_Bar) as! () -> Bar
            return perform()
        }
    }

    public func expect(
        _ expectation: PropertyExpectation<() -> Bar>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping () -> Bar
    ) {
        _record(
            expectation.getterExpectation,
            fileID,
            filePath, 
            line,
            column,
            perform
        )
    }

    public func expect(
        set expectation: PropertyExpectation<(_ newValue: Bar) -> Void>,
        to newValue: Parameter<Bar>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ newValue: Bar) -> Void = { _ in }
    ) {
        _record(
            expectation.setterExpectation(newValue.anyParameter),
            fileID,
            filePath, 
            line,
            column,
            perform
        )
    }
}

internal extension SourceryIssue1Mock.PropertyExpectation where Signature == () -> SourceryIssue1Mock.Bar {
    static var value: Self {
        .init(method: SourceryIssue1Mock.Methods.value_sync_ret_Bar)
    }
}

internal class TestableMockableMock: TestableMockable, Mock {

    enum Methods {
        static var doSomething_syncwith_internal_InternalMockableParameter_ret_Void: MockMethod {
            .init {
                "doSomething(with: \($0[0] ?? "nil"))"
            }
        }
    }

    internal struct MethodExpectation<Signature> {
        internal let expectation: Recorder.Expectation

        init(method: MockMethod, parameters: [AnyParameter]) {
            self.expectation = .init(
                method: method,
                parameters: parameters
            )
        }

        internal static func doSomething(with internal: Parameter<InternalMockableParameter>) -> Self
        where Signature == (_ internal: InternalMockableParameter) -> Void {
            .init(
                method: Methods.doSomething_syncwith_internal_InternalMockableParameter_ret_Void,
                parameters: [`internal`.anyParameter]
            )
        }
    }

    public let recorder = Recorder()

    private let fileID: String
    private let filePath: StaticString
    private let line: UInt
    private let column: Int

    public init(
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column
    ) {
        self.fileID = fileID
        self.filePath = filePath
        self.line = line
        self.column = column
    }

    private func _record<P>(
        _ expectation: Recorder.Expectation, 
        _ fileID: String,
        _ filePath: StaticString,
        _ line: UInt,
        _ column: Int,
        _ perform: P
    ) {
        guard isEnabled else {
            handleFatalFailure(
                "Setting expectation on disabled mock is not allowed",
                fileID: fileID,
                filePath: filePath,
                line: line,
                column: column
            )            
        }
        recorder.record(
            .init(
                expectation, 
                perform,
                fileID,
                filePath, 
                line,
                column
            )
        )
    }

    private func _perform(_ method: MockMethod, _ parameters: [Any?] = []) -> Any {
        let invocation = Invocation(
            method: method,
            parameters: parameters
        )
        guard let stub = recorder.next() else {
            handleFatalFailure(
                "Expected no calls but received `\(invocation)`", 
                fileID: fileID,
                filePath: filePath,
                line: line,
                column: column
            )
        }

        guard stub.matches(invocation) else {
            handleFatalFailure(
                "Unexpected call: expected `\(stub.expectation)`, but received `\(invocation)`",
                fileID: stub.fileID,
                filePath: stub.filePath,
                line: stub.line,
                column: stub.column
            )
        }

        defer { recorder.checkVerification() }
        return stub.perform
    }

    internal func doSomething(with internal: InternalMockableParameter) -> Void {
        let perform = _perform(
            Methods.doSomething_syncwith_internal_InternalMockableParameter_ret_Void,
            [`internal`]
        ) as! (_ internal: InternalMockableParameter) -> Void
        return perform(`internal`)
    }

    
    internal func expect(
        _ expectation: MethodExpectation<(_ internal: InternalMockableParameter) -> Void>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ internal: InternalMockableParameter) -> Void = { _ in }
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }
}