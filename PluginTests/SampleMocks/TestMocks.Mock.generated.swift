import CoreLocation
import TestPackage
import UltiMock
import XCTest

// Generated by UltiMock. DO NOT EDIT!

open class GenericTestMockableMock<ConstrainedValue: Equatable, Value>: GenericTestMockable, Mock {
    public typealias ConstrainedValue = ConstrainedValue
    public typealias Value = Value

    enum Methods {
        static var doSomething_syncwith_value_Value_ret_Void: MockMethod {
            .init {
                "doSomething(with: \($0[0] ?? "nil"))"
            }
        }
        static var doSomething_syncwith_value_ConstrainedValue_ret_Void: MockMethod {
            .init {
                "doSomething(with: \($0[0] ?? "nil"))"
            }
        }
        static var doSomethingWithInput_sync_input_I_ret_OwhereValue_eq__lp_I_rp__ret_O: MockMethod {
            .init {
                "doSomethingWithInput<I, O>(\($0[0] ?? "nil"))"
            }
        }
    }

    public struct MethodExpectation<Signature> {
        public let expectation: Recorder.Expectation

        init(method: MockMethod, parameters: [AnyParameter]) {
            self.expectation = .init(
                method: method,
                parameters: parameters
            )
        }

        public static func doSomething(with value: Parameter<Value>) -> Self
        where Signature == (_ value: Value) -> Void {
            .init(
                method: Methods.doSomething_syncwith_value_Value_ret_Void,
                parameters: [value.anyParameter]
            )
        }

        public static func doSomething(with value: Parameter<ConstrainedValue>) -> Self
        where Signature == (_ value: ConstrainedValue) -> Void {
            .init(
                method: Methods.doSomething_syncwith_value_ConstrainedValue_ret_Void,
                parameters: [value.anyParameter]
            )
        }

        public static func doSomethingWithInput<I, O>(_ input: Parameter<I>) -> Self
        where Signature == (_ input: I) -> O, Value == (I) -> O {
            .init(
                method: Methods.doSomethingWithInput_sync_input_I_ret_OwhereValue_eq__lp_I_rp__ret_O,
                parameters: [input.anyParameter]
            )
        }
    }

    public let recorder = Recorder()

    private let fileID: String
    private let filePath: StaticString
    private let line: UInt
    private let column: Int

    public init(
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column
    ) {
        self.fileID = fileID
        self.filePath = filePath
        self.line = line
        self.column = column
    }

    private func _record<P>(
        _ expectation: Recorder.Expectation, 
        _ fileID: String,
        _ filePath: StaticString,
        _ line: UInt,
        _ column: Int,
        _ perform: P
    ) {
        guard isEnabled else {
            handleFatalFailure(
                "Setting expectation on disabled mock is not allowed",
                fileID: fileID,
                filePath: filePath,
                line: line,
                column: column
            )            
        }
        recorder.record(
            .init(
                expectation, 
                perform,
                fileID,
                filePath, 
                line,
                column
            )
        )
    }

    private func _perform(_ method: MockMethod, _ parameters: [Any?] = []) -> Any {
        let invocation = Invocation(
            method: method,
            parameters: parameters
        )
        guard let stub = recorder.next() else {
            handleFatalFailure(
                "Expected no calls but received `\(invocation)`", 
                fileID: fileID,
                filePath: filePath,
                line: line,
                column: column
            )
        }

        guard stub.matches(invocation) else {
            handleFatalFailure(
                "Unexpected call: expected `\(stub.expectation)`, but received `\(invocation)`",
                fileID: stub.fileID,
                filePath: stub.filePath,
                line: stub.line,
                column: stub.column
            )
        }

        defer { recorder.checkVerification() }
        return stub.perform
    }

    public func doSomething(with value: Value) -> Void {
        let perform = _perform(
            Methods.doSomething_syncwith_value_Value_ret_Void,
            [value]
        ) as! (_ value: Value) -> Void
        return perform(value)
    }

    public func doSomething(with value: ConstrainedValue) -> Void {
        let perform = _perform(
            Methods.doSomething_syncwith_value_ConstrainedValue_ret_Void,
            [value]
        ) as! (_ value: ConstrainedValue) -> Void
        return perform(value)
    }

    public func doSomethingWithInput<I, O>(_ input: I) -> O {
        let perform = _perform(
            Methods.doSomethingWithInput_sync_input_I_ret_OwhereValue_eq__lp_I_rp__ret_O,
            [input]
        ) as! (_ input: I) -> O
        return perform(input)
    }

    
    public func expect(
        _ expectation: MethodExpectation<(_ value: Value) -> Void>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ value: Value) -> Void = { _ in }
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    
    public func expect(
        _ expectation: MethodExpectation<(_ value: ConstrainedValue) -> Void>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ value: ConstrainedValue) -> Void = { _ in }
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    
    public func expect<I, O>(
        _ expectation: MethodExpectation<(_ input: I) -> O>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ input: I) -> O
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }
}

open class Test3rdPartyProtocolMock<Input, Output>: Test3rdPartyProtocol, Mock {
    public typealias Input = Input
    public typealias Output = Output

    enum Methods {
        static var doSomething_sync_string_Input_ret_Output: MockMethod {
            .init {
                "doSomething(\($0[0] ?? "nil"))"
            }
        }
    }

    public struct MethodExpectation<Signature> {
        public let expectation: Recorder.Expectation

        init(method: MockMethod, parameters: [AnyParameter]) {
            self.expectation = .init(
                method: method,
                parameters: parameters
            )
        }

        public static func doSomething(_ string: Parameter<Input>) -> Self
        where Signature == (_ string: Input) -> Output {
            .init(
                method: Methods.doSomething_sync_string_Input_ret_Output,
                parameters: [string.anyParameter]
            )
        }
    }

    public let recorder = Recorder()

    private let fileID: String
    private let filePath: StaticString
    private let line: UInt
    private let column: Int

    public init(
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column
    ) {
        self.fileID = fileID
        self.filePath = filePath
        self.line = line
        self.column = column
    }

    private func _record<P>(
        _ expectation: Recorder.Expectation, 
        _ fileID: String,
        _ filePath: StaticString,
        _ line: UInt,
        _ column: Int,
        _ perform: P
    ) {
        guard isEnabled else {
            handleFatalFailure(
                "Setting expectation on disabled mock is not allowed",
                fileID: fileID,
                filePath: filePath,
                line: line,
                column: column
            )            
        }
        recorder.record(
            .init(
                expectation, 
                perform,
                fileID,
                filePath, 
                line,
                column
            )
        )
    }

    private func _perform(_ method: MockMethod, _ parameters: [Any?] = []) -> Any {
        let invocation = Invocation(
            method: method,
            parameters: parameters
        )
        guard let stub = recorder.next() else {
            handleFatalFailure(
                "Expected no calls but received `\(invocation)`", 
                fileID: fileID,
                filePath: filePath,
                line: line,
                column: column
            )
        }

        guard stub.matches(invocation) else {
            handleFatalFailure(
                "Unexpected call: expected `\(stub.expectation)`, but received `\(invocation)`",
                fileID: stub.fileID,
                filePath: stub.filePath,
                line: stub.line,
                column: stub.column
            )
        }

        defer { recorder.checkVerification() }
        return stub.perform
    }

    public func doSomething(_ string: Input) -> Output {
        let perform = _perform(
            Methods.doSomething_sync_string_Input_ret_Output,
            [string]
        ) as! (_ string: Input) -> Output
        return perform(string)
    }

    
    public func expect(
        _ expectation: MethodExpectation<(_ string: Input) -> Output>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ string: Input) -> Output
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }
}

open class TestMockableMock: TestMockable, @unchecked Sendable, Mock {

    enum Methods {
        static var forceUnwrappedResult_sync_ret_String_impopt_: MockMethod {
            .init { _ in
                "forceUnwrappedResult()"
            }
        }
        static var newAPI_sync_ret_Void: MockMethod {
            .init { _ in
                "newAPI()"
            }
        }
        static var noParamsVoid_sync_ret_Void: MockMethod {
            .init { _ in
                "noParamsVoid()"
            }
        }
        static var noParamsVoidAsync_async_ret_Void: MockMethod {
            .init { _ in
                "noParamsVoidAsync()"
            }
        }
        static var noParamsVoidAsyncThrowing_async_ret_Void: MockMethod {
            .init { _ in
                "noParamsVoidAsyncThrowing()"
            }
        }
        static var noParamsResult_sync_ret_Swift_Int: MockMethod {
            .init { _ in
                "noParamsResult()"
            }
        }
        static var noParamsResult_sync_ret_Int_opt_: MockMethod {
            .init { _ in
                "noParamsResult()"
            }
        }
        static var noParamsImplicitOptionalResult_sync_ret_Int_impopt_: MockMethod {
            .init { _ in
                "noParamsImplicitOptionalResult()"
            }
        }
        static var noParamsArrayResult_sync_ret__lsb_Int_rsb_: MockMethod {
            .init { _ in
                "noParamsArrayResult()"
            }
        }
        static var noParamsDictionaryResult_sync_ret__lsb_String_col_Int_rsb_: MockMethod {
            .init { _ in
                "noParamsDictionaryResult()"
            }
        }
        static var noParamsClosureResult_sync_ret__lp_Int_rp__ret_Void: MockMethod {
            .init { _ in
                "noParamsClosureResult()"
            }
        }
        static var noParamsResultAsync_async_ret_Int: MockMethod {
            .init { _ in
                "noParamsResultAsync()"
            }
        }
        static var noParamsAsyncThrowingResult_async_ret_Int: MockMethod {
            .init { _ in
                "noParamsAsyncThrowingResult()"
            }
        }
        static var func_sync_ret_Void: MockMethod {
            .init { _ in
                "`func`()"
            }
        }
        static var withSelf_sync_self_Self_ret_Self: MockMethod {
            .init {
                "withSelf(\($0[0] ?? "nil"))"
            }
        }
        static var withOptionalClosure_sync_closure__lp__lp_Int_rp__ret_Void_rp__opt__ret_Void: MockMethod {
            .init {
                "withOptionalClosure(\($0[0] ?? "nil"))"
            }
        }
        static var withAnnotatedClosure_sync_closure__lp__lp_Int_rp__ret_Void_rp__opt__ret_Void: MockMethod {
            .init {
                "withAnnotatedClosure(\($0[0] ?? "nil"))"
            }
        }
        static var withParamsVoid_syncint_int_Swift_Int_label_labelString_String__string_String__optional_Int_opt___implicitOptional_Int_impopt___inout_inoutInt__array__lsb_Int_rsb___dictionary__lsb_String_col_Int_rsb___escapingClosure__lp_Int_rp__ret_Void_ret_Void: MockMethod {
            .init {
                "withParamsVoid(int: \($0[0] ?? "nil"), label: \"\($0[1]!)\", \"\($0[2]!)\", \($0[3] ?? "nil"), \($0[4] ?? "nil"), \($0[5] ?? "nil"), \($0[6] ?? "nil"), \($0[7] ?? "nil"), \($0[8] ?? "nil"))"
            }
        }
        static var withParamsVoidAsync_asyncint_int_Int_label_labelString_String__string_String__optional_Int_opt__ret_Void: MockMethod {
            .init {
                "withParamsVoidAsync(int: \($0[0] ?? "nil"), label: \"\($0[1]!)\", \"\($0[2]!)\", \($0[3] ?? "nil"))"
            }
        }
        static var withParamsVoidAsyncThrowing_asyncint_int_Int_label_labelString_String__string_String__optional_Int_opt__ret_Void: MockMethod {
            .init {
                "withParamsVoidAsyncThrowing(int: \($0[0] ?? "nil"), label: \"\($0[1]!)\", \"\($0[2]!)\", \($0[3] ?? "nil"))"
            }
        }
        static var withParamsResult_syncint_int_Int_label_labelString_String__string_String_ret_Int: MockMethod {
            .init {
                "withParamsResult(int: \($0[0] ?? "nil"), label: \"\($0[1]!)\", \"\($0[2]!)\")"
            }
        }
        static var withParamsResult_syncotherInt_otherInt_Int_label_labelString_String__string_String_ret_Int: MockMethod {
            .init {
                "withParamsResult(otherInt: \($0[0] ?? "nil"), label: \"\($0[1]!)\", \"\($0[2]!)\")"
            }
        }
        static var withParamsResultAsync_asyncint_int_Int_label_labelString_String__string_String_ret_Int: MockMethod {
            .init {
                "withParamsResultAsync(int: \($0[0] ?? "nil"), label: \"\($0[1]!)\", \"\($0[2]!)\")"
            }
        }
        static var withParamsAsyncThrowingResult_asyncint_int_Int_label_labelString_String__string_String_ret_Int: MockMethod {
            .init {
                "withParamsAsyncThrowingResult(int: \($0[0] ?? "nil"), label: \"\($0[1]!)\", \"\($0[2]!)\")"
            }
        }
        static var generic_syncparameter1_parameter1_P1__parameter2_P2_ret_IntwhereP2_col_Hashable: MockMethod {
            .init {
                "generic<P1: Equatable, P2>(parameter1: \($0[0] ?? "nil"), \($0[1] ?? "nil"))"
            }
        }
        static var generic_syncsome_some_someTestGenericProtocol_lab_Int_rab__any_any_anyTestGenericProtocol_lab_String_rab__ret_Int: MockMethod {
            .init {
                "generic(some: \($0[0] ?? "nil"), any: \($0[1] ?? "nil"))"
            }
        }
        static var discardableResult_sync_ret_String: MockMethod {
            .init { _ in
                "discardableResult()"
            }
        }
        static var closureAliasResult_sync_closure_ClosureAlias_lab_Int_rab__ret_ClosureAlias_lab_Int_rab_: MockMethod {
            .init {
                "closureAliasResult(\($0[0] ?? "nil"))"
            }
        }
        static var closureAliasResultEquivalent_sync_closure__lp_Int_rp__ret_Void_ret__lp_Int_rp__ret_Void: MockMethod {
            .init {
                "closureAliasResultEquivalent(\($0[0] ?? "nil"))"
            }
        }
        static var property_sync_ret_OnlyProperty: MockMethod {
            .init { _ in
                "property"
            }
        }
        static var throwingProperty_sync_ret_Int: MockMethod {
            .init { _ in
                "throwingProperty"
            }
        }
        static var asyncProperty_async_ret_Int: MockMethod {
            .init { _ in
                "asyncProperty"
            }
        }
        static var asyncThrowingProperty_async_ret_Int: MockMethod {
            .init { _ in
                "asyncThrowingProperty"
            }
        }
        static var readwriteProperty_sync_ret_Int: MockMethod {
            .init { _ in
                "readwriteProperty"
            }
        }
        static var set_readwriteProperty_sync_ret_Int: MockMethod {
            .init {
                "readwriteProperty = \($0[0] ?? "nil")"
            }
        }
        static var forceUnwrapped_sync_ret_String_impopt_: MockMethod {
            .init { _ in
                "forceUnwrapped"
            }
        }
        static var set_forceUnwrapped_sync_ret_String_impopt_: MockMethod {
            .init {
                "forceUnwrapped = \($0[0] ?? "nil")"
            }
        }
        static var subscript_get_by_key_key_String_Int: MockMethod {
            .init {
                "[key: \"\($0[0]!)\"]"
            }
        }
        static var subscript_set_by_key_key_String_Int: MockMethod {
            .init {
                "[key: \"\($0[0]!)\"] = \($0.last! ?? "nil")"
            }
        }
        static var subscript_get_by_key_key_Int_String: MockMethod {
            .init {
                "[key: \($0[0] ?? "nil")]"
            }
        }
    }

    public struct MethodExpectation<Signature> {
        public let expectation: Recorder.Expectation

        init(method: MockMethod, parameters: [AnyParameter]) {
            self.expectation = .init(
                method: method,
                parameters: parameters
            )
        }

        public static func forceUnwrappedResult() -> Self
        where Signature == () -> String? {
            .init(
                method: Methods.forceUnwrappedResult_sync_ret_String_impopt_,
                parameters: []
            )
        }

        @available(iOS 15.0, *)
        public static func newAPI() -> Self
        where Signature == () -> Void {
            .init(
                method: Methods.newAPI_sync_ret_Void,
                parameters: []
            )
        }

        public static func noParamsVoid() -> Self
        where Signature == () -> Void {
            .init(
                method: Methods.noParamsVoid_sync_ret_Void,
                parameters: []
            )
        }

        public static func noParamsVoidAsync() -> Self
        where Signature == () async -> Void {
            .init(
                method: Methods.noParamsVoidAsync_async_ret_Void,
                parameters: []
            )
        }

        public static func noParamsVoidAsyncThrowing() -> Self
        where Signature == () async throws -> Void {
            .init(
                method: Methods.noParamsVoidAsyncThrowing_async_ret_Void,
                parameters: []
            )
        }

        public static func noParamsResult() -> Self
        where Signature == () -> Swift.Int {
            .init(
                method: Methods.noParamsResult_sync_ret_Swift_Int,
                parameters: []
            )
        }

        public static func noParamsResult() -> Self
        where Signature == () -> Int? {
            .init(
                method: Methods.noParamsResult_sync_ret_Int_opt_,
                parameters: []
            )
        }

        public static func noParamsImplicitOptionalResult() -> Self
        where Signature == () -> Int? {
            .init(
                method: Methods.noParamsImplicitOptionalResult_sync_ret_Int_impopt_,
                parameters: []
            )
        }

        public static func noParamsArrayResult() -> Self
        where Signature == () -> [Int] {
            .init(
                method: Methods.noParamsArrayResult_sync_ret__lsb_Int_rsb_,
                parameters: []
            )
        }

        public static func noParamsDictionaryResult() -> Self
        where Signature == () -> [String: Int] {
            .init(
                method: Methods.noParamsDictionaryResult_sync_ret__lsb_String_col_Int_rsb_,
                parameters: []
            )
        }

        public static func noParamsClosureResult() -> Self
        where Signature == () -> (Int) -> Void {
            .init(
                method: Methods.noParamsClosureResult_sync_ret__lp_Int_rp__ret_Void,
                parameters: []
            )
        }

        public static func noParamsResultAsync() -> Self
        where Signature == () async -> Int {
            .init(
                method: Methods.noParamsResultAsync_async_ret_Int,
                parameters: []
            )
        }

        public static func noParamsAsyncThrowingResult() -> Self
        where Signature == () async throws -> Int {
            .init(
                method: Methods.noParamsAsyncThrowingResult_async_ret_Int,
                parameters: []
            )
        }

        public static func `func`() -> Self
        where Signature == () -> Void {
            .init(
                method: Methods.func_sync_ret_Void,
                parameters: []
            )
        }

        public static func withSelf(_ self: Parameter<TestMockableMock>) -> Self
        where Signature == (_ self: TestMockableMock) -> TestMockableMock {
            .init(
                method: Methods.withSelf_sync_self_Self_ret_Self,
                parameters: [self.anyParameter]
            )
        }

        public static func withOptionalClosure(_ closure: Parameter<((Int) -> Void)?>) -> Self
        where Signature == (_ closure: ((Int) -> Void)?) -> Void {
            .init(
                method: Methods.withOptionalClosure_sync_closure__lp__lp_Int_rp__ret_Void_rp__opt__ret_Void,
                parameters: [closure.anyParameter]
            )
        }

        public static func withAnnotatedClosure(_ closure: Parameter<(@MainActor @Sendable (Int) -> Void)?>) -> Self
        where Signature == (_ closure: (@MainActor @Sendable (Int) -> Void)?) -> Void {
            .init(
                method: Methods.withAnnotatedClosure_sync_closure__lp__lp_Int_rp__ret_Void_rp__opt__ret_Void,
                parameters: [closure.anyParameter]
            )
        }

        public static func withParamsVoid(int: Parameter<Swift.Int>, label labelString: Parameter<String>, _ string: Parameter<String>, _ optional: Parameter<Int?>, _ implicitOptional: Parameter<Int?>, _ `inout`: Parameter<Int>, _ array: Parameter<[Int]>, _ dictionary: Parameter<[String: Int]>, _ escapingClosure: Parameter<(Int) -> Void>) -> Self
        where Signature == (_ int: Swift.Int, _ labelString: String, _ string: String, _ optional: Int?, _ implicitOptional: Int?, _ `inout`: inout Int, _ array: [Int], _ dictionary: [String: Int], _ escapingClosure: (Int) -> Void) -> Void {
            .init(
                method: Methods.withParamsVoid_syncint_int_Swift_Int_label_labelString_String__string_String__optional_Int_opt___implicitOptional_Int_impopt___inout_inoutInt__array__lsb_Int_rsb___dictionary__lsb_String_col_Int_rsb___escapingClosure__lp_Int_rp__ret_Void_ret_Void,
                parameters: [int.anyParameter, labelString.anyParameter, string.anyParameter, optional.anyParameter, implicitOptional.anyParameter, `inout`.anyParameter, array.anyParameter, dictionary.anyParameter, escapingClosure.anyParameter]
            )
        }

        public static func withParamsVoidAsync(int: Parameter<Int>, label labelString: Parameter<String>, _ string: Parameter<String>, _ optional: Parameter<Int?>) -> Self
        where Signature == (_ int: Int, _ labelString: String, _ string: String, _ optional: Int?) async -> Void {
            .init(
                method: Methods.withParamsVoidAsync_asyncint_int_Int_label_labelString_String__string_String__optional_Int_opt__ret_Void,
                parameters: [int.anyParameter, labelString.anyParameter, string.anyParameter, optional.anyParameter]
            )
        }

        public static func withParamsVoidAsyncThrowing(int: Parameter<Int>, label labelString: Parameter<String>, _ string: Parameter<String>, _ optional: Parameter<Int?>) -> Self
        where Signature == (_ int: Int, _ labelString: String, _ string: String, _ optional: Int?) async throws -> Void {
            .init(
                method: Methods.withParamsVoidAsyncThrowing_asyncint_int_Int_label_labelString_String__string_String__optional_Int_opt__ret_Void,
                parameters: [int.anyParameter, labelString.anyParameter, string.anyParameter, optional.anyParameter]
            )
        }

        public static func withParamsResult(int: Parameter<Int>, label labelString: Parameter<String>, _ string: Parameter<String>) -> Self
        where Signature == (_ int: Int, _ labelString: String, _ string: String) -> Int {
            .init(
                method: Methods.withParamsResult_syncint_int_Int_label_labelString_String__string_String_ret_Int,
                parameters: [int.anyParameter, labelString.anyParameter, string.anyParameter]
            )
        }

        public static func withParamsResult(otherInt: Parameter<Int>, label labelString: Parameter<String>, _ string: Parameter<String>) -> Self
        where Signature == (_ otherInt: Int, _ labelString: String, _ string: String) -> Int {
            .init(
                method: Methods.withParamsResult_syncotherInt_otherInt_Int_label_labelString_String__string_String_ret_Int,
                parameters: [otherInt.anyParameter, labelString.anyParameter, string.anyParameter]
            )
        }

        public static func withParamsResultAsync(int: Parameter<Int>, label labelString: Parameter<String>, _ string: Parameter<String>) -> Self
        where Signature == (_ int: Int, _ labelString: String, _ string: String) async -> Int {
            .init(
                method: Methods.withParamsResultAsync_asyncint_int_Int_label_labelString_String__string_String_ret_Int,
                parameters: [int.anyParameter, labelString.anyParameter, string.anyParameter]
            )
        }

        public static func withParamsAsyncThrowingResult(int: Parameter<Int>, label labelString: Parameter<String>, _ string: Parameter<String>) -> Self
        where Signature == (_ int: Int, _ labelString: String, _ string: String) async throws -> Int {
            .init(
                method: Methods.withParamsAsyncThrowingResult_asyncint_int_Int_label_labelString_String__string_String_ret_Int,
                parameters: [int.anyParameter, labelString.anyParameter, string.anyParameter]
            )
        }

        public static func generic<P1: Equatable, P2>(parameter1: Parameter<P1>, _ parameter2: Parameter<P2>) -> Self
        where Signature == (_ parameter1: P1, _ parameter2: P2) -> Int, P2: Hashable {
            .init(
                method: Methods.generic_syncparameter1_parameter1_P1__parameter2_P2_ret_IntwhereP2_col_Hashable,
                parameters: [parameter1.anyParameter, parameter2.anyParameter]
            )
        }

        @available(macOS 13, iOS 16, *)
        public static func generic(some: Parameter<some TestGenericProtocol<Int>>, any: Parameter<any TestGenericProtocol<String>>) -> Self
        where Signature == (_ some: any TestGenericProtocol<Int>, _ any: any TestGenericProtocol<String>) -> Int {
            .init(
                method: Methods.generic_syncsome_some_someTestGenericProtocol_lab_Int_rab__any_any_anyTestGenericProtocol_lab_String_rab__ret_Int,
                parameters: [some.anyParameter, any.anyParameter]
            )
        }

        @discardableResult
        public static func discardableResult() -> Self
        where Signature == () -> String {
            .init(
                method: Methods.discardableResult_sync_ret_String,
                parameters: []
            )
        }

        public static func closureAliasResult(_ closure: Parameter<ClosureAlias<Int>>) -> Self
        where Signature == (_ closure: (Int) -> Void) -> (Int) -> Void {
            .init(
                method: Methods.closureAliasResult_sync_closure_ClosureAlias_lab_Int_rab__ret_ClosureAlias_lab_Int_rab_,
                parameters: [closure.anyParameter]
            )
        }

        public static func closureAliasResultEquivalent(_ closure: Parameter<(Int) -> Void>) -> Self
        where Signature == (_ closure: (Int) -> Void) -> (Int) -> Void {
            .init(
                method: Methods.closureAliasResultEquivalent_sync_closure__lp_Int_rp__ret_Void_ret__lp_Int_rp__ret_Void,
                parameters: [closure.anyParameter]
            )
        }
    }

    public struct PropertyExpectation<Signature> {
        private let method: MockMethod

        init(method: MockMethod) {
            self.method = method
        }

        public var getterExpectation: Recorder.Expectation {
            .init(
                method: method,
                parameters: []
            )
        }

        public func setterExpectation(_ newValue: AnyParameter) -> Recorder.Expectation {
            .init(
                method: method,
                parameters: [newValue]
            )
        }
    }

    public struct SubscriptExpectation<Signature> {
        private let method: MockMethod
        private let parameters: [AnyParameter]

        init(method: MockMethod, parameters: [AnyParameter]) {
            self.method = method
            self.parameters = parameters
        }

        public var getterExpectation: Recorder.Expectation {
            .init(
                method: method,
                parameters: parameters
            )
        }

        public func setterExpectation(_ newValue: AnyParameter) -> Recorder.Expectation {
            .init(
                method: method,
                parameters: parameters + [newValue]
            )
        }

        public static var `subscript`: TestMockableMock.SubscriptExpectations { .init() }
    }

    public struct SubscriptExpectations {

        public subscript(key: Parameter<String>) -> TestMockableMock.SubscriptExpectation<(_ key: String) -> Int> {
            .init(
                method: Methods.subscript_get_by_key_key_String_Int,
                parameters: [key.anyParameter]
            )
        }
        
        public subscript(key: Parameter<String>) -> TestMockableMock.SubscriptExpectation<(String, _ newValue: Int) -> Void> {
            .init(
                method: Methods.subscript_set_by_key_key_String_Int,
                parameters: [key.anyParameter]
            )
        }

        public subscript(key: Parameter<Int>) -> TestMockableMock.SubscriptExpectation<(_ key: Int) -> String> {
            .init(
                method: Methods.subscript_get_by_key_key_Int_String,
                parameters: [key.anyParameter]
            )
        }
    }

    public let recorder = Recorder()

    private let fileID: String
    private let filePath: StaticString
    private let line: UInt
    private let column: Int

    public init(
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column
    ) {
        self.fileID = fileID
        self.filePath = filePath
        self.line = line
        self.column = column
    }

    private func _record<P>(
        _ expectation: Recorder.Expectation, 
        _ fileID: String,
        _ filePath: StaticString,
        _ line: UInt,
        _ column: Int,
        _ perform: P
    ) {
        guard isEnabled else {
            handleFatalFailure(
                "Setting expectation on disabled mock is not allowed",
                fileID: fileID,
                filePath: filePath,
                line: line,
                column: column
            )            
        }
        recorder.record(
            .init(
                expectation, 
                perform,
                fileID,
                filePath, 
                line,
                column
            )
        )
    }

    private func _perform(_ method: MockMethod, _ parameters: [Any?] = []) -> Any {
        let invocation = Invocation(
            method: method,
            parameters: parameters
        )
        guard let stub = recorder.next() else {
            handleFatalFailure(
                "Expected no calls but received `\(invocation)`", 
                fileID: fileID,
                filePath: filePath,
                line: line,
                column: column
            )
        }

        guard stub.matches(invocation) else {
            handleFatalFailure(
                "Unexpected call: expected `\(stub.expectation)`, but received `\(invocation)`",
                fileID: stub.fileID,
                filePath: stub.filePath,
                line: stub.line,
                column: stub.column
            )
        }

        defer { recorder.checkVerification() }
        return stub.perform
    }

    public func forceUnwrappedResult() -> String! {
        let perform = _perform(Methods.forceUnwrappedResult_sync_ret_String_impopt_) as! () -> String?
        return perform()
    }

    @available(iOS 15.0, *)
    public func newAPI() -> Void {
        let perform = _perform(Methods.newAPI_sync_ret_Void) as! () -> Void
        return perform()
    }

    public func noParamsVoid() -> Void {
        let perform = _perform(Methods.noParamsVoid_sync_ret_Void) as! () -> Void
        return perform()
    }

    public func noParamsVoidAsync() async -> Void {
        let perform = _perform(Methods.noParamsVoidAsync_async_ret_Void) as! () async -> Void
        return await perform()
    }

    public func noParamsVoidAsyncThrowing() async throws -> Void {
        let perform = _perform(Methods.noParamsVoidAsyncThrowing_async_ret_Void) as! () async throws -> Void
        return try await perform()
    }

    public func noParamsResult() -> Swift.Int {
        let perform = _perform(Methods.noParamsResult_sync_ret_Swift_Int) as! () -> Swift.Int
        return perform()
    }

    public func noParamsResult() -> Int? {
        let perform = _perform(Methods.noParamsResult_sync_ret_Int_opt_) as! () -> Int?
        return perform()
    }

    public func noParamsImplicitOptionalResult() -> Int! {
        let perform = _perform(Methods.noParamsImplicitOptionalResult_sync_ret_Int_impopt_) as! () -> Int?
        return perform()
    }

    public func noParamsArrayResult() -> [Int] {
        let perform = _perform(Methods.noParamsArrayResult_sync_ret__lsb_Int_rsb_) as! () -> [Int]
        return perform()
    }

    public func noParamsDictionaryResult() -> [String: Int] {
        let perform = _perform(Methods.noParamsDictionaryResult_sync_ret__lsb_String_col_Int_rsb_) as! () -> [String: Int]
        return perform()
    }

    public func noParamsClosureResult() -> (Int) -> Void {
        let perform = _perform(Methods.noParamsClosureResult_sync_ret__lp_Int_rp__ret_Void) as! () -> (Int) -> Void
        return perform()
    }

    public func noParamsResultAsync() async -> Int {
        let perform = _perform(Methods.noParamsResultAsync_async_ret_Int) as! () async -> Int
        return await perform()
    }

    public func noParamsAsyncThrowingResult() async throws -> Int {
        let perform = _perform(Methods.noParamsAsyncThrowingResult_async_ret_Int) as! () async throws -> Int
        return try await perform()
    }

    public func `func`() -> Void {
        let perform = _perform(Methods.func_sync_ret_Void) as! () -> Void
        return perform()
    }

    public func withSelf(_ self: TestMockableMock) -> Self {
        let perform = _perform(
            Methods.withSelf_sync_self_Self_ret_Self,
            [self]
        ) as! (_ self: TestMockableMock) -> Self
        return perform(self)
    }

    public func withOptionalClosure(_ closure: ((Int) -> Void)?) -> Void {
        let perform = _perform(
            Methods.withOptionalClosure_sync_closure__lp__lp_Int_rp__ret_Void_rp__opt__ret_Void,
            [closure]
        ) as! (_ closure: ((Int) -> Void)?) -> Void
        return perform(closure)
    }

    public func withAnnotatedClosure(_ closure: (@MainActor @Sendable (Int) -> Void)?) -> Void {
        let perform = _perform(
            Methods.withAnnotatedClosure_sync_closure__lp__lp_Int_rp__ret_Void_rp__opt__ret_Void,
            [closure]
        ) as! (_ closure: (@MainActor @Sendable (Int) -> Void)?) -> Void
        return perform(closure)
    }

    public func withParamsVoid(int: Swift.Int, label labelString: String, _ string: String, _ optional: Int?, _ implicitOptional: Int!, _ `inout`: inout Int, _ array: [Int], _ dictionary: [String: Int], _ escapingClosure: @escaping (Int) -> Void) -> Void {
        let perform = _perform(
            Methods.withParamsVoid_syncint_int_Swift_Int_label_labelString_String__string_String__optional_Int_opt___implicitOptional_Int_impopt___inout_inoutInt__array__lsb_Int_rsb___dictionary__lsb_String_col_Int_rsb___escapingClosure__lp_Int_rp__ret_Void_ret_Void,
            [int, labelString, string, optional, implicitOptional, `inout`, array, dictionary, escapingClosure]
        ) as! (_ int: Swift.Int, _ labelString: String, _ string: String, _ optional: Int?, _ implicitOptional: Int?, _ `inout`: inout Int, _ array: [Int], _ dictionary: [String: Int], _ escapingClosure: (Int) -> Void) -> Void
        return perform(int, labelString, string, optional, implicitOptional, &`inout`, array, dictionary, escapingClosure)
    }

    public func withParamsVoidAsync(int: Int, label labelString: String, _ string: String, _ optional: Int?) async -> Void {
        let perform = _perform(
            Methods.withParamsVoidAsync_asyncint_int_Int_label_labelString_String__string_String__optional_Int_opt__ret_Void,
            [int, labelString, string, optional]
        ) as! (_ int: Int, _ labelString: String, _ string: String, _ optional: Int?) async -> Void
        return await perform(int, labelString, string, optional)
    }

    public func withParamsVoidAsyncThrowing(int: Int, label labelString: String, _ string: String, _ optional: Int?) async throws -> Void {
        let perform = _perform(
            Methods.withParamsVoidAsyncThrowing_asyncint_int_Int_label_labelString_String__string_String__optional_Int_opt__ret_Void,
            [int, labelString, string, optional]
        ) as! (_ int: Int, _ labelString: String, _ string: String, _ optional: Int?) async throws -> Void
        return try await perform(int, labelString, string, optional)
    }

    public func withParamsResult(int: Int, label labelString: String, _ string: String) -> Int {
        let perform = _perform(
            Methods.withParamsResult_syncint_int_Int_label_labelString_String__string_String_ret_Int,
            [int, labelString, string]
        ) as! (_ int: Int, _ labelString: String, _ string: String) -> Int
        return perform(int, labelString, string)
    }

    public func withParamsResult(otherInt: Int, label labelString: String, _ string: String) -> Int {
        let perform = _perform(
            Methods.withParamsResult_syncotherInt_otherInt_Int_label_labelString_String__string_String_ret_Int,
            [otherInt, labelString, string]
        ) as! (_ otherInt: Int, _ labelString: String, _ string: String) -> Int
        return perform(otherInt, labelString, string)
    }

    public func withParamsResultAsync(int: Int, label labelString: String, _ string: String) async -> Int {
        let perform = _perform(
            Methods.withParamsResultAsync_asyncint_int_Int_label_labelString_String__string_String_ret_Int,
            [int, labelString, string]
        ) as! (_ int: Int, _ labelString: String, _ string: String) async -> Int
        return await perform(int, labelString, string)
    }

    public func withParamsAsyncThrowingResult(int: Int, label labelString: String, _ string: String) async throws -> Int {
        let perform = _perform(
            Methods.withParamsAsyncThrowingResult_asyncint_int_Int_label_labelString_String__string_String_ret_Int,
            [int, labelString, string]
        ) as! (_ int: Int, _ labelString: String, _ string: String) async throws -> Int
        return try await perform(int, labelString, string)
    }

    public func generic<P1: Equatable, P2>(parameter1: P1, _ parameter2: P2) -> Int {
        let perform = _perform(
            Methods.generic_syncparameter1_parameter1_P1__parameter2_P2_ret_IntwhereP2_col_Hashable,
            [parameter1, parameter2]
        ) as! (_ parameter1: P1, _ parameter2: P2) -> Int
        return perform(parameter1, parameter2)
    }

    @available(macOS 13, iOS 16, *)
    public func generic(some: some TestGenericProtocol<Int>, any: any TestGenericProtocol<String>) -> Int {
        let perform = _perform(
            Methods.generic_syncsome_some_someTestGenericProtocol_lab_Int_rab__any_any_anyTestGenericProtocol_lab_String_rab__ret_Int,
            [some, any]
        ) as! (_ some: any TestGenericProtocol<Int>, _ any: any TestGenericProtocol<String>) -> Int
        return perform(some, any)
    }

    @discardableResult
    public func discardableResult() -> String {
        let perform = _perform(Methods.discardableResult_sync_ret_String) as! () -> String
        return perform()
    }

    public func closureAliasResult(_ closure: @escaping ClosureAlias<Int>) -> (Int) -> Void {
        let perform = _perform(
            Methods.closureAliasResult_sync_closure_ClosureAlias_lab_Int_rab__ret_ClosureAlias_lab_Int_rab_,
            [closure]
        ) as! (_ closure: (Int) -> Void) -> (Int) -> Void
        return perform(closure)
    }

    public func closureAliasResultEquivalent(_ closure: @escaping (Int) -> Void) -> (Int) -> Void {
        let perform = _perform(
            Methods.closureAliasResultEquivalent_sync_closure__lp_Int_rp__ret_Void_ret__lp_Int_rp__ret_Void,
            [closure]
        ) as! (_ closure: (Int) -> Void) -> (Int) -> Void
        return perform(closure)
    }

    public var property: OnlyProperty {
        get {
            let perform = _perform(Methods.property_sync_ret_OnlyProperty) as! () -> OnlyProperty
            return perform()
        }
    }

    public var throwingProperty: Int {
        get throws {
            let perform = _perform(Methods.throwingProperty_sync_ret_Int) as! () throws -> Int
            return try perform()
        }
    }

    public var asyncProperty: Int {
        get async {
            let perform = _perform(Methods.asyncProperty_async_ret_Int) as! () async -> Int
            return await perform()
        }
    }

    public var asyncThrowingProperty: Int {
        get async throws {
            let perform = _perform(Methods.asyncThrowingProperty_async_ret_Int) as! () async throws -> Int
            return try await perform()
        }
    }

    public var readwriteProperty: Int {
        get {
            let perform = _perform(Methods.readwriteProperty_sync_ret_Int) as! () -> Int
            return perform()
        }
        set {
            let perform = _perform(
                Methods.set_readwriteProperty_sync_ret_Int,
                [newValue]
            ) as! (_ newValue: Int) -> Void
            return perform(newValue)
        }
    }

    public var forceUnwrapped: String! {
        get {
            let perform = _perform(Methods.forceUnwrapped_sync_ret_String_impopt_) as! () -> String?
            return perform()
        }
        set {
            let perform = _perform(
                Methods.set_forceUnwrapped_sync_ret_String_impopt_,
                [newValue]
            ) as! (_ newValue: String?) -> Void
            return perform(newValue)
        }
    }

    public subscript(key: String) -> Int {
        get {
            let perform = _perform(
                Methods.subscript_get_by_key_key_String_Int,
                [key]
            ) as! (_ key: String) -> Int
            return perform(key)
        }
        set {
            let perform = _perform(
                Methods.subscript_set_by_key_key_String_Int,
                [key, newValue]
            ) as! (String, _ newValue: Int) -> Void
            return perform(key, newValue)
        }
    }

    public subscript(key: Int) -> String {
        let perform = _perform(
            Methods.subscript_get_by_key_key_Int_String,
            [key]
        ) as! (_ key: Int) -> String
        return perform(key)
    }

    
    public func expect(
        _ expectation: MethodExpectation<() -> String?>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping () -> String?
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    @available(iOS 15.0, *)
    public func expect(
        _ expectation: MethodExpectation<() -> Void>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping () -> Void = {}
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    
    public func expect(
        _ expectation: MethodExpectation<() async -> Void>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping () async -> Void = {}
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    
    public func expect(
        _ expectation: MethodExpectation<() async throws -> Void>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping () async throws -> Void = {}
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    
    public func expect(
        _ expectation: MethodExpectation<() -> Swift.Int>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping () -> Swift.Int
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    
    public func expect(
        _ expectation: MethodExpectation<() -> Int?>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping () -> Int?
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    
    public func expect(
        _ expectation: MethodExpectation<() -> [Int]>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping () -> [Int]
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    
    public func expect(
        _ expectation: MethodExpectation<() -> [String: Int]>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping () -> [String: Int]
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    
    public func expect(
        _ expectation: MethodExpectation<() -> (Int) -> Void>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping () -> (Int) -> Void
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    
    public func expect(
        _ expectation: MethodExpectation<() async -> Int>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping () async -> Int
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    
    public func expect(
        _ expectation: MethodExpectation<() async throws -> Int>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping () async throws -> Int
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    
    public func expect(
        _ expectation: MethodExpectation<(_ self: TestMockableMock) -> TestMockableMock>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ self: TestMockableMock) -> TestMockableMock
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    
    public func expect(
        _ expectation: MethodExpectation<(_ closure: ((Int) -> Void)?) -> Void>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ closure: ((Int) -> Void)?) -> Void = { _ in }
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    
    public func expect(
        _ expectation: MethodExpectation<(_ closure: (@MainActor @Sendable (Int) -> Void)?) -> Void>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ closure: (@MainActor @Sendable (Int) -> Void)?) -> Void = { _ in }
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    
    public func expect(
        _ expectation: MethodExpectation<(_ int: Swift.Int, _ labelString: String, _ string: String, _ optional: Int?, _ implicitOptional: Int?, _ `inout`: inout Int, _ array: [Int], _ dictionary: [String: Int], _ escapingClosure: (Int) -> Void) -> Void>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ int: Swift.Int, _ labelString: String, _ string: String, _ optional: Int?, _ implicitOptional: Int?, _ `inout`: inout Int, _ array: [Int], _ dictionary: [String: Int], _ escapingClosure: (Int) -> Void) -> Void = { _, _, _, _, _, _, _, _, _ in }
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    
    public func expect(
        _ expectation: MethodExpectation<(_ int: Int, _ labelString: String, _ string: String, _ optional: Int?) async -> Void>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ int: Int, _ labelString: String, _ string: String, _ optional: Int?) async -> Void = { _, _, _, _ in }
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    
    public func expect(
        _ expectation: MethodExpectation<(_ int: Int, _ labelString: String, _ string: String, _ optional: Int?) async throws -> Void>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ int: Int, _ labelString: String, _ string: String, _ optional: Int?) async throws -> Void = { _, _, _, _ in }
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    
    public func expect(
        _ expectation: MethodExpectation<(_ int: Int, _ labelString: String, _ string: String) -> Int>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ int: Int, _ labelString: String, _ string: String) -> Int
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    
    public func expect(
        _ expectation: MethodExpectation<(_ int: Int, _ labelString: String, _ string: String) async -> Int>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ int: Int, _ labelString: String, _ string: String) async -> Int
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    
    public func expect(
        _ expectation: MethodExpectation<(_ int: Int, _ labelString: String, _ string: String) async throws -> Int>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ int: Int, _ labelString: String, _ string: String) async throws -> Int
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    
    public func expect<P1: Equatable, P2>(
        _ expectation: MethodExpectation<(_ parameter1: P1, _ parameter2: P2) -> Int>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ parameter1: P1, _ parameter2: P2) -> Int
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    @available(macOS 13, iOS 16, *)
    public func expect(
        _ expectation: MethodExpectation<(_ some: any TestGenericProtocol<Int>, _ any: any TestGenericProtocol<String>) -> Int>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ some: any TestGenericProtocol<Int>, _ any: any TestGenericProtocol<String>) -> Int
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    
    public func expect(
        _ expectation: MethodExpectation<() -> String>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping () -> String
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    
    public func expect(
        _ expectation: MethodExpectation<(_ closure: (Int) -> Void) -> (Int) -> Void>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ closure: (Int) -> Void) -> (Int) -> Void
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    public func expect(
        _ expectation: PropertyExpectation<() -> OnlyProperty>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping () -> OnlyProperty
    ) {
        _record(
            expectation.getterExpectation,
            fileID,
            filePath, 
            line,
            column,
            perform
        )
    }

    public func expect(
        _ expectation: PropertyExpectation<() throws -> Int>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping () throws -> Int
    ) {
        _record(
            expectation.getterExpectation,
            fileID,
            filePath, 
            line,
            column,
            perform
        )
    }

    public func expect(
        _ expectation: PropertyExpectation<() async -> Int>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping () async -> Int
    ) {
        _record(
            expectation.getterExpectation,
            fileID,
            filePath, 
            line,
            column,
            perform
        )
    }

    public func expect(
        _ expectation: PropertyExpectation<() async throws -> Int>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping () async throws -> Int
    ) {
        _record(
            expectation.getterExpectation,
            fileID,
            filePath, 
            line,
            column,
            perform
        )
    }

    public func expect(
        _ expectation: PropertyExpectation<() -> Int>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping () -> Int
    ) {
        _record(
            expectation.getterExpectation,
            fileID,
            filePath, 
            line,
            column,
            perform
        )
    }

    public func expect(
        _ expectation: PropertyExpectation<() -> String?>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping () -> String?
    ) {
        _record(
            expectation.getterExpectation,
            fileID,
            filePath, 
            line,
            column,
            perform
        )
    }

    public func expect(
        set expectation: PropertyExpectation<(_ newValue: OnlyProperty) -> Void>,
        to newValue: Parameter<OnlyProperty>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ newValue: OnlyProperty) -> Void = { _ in }
    ) {
        _record(
            expectation.setterExpectation(newValue.anyParameter),
            fileID,
            filePath, 
            line,
            column,
            perform
        )
    }

    public func expect(
        set expectation: PropertyExpectation<(_ newValue: Int) -> Void>,
        to newValue: Parameter<Int>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ newValue: Int) -> Void = { _ in }
    ) {
        _record(
            expectation.setterExpectation(newValue.anyParameter),
            fileID,
            filePath, 
            line,
            column,
            perform
        )
    }

    public func expect(
        set expectation: PropertyExpectation<(_ newValue: String?) -> Void>,
        to newValue: Parameter<String?>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ newValue: String?) -> Void = { _ in }
    ) {
        _record(
            expectation.setterExpectation(newValue.anyParameter),
            fileID,
            filePath, 
            line,
            column,
            perform
        )
    }

    public func expect(
        _ expectation: SubscriptExpectation<(_ key: String) -> Int>,
        file: StaticString = #filePath,
        line: UInt = #line,
        perform: @escaping (_ key: String) -> Int
    ) {
        _record(
            expectation.getterExpectation,
            fileID,
            filePath, 
            line,
            column,
            perform
        )
    }

    public func expect(
        _ expectation: SubscriptExpectation<(_ key: Int) -> String>,
        file: StaticString = #filePath,
        line: UInt = #line,
        perform: @escaping (_ key: Int) -> String
    ) {
        _record(
            expectation.getterExpectation,
            fileID,
            filePath, 
            line,
            column,
            perform
        )
    }

    public func expect(
        set expectation: SubscriptExpectation<(String, _ newValue: Int) -> Void>,
        to newValue: Parameter<Int>,
        file: StaticString = #filePath,
        line: UInt = #line,
        perform: @escaping (String, _ newValue: Int) -> Void = {  _, _ in  }
    ) {
        _record(
            expectation.setterExpectation(newValue.anyParameter),
            fileID,
            filePath, 
            line,
            column,
            perform
        )
    }


}

public extension TestMockableMock.PropertyExpectation where Signature == () -> OnlyProperty {
    static var property: Self {
        .init(method: TestMockableMock.Methods.property_sync_ret_OnlyProperty)
    }
}

public extension TestMockableMock.PropertyExpectation where Signature == () throws -> Int {
    static var throwingProperty: Self {
        .init(method: TestMockableMock.Methods.throwingProperty_sync_ret_Int)
    }
}

public extension TestMockableMock.PropertyExpectation where Signature == () async -> Int {
    static var asyncProperty: Self {
        .init(method: TestMockableMock.Methods.asyncProperty_async_ret_Int)
    }
}

public extension TestMockableMock.PropertyExpectation where Signature == () async throws -> Int {
    static var asyncThrowingProperty: Self {
        .init(method: TestMockableMock.Methods.asyncThrowingProperty_async_ret_Int)
    }
}

public extension TestMockableMock.PropertyExpectation where Signature == () -> Int {
    static var readwriteProperty: Self {
        .init(method: TestMockableMock.Methods.readwriteProperty_sync_ret_Int)
    }
}

public extension TestMockableMock.PropertyExpectation where Signature == (_ newValue: Int) -> Void {
    static var readwriteProperty: Self {
        .init(method: TestMockableMock.Methods.set_readwriteProperty_sync_ret_Int)
    }
}

public extension TestMockableMock.PropertyExpectation where Signature == () -> String? {
    static var forceUnwrapped: Self {
        .init(method: TestMockableMock.Methods.forceUnwrapped_sync_ret_String_impopt_)
    }
}

public extension TestMockableMock.PropertyExpectation where Signature == (_ newValue: String?) -> Void {
    static var forceUnwrapped: Self {
        .init(method: TestMockableMock.Methods.set_forceUnwrapped_sync_ret_String_impopt_)
    }
}

open class TestMockableClassMock: TestMockableClass, Mock {

    enum Methods {
        static var noParamsVoid_sync_ret_Void: MockMethod {
            .init { _ in
                "noParamsVoid()"
            }
        }
        static var noParamsVoidAsync_async_ret_Void: MockMethod {
            .init { _ in
                "noParamsVoidAsync()"
            }
        }
        static var noParamsVoidAsyncThrowing_async_ret_Void: MockMethod {
            .init { _ in
                "noParamsVoidAsyncThrowing()"
            }
        }
        static var noParamsResult_sync_ret_Int: MockMethod {
            .init { _ in
                "noParamsResult()"
            }
        }
        static var noParamsResultAsync_async_ret_Int: MockMethod {
            .init { _ in
                "noParamsResultAsync()"
            }
        }
        static var noParamsAsyncThrowingResult_async_ret_Int: MockMethod {
            .init { _ in
                "noParamsAsyncThrowingResult()"
            }
        }
        static var withParamsVoid_syncint_int_Int_label_labelString_String__string_String_ret_Void: MockMethod {
            .init {
                "withParamsVoid(int: \($0[0] ?? "nil"), label: \"\($0[1]!)\", \"\($0[2]!)\")"
            }
        }
        static var withParamsVoidAsync_asyncint_int_Int_label_labelString_String__string_String_ret_Void: MockMethod {
            .init {
                "withParamsVoidAsync(int: \($0[0] ?? "nil"), label: \"\($0[1]!)\", \"\($0[2]!)\")"
            }
        }
        static var withParamsVoidAsyncThrowing_asyncint_int_Int_label_labelString_String__string_String_ret_Void: MockMethod {
            .init {
                "withParamsVoidAsyncThrowing(int: \($0[0] ?? "nil"), label: \"\($0[1]!)\", \"\($0[2]!)\")"
            }
        }
        static var withParamsResult_syncint_int_Int_label_labelString_String__string_String_ret_Int: MockMethod {
            .init {
                "withParamsResult(int: \($0[0] ?? "nil"), label: \"\($0[1]!)\", \"\($0[2]!)\")"
            }
        }
        static var withParamsResultAsync_asyncint_int_Int_label_labelString_String__string_String_ret_Int: MockMethod {
            .init {
                "withParamsResultAsync(int: \($0[0] ?? "nil"), label: \"\($0[1]!)\", \"\($0[2]!)\")"
            }
        }
        static var withParamsAsyncThrowingResult_asyncint_int_Int_label_labelString_String__string_String_ret_Int: MockMethod {
            .init {
                "withParamsAsyncThrowingResult(int: \($0[0] ?? "nil"), label: \"\($0[1]!)\", \"\($0[2]!)\")"
            }
        }
        static var openMethod_sync_ret_Void: MockMethod {
            .init { _ in
                "openMethod()"
            }
        }
        static var superNoParamsVoid_sync_ret_Void: MockMethod {
            .init { _ in
                "superNoParamsVoid()"
            }
        }
        static var readwriteProperty_sync_ret_Int: MockMethod {
            .init { _ in
                "readwriteProperty"
            }
        }
        static var set_readwriteProperty_sync_ret_Int: MockMethod {
            .init {
                "readwriteProperty = \($0[0] ?? "nil")"
            }
        }
        static var privateSettableProperty_sync_ret_Int: MockMethod {
            .init { _ in
                "privateSettableProperty"
            }
        }
        static var sideEffectProperty_sync_ret_Int: MockMethod {
            .init { _ in
                "sideEffectProperty"
            }
        }
        static var set_sideEffectProperty_sync_ret_Int: MockMethod {
            .init {
                "sideEffectProperty = \($0[0] ?? "nil")"
            }
        }
    }

    public struct MethodExpectation<Signature> {
        public let expectation: Recorder.Expectation

        init(method: MockMethod, parameters: [AnyParameter]) {
            self.expectation = .init(
                method: method,
                parameters: parameters
            )
        }

        public static func noParamsVoid() -> Self
        where Signature == () -> Void {
            .init(
                method: Methods.noParamsVoid_sync_ret_Void,
                parameters: []
            )
        }

        public static func noParamsVoidAsync() -> Self
        where Signature == () async -> Void {
            .init(
                method: Methods.noParamsVoidAsync_async_ret_Void,
                parameters: []
            )
        }

        public static func noParamsVoidAsyncThrowing() -> Self
        where Signature == () async throws -> Void {
            .init(
                method: Methods.noParamsVoidAsyncThrowing_async_ret_Void,
                parameters: []
            )
        }

        public static func noParamsResult() -> Self
        where Signature == () -> Int {
            .init(
                method: Methods.noParamsResult_sync_ret_Int,
                parameters: []
            )
        }

        public static func noParamsResultAsync() -> Self
        where Signature == () async -> Int {
            .init(
                method: Methods.noParamsResultAsync_async_ret_Int,
                parameters: []
            )
        }

        public static func noParamsAsyncThrowingResult() -> Self
        where Signature == () async throws -> Int {
            .init(
                method: Methods.noParamsAsyncThrowingResult_async_ret_Int,
                parameters: []
            )
        }

        public static func withParamsVoid(int: Parameter<Int>, label labelString: Parameter<String>, _ string: Parameter<String>) -> Self
        where Signature == (_ int: Int, _ labelString: String, _ string: String) -> Void {
            .init(
                method: Methods.withParamsVoid_syncint_int_Int_label_labelString_String__string_String_ret_Void,
                parameters: [int.anyParameter, labelString.anyParameter, string.anyParameter]
            )
        }

        public static func withParamsVoidAsync(int: Parameter<Int>, label labelString: Parameter<String>, _ string: Parameter<String>) -> Self
        where Signature == (_ int: Int, _ labelString: String, _ string: String) async -> Void {
            .init(
                method: Methods.withParamsVoidAsync_asyncint_int_Int_label_labelString_String__string_String_ret_Void,
                parameters: [int.anyParameter, labelString.anyParameter, string.anyParameter]
            )
        }

        public static func withParamsVoidAsyncThrowing(int: Parameter<Int>, label labelString: Parameter<String>, _ string: Parameter<String>) -> Self
        where Signature == (_ int: Int, _ labelString: String, _ string: String) async throws -> Void {
            .init(
                method: Methods.withParamsVoidAsyncThrowing_asyncint_int_Int_label_labelString_String__string_String_ret_Void,
                parameters: [int.anyParameter, labelString.anyParameter, string.anyParameter]
            )
        }

        public static func withParamsResult(int: Parameter<Int>, label labelString: Parameter<String>, _ string: Parameter<String>) -> Self
        where Signature == (_ int: Int, _ labelString: String, _ string: String) -> Int {
            .init(
                method: Methods.withParamsResult_syncint_int_Int_label_labelString_String__string_String_ret_Int,
                parameters: [int.anyParameter, labelString.anyParameter, string.anyParameter]
            )
        }

        public static func withParamsResultAsync(int: Parameter<Int>, label labelString: Parameter<String>, _ string: Parameter<String>) -> Self
        where Signature == (_ int: Int, _ labelString: String, _ string: String) async -> Int {
            .init(
                method: Methods.withParamsResultAsync_asyncint_int_Int_label_labelString_String__string_String_ret_Int,
                parameters: [int.anyParameter, labelString.anyParameter, string.anyParameter]
            )
        }

        public static func withParamsAsyncThrowingResult(int: Parameter<Int>, label labelString: Parameter<String>, _ string: Parameter<String>) -> Self
        where Signature == (_ int: Int, _ labelString: String, _ string: String) async throws -> Int {
            .init(
                method: Methods.withParamsAsyncThrowingResult_asyncint_int_Int_label_labelString_String__string_String_ret_Int,
                parameters: [int.anyParameter, labelString.anyParameter, string.anyParameter]
            )
        }

        public static func openMethod() -> Self
        where Signature == () -> Void {
            .init(
                method: Methods.openMethod_sync_ret_Void,
                parameters: []
            )
        }

        public static func superNoParamsVoid() -> Self
        where Signature == () -> Void {
            .init(
                method: Methods.superNoParamsVoid_sync_ret_Void,
                parameters: []
            )
        }
    }

    public struct PropertyExpectation<Signature> {
        private let method: MockMethod

        init(method: MockMethod) {
            self.method = method
        }

        public var getterExpectation: Recorder.Expectation {
            .init(
                method: method,
                parameters: []
            )
        }

        public func setterExpectation(_ newValue: AnyParameter) -> Recorder.Expectation {
            .init(
                method: method,
                parameters: [newValue]
            )
        }
    }

    public let recorder = Recorder()

    private let fileID: String
    private let filePath: StaticString
    private let line: UInt
    private let column: Int


    @available(*, unavailable)
    public required init() {
        fatalError()
    }

    public init(int: Int, 
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column
    ) {
        self.fileID = fileID
        self.filePath = filePath
        self.line = line
        self.column = column
        self.autoForwardingEnabled = true
        super.init(int: int)
        self.autoForwardingEnabled = false
    }

    public init(string: String, 
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column
    ) {
        self.fileID = fileID
        self.filePath = filePath
        self.line = line
        self.column = column
        self.autoForwardingEnabled = true
        super.init(string: string)
        self.autoForwardingEnabled = false
    }

    public init(
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column
    ) {
        self.fileID = fileID
        self.filePath = filePath
        self.line = line
        self.column = column
        self.autoForwardingEnabled = true
        super.init()
        self.autoForwardingEnabled = false
    }

    public var autoForwardingEnabled: Bool

    public var isEnabled: Bool {
        !autoForwardingEnabled
    }

    private func _record<P>(
        _ expectation: Recorder.Expectation, 
        _ fileID: String,
        _ filePath: StaticString,
        _ line: UInt,
        _ column: Int,
        _ perform: P
    ) {
        guard isEnabled else {
            handleFatalFailure(
                "Setting expectation on disabled mock is not allowed",
                fileID: fileID,
                filePath: filePath,
                line: line,
                column: column
            )            
        }
        recorder.record(
            .init(
                expectation, 
                perform,
                fileID,
                filePath, 
                line,
                column
            )
        )
    }

    private func _perform(_ method: MockMethod, _ parameters: [Any?] = []) -> Any {
        let invocation = Invocation(
            method: method,
            parameters: parameters
        )
        guard let stub = recorder.next() else {
            handleFatalFailure(
                "Expected no calls but received `\(invocation)`", 
                fileID: fileID,
                filePath: filePath,
                line: line,
                column: column
            )
        }

        guard stub.matches(invocation) else {
            handleFatalFailure(
                "Unexpected call: expected `\(stub.expectation)`, but received `\(invocation)`",
                fileID: stub.fileID,
                filePath: stub.filePath,
                line: stub.line,
                column: stub.column
            )
        }

        defer { recorder.checkVerification() }
        return stub.perform
    }

    public override func noParamsVoid() -> Void {
        guard !autoForwardingEnabled else {
            return super.noParamsVoid()
        }
        let perform = _perform(Methods.noParamsVoid_sync_ret_Void) as! (_ forwardToOriginal: () -> Void) -> Void
        return perform(super.noParamsVoid)
    }

    public override func noParamsVoidAsync() async -> Void {
        guard !autoForwardingEnabled else {
            return await super.noParamsVoidAsync()
        }
        let perform = _perform(Methods.noParamsVoidAsync_async_ret_Void) as! (_ forwardToOriginal: () async -> Void) async -> Void
        return await perform(super.noParamsVoidAsync)
    }

    public override func noParamsVoidAsyncThrowing() async throws -> Void {
        guard !autoForwardingEnabled else {
            return try await super.noParamsVoidAsyncThrowing()
        }
        let perform = _perform(Methods.noParamsVoidAsyncThrowing_async_ret_Void) as! (_ forwardToOriginal: () async throws -> Void) async throws -> Void
        return try await perform(super.noParamsVoidAsyncThrowing)
    }

    public override func noParamsResult() -> Int {
        guard !autoForwardingEnabled else {
            return super.noParamsResult()
        }
        let perform = _perform(Methods.noParamsResult_sync_ret_Int) as! (_ forwardToOriginal: () -> Int) -> Int
        return perform(super.noParamsResult)
    }

    public override func noParamsResultAsync() async -> Int {
        guard !autoForwardingEnabled else {
            return await super.noParamsResultAsync()
        }
        let perform = _perform(Methods.noParamsResultAsync_async_ret_Int) as! (_ forwardToOriginal: () async -> Int) async -> Int
        return await perform(super.noParamsResultAsync)
    }

    public override func noParamsAsyncThrowingResult() async throws -> Int {
        guard !autoForwardingEnabled else {
            return try await super.noParamsAsyncThrowingResult()
        }
        let perform = _perform(Methods.noParamsAsyncThrowingResult_async_ret_Int) as! (_ forwardToOriginal: () async throws -> Int) async throws -> Int
        return try await perform(super.noParamsAsyncThrowingResult)
    }

    public override func withParamsVoid(int: Int, label labelString: String, _ string: String) -> Void {
        guard !autoForwardingEnabled else {
            return super.withParamsVoid(int: int, label: labelString, string)
        }
        let perform = _perform(
            Methods.withParamsVoid_syncint_int_Int_label_labelString_String__string_String_ret_Void,
            [int, labelString, string]
        ) as! (_ forwardToOriginal: (_ int: Int, _ labelString: String, _ string: String) -> Void, _ int: Int, _ labelString: String, _ string: String) -> Void
        return perform(super.withParamsVoid(int:label:_:), int, labelString, string)
    }

    public override func withParamsVoidAsync(int: Int, label labelString: String, _ string: String) async -> Void {
        guard !autoForwardingEnabled else {
            return await super.withParamsVoidAsync(int: int, label: labelString, string)
        }
        let perform = _perform(
            Methods.withParamsVoidAsync_asyncint_int_Int_label_labelString_String__string_String_ret_Void,
            [int, labelString, string]
        ) as! (_ forwardToOriginal: (_ int: Int, _ labelString: String, _ string: String) async -> Void, _ int: Int, _ labelString: String, _ string: String) async -> Void
        return await perform(super.withParamsVoidAsync(int:label:_:), int, labelString, string)
    }

    public override func withParamsVoidAsyncThrowing(int: Int, label labelString: String, _ string: String) async throws -> Void {
        guard !autoForwardingEnabled else {
            return try await super.withParamsVoidAsyncThrowing(int: int, label: labelString, string)
        }
        let perform = _perform(
            Methods.withParamsVoidAsyncThrowing_asyncint_int_Int_label_labelString_String__string_String_ret_Void,
            [int, labelString, string]
        ) as! (_ forwardToOriginal: (_ int: Int, _ labelString: String, _ string: String) async throws -> Void, _ int: Int, _ labelString: String, _ string: String) async throws -> Void
        return try await perform(super.withParamsVoidAsyncThrowing(int:label:_:), int, labelString, string)
    }

    public override func withParamsResult(int: Int, label labelString: String, _ string: String) -> Int {
        guard !autoForwardingEnabled else {
            return super.withParamsResult(int: int, label: labelString, string)
        }
        let perform = _perform(
            Methods.withParamsResult_syncint_int_Int_label_labelString_String__string_String_ret_Int,
            [int, labelString, string]
        ) as! (_ forwardToOriginal: (_ int: Int, _ labelString: String, _ string: String) -> Int, _ int: Int, _ labelString: String, _ string: String) -> Int
        return perform(super.withParamsResult(int:label:_:), int, labelString, string)
    }

    public override func withParamsResultAsync(int: Int, label labelString: String, _ string: String) async -> Int {
        guard !autoForwardingEnabled else {
            return await super.withParamsResultAsync(int: int, label: labelString, string)
        }
        let perform = _perform(
            Methods.withParamsResultAsync_asyncint_int_Int_label_labelString_String__string_String_ret_Int,
            [int, labelString, string]
        ) as! (_ forwardToOriginal: (_ int: Int, _ labelString: String, _ string: String) async -> Int, _ int: Int, _ labelString: String, _ string: String) async -> Int
        return await perform(super.withParamsResultAsync(int:label:_:), int, labelString, string)
    }

    public override func withParamsAsyncThrowingResult(int: Int, label labelString: String, _ string: String) async throws -> Int {
        guard !autoForwardingEnabled else {
            return try await super.withParamsAsyncThrowingResult(int: int, label: labelString, string)
        }
        let perform = _perform(
            Methods.withParamsAsyncThrowingResult_asyncint_int_Int_label_labelString_String__string_String_ret_Int,
            [int, labelString, string]
        ) as! (_ forwardToOriginal: (_ int: Int, _ labelString: String, _ string: String) async throws -> Int, _ int: Int, _ labelString: String, _ string: String) async throws -> Int
        return try await perform(super.withParamsAsyncThrowingResult(int:label:_:), int, labelString, string)
    }

    public override func openMethod() -> Void {
        guard !autoForwardingEnabled else {
            return super.openMethod()
        }
        let perform = _perform(Methods.openMethod_sync_ret_Void) as! (_ forwardToOriginal: () -> Void) -> Void
        return perform(super.openMethod)
    }

    public override func superNoParamsVoid() -> Void {
        guard !autoForwardingEnabled else {
            return super.superNoParamsVoid()
        }
        let perform = _perform(Methods.superNoParamsVoid_sync_ret_Void) as! (_ forwardToOriginal: () -> Void) -> Void
        return perform(super.superNoParamsVoid)
    }

    public override var readwriteProperty: Int {
        get {
            guard !autoForwardingEnabled else {
                return super.readwriteProperty
            }
            let perform = _perform(Methods.readwriteProperty_sync_ret_Int) as! (_ forwardToOriginal: () -> Int) -> Int
            return perform({ super.readwriteProperty })
        }
        set {
            guard !autoForwardingEnabled else {
                super.readwriteProperty = newValue
                return
            }
            let perform = _perform(
                Methods.set_readwriteProperty_sync_ret_Int,
                [newValue]
            ) as! (_ forwardToOriginal: (_ newValue: Int) -> Void, _ newValue: Int) -> Void
            return perform({ super.readwriteProperty = $0 }, newValue)
        }
    }

    public override var privateSettableProperty: Int {
        get {
            guard !autoForwardingEnabled else {
                return super.privateSettableProperty
            }
            let perform = _perform(Methods.privateSettableProperty_sync_ret_Int) as! (_ forwardToOriginal: () -> Int) -> Int
            return perform({ super.privateSettableProperty })
        }
    }

    public override var sideEffectProperty: Int {
        get {
            guard !autoForwardingEnabled else {
                return super.sideEffectProperty
            }
            let perform = _perform(Methods.sideEffectProperty_sync_ret_Int) as! (_ forwardToOriginal: () -> Int) -> Int
            return perform({ super.sideEffectProperty })
        }
        set {
            guard !autoForwardingEnabled else {
                super.sideEffectProperty = newValue
                return
            }
            let perform = _perform(
                Methods.set_sideEffectProperty_sync_ret_Int,
                [newValue]
            ) as! (_ forwardToOriginal: (_ newValue: Int) -> Void, _ newValue: Int) -> Void
            return perform({ super.sideEffectProperty = $0 }, newValue)
        }
    }

    
    public func expect(
        _ expectation: MethodExpectation<() -> Void>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ forwardToOriginal: () -> Void) -> Void = { _forwardToSuper in
            _forwardToSuper()
        }
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    
    public func expect(
        _ expectation: MethodExpectation<() async -> Void>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ forwardToOriginal: () async -> Void) async -> Void = { _forwardToSuper in
            await _forwardToSuper()
        }
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    
    public func expect(
        _ expectation: MethodExpectation<() async throws -> Void>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ forwardToOriginal: () async throws -> Void) async throws -> Void = { _forwardToSuper in
            try await _forwardToSuper()
        }
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    
    public func expect(
        _ expectation: MethodExpectation<() -> Int>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ forwardToOriginal: () -> Int) -> Int = { _forwardToSuper in
            _forwardToSuper()
        }
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    
    public func expect(
        _ expectation: MethodExpectation<() async -> Int>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ forwardToOriginal: () async -> Int) async -> Int = { _forwardToSuper in
            await _forwardToSuper()
        }
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    
    public func expect(
        _ expectation: MethodExpectation<() async throws -> Int>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ forwardToOriginal: () async throws -> Int) async throws -> Int = { _forwardToSuper in
            try await _forwardToSuper()
        }
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    
    public func expect(
        _ expectation: MethodExpectation<(_ int: Int, _ labelString: String, _ string: String) -> Void>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ forwardToOriginal: (_ int: Int, _ labelString: String, _ string: String) -> Void, _ int: Int, _ labelString: String, _ string: String) -> Void = { _forwardToSuper, int, labelString, string in
            _forwardToSuper(int, labelString, string)
        }
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    
    public func expect(
        _ expectation: MethodExpectation<(_ int: Int, _ labelString: String, _ string: String) async -> Void>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ forwardToOriginal: (_ int: Int, _ labelString: String, _ string: String) async -> Void, _ int: Int, _ labelString: String, _ string: String) async -> Void = { _forwardToSuper, int, labelString, string in
            await _forwardToSuper(int, labelString, string)
        }
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    
    public func expect(
        _ expectation: MethodExpectation<(_ int: Int, _ labelString: String, _ string: String) async throws -> Void>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ forwardToOriginal: (_ int: Int, _ labelString: String, _ string: String) async throws -> Void, _ int: Int, _ labelString: String, _ string: String) async throws -> Void = { _forwardToSuper, int, labelString, string in
            try await _forwardToSuper(int, labelString, string)
        }
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    
    public func expect(
        _ expectation: MethodExpectation<(_ int: Int, _ labelString: String, _ string: String) -> Int>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ forwardToOriginal: (_ int: Int, _ labelString: String, _ string: String) -> Int, _ int: Int, _ labelString: String, _ string: String) -> Int = { _forwardToSuper, int, labelString, string in
            _forwardToSuper(int, labelString, string)
        }
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    
    public func expect(
        _ expectation: MethodExpectation<(_ int: Int, _ labelString: String, _ string: String) async -> Int>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ forwardToOriginal: (_ int: Int, _ labelString: String, _ string: String) async -> Int, _ int: Int, _ labelString: String, _ string: String) async -> Int = { _forwardToSuper, int, labelString, string in
            await _forwardToSuper(int, labelString, string)
        }
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    
    public func expect(
        _ expectation: MethodExpectation<(_ int: Int, _ labelString: String, _ string: String) async throws -> Int>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ forwardToOriginal: (_ int: Int, _ labelString: String, _ string: String) async throws -> Int, _ int: Int, _ labelString: String, _ string: String) async throws -> Int = { _forwardToSuper, int, labelString, string in
            try await _forwardToSuper(int, labelString, string)
        }
    ) {
        _record(
            expectation.expectation,
            fileID,
            filePath,
            line,
            column,
            perform
        )
    }

    public func expect(
        _ expectation: PropertyExpectation<() -> Int>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ forwardToOriginal: () -> Int) -> Int = { $0() }
    ) {
        _record(
            expectation.getterExpectation,
            fileID,
            filePath, 
            line,
            column,
            perform
        )
    }

    public func expect(
        set expectation: PropertyExpectation<(_ newValue: Int) -> Void>,
        to newValue: Parameter<Int>,
        fileID: String = #fileID,
        filePath: StaticString = #filePath,
        line: UInt = #line,
        column: Int = #column,
        perform: @escaping (_ forwardToOriginal: (_ newValue: Int) -> Void, _ newValue: Int) -> Void = { $0($1) }
    ) {
        _record(
            expectation.setterExpectation(newValue.anyParameter),
            fileID,
            filePath, 
            line,
            column,
            perform
        )
    }
}

public extension TestMockableClassMock.PropertyExpectation where Signature == () -> Int {
    static var readwriteProperty: Self {
        .init(method: TestMockableClassMock.Methods.readwriteProperty_sync_ret_Int)
    }
}

public extension TestMockableClassMock.PropertyExpectation where Signature == (_ newValue: Int) -> Void {
    static var readwriteProperty: Self {
        .init(method: TestMockableClassMock.Methods.set_readwriteProperty_sync_ret_Int)
    }
}

public extension TestMockableClassMock.PropertyExpectation where Signature == () -> Int {
    static var privateSettableProperty: Self {
        .init(method: TestMockableClassMock.Methods.privateSettableProperty_sync_ret_Int)
    }
}

public extension TestMockableClassMock.PropertyExpectation where Signature == () -> Int {
    static var sideEffectProperty: Self {
        .init(method: TestMockableClassMock.Methods.sideEffectProperty_sync_ret_Int)
    }
}

public extension TestMockableClassMock.PropertyExpectation where Signature == (_ newValue: Int) -> Void {
    static var sideEffectProperty: Self {
        .init(method: TestMockableClassMock.Methods.set_sideEffectProperty_sync_ret_Int)
    }
}